/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const CFE_SPACECRAFT_ID: ::std::os::raw::c_uint = 66;
pub const CFE_SB_TIME_32_16_SUBS: ::std::os::raw::c_uint = 1;
pub const CFE_SB_TIME_32_32_SUBS: ::std::os::raw::c_uint = 2;
pub const CFE_SB_TIME_32_32_M_20: ::std::os::raw::c_uint = 3;
pub const CFE_SB_PACKET_TIME_FORMAT: ::std::os::raw::c_uint = 1;
pub const CFE_SB_MAX_SB_MSG_SIZE: ::std::os::raw::c_uint = 32768;
pub const CFE_TIME_MIN_ELAPSED: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_MAX_ELAPSED: ::std::os::raw::c_uint = 200000;
pub const CFE_TIME_DEF_MET_SECS: ::std::os::raw::c_uint = 1000;
pub const CFE_TIME_DEF_MET_SUBS: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_DEF_STCF_SECS: ::std::os::raw::c_uint = 1000000;
pub const CFE_TIME_DEF_STCF_SUBS: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_DEF_LEAPS: ::std::os::raw::c_uint = 32;
pub const CFE_TIME_DEF_DELAY_SECS: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_DEF_DELAY_SUBS: ::std::os::raw::c_uint = 1000;
pub const CFE_TIME_EPOCH_YEAR: ::std::os::raw::c_uint = 1980;
pub const CFE_TIME_EPOCH_DAY: ::std::os::raw::c_uint = 1;
pub const CFE_TIME_EPOCH_HOUR: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_EPOCH_MINUTE: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_EPOCH_SECOND: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_FS_FACTOR: ::std::os::raw::c_uint = 789004800;
pub const CFE_ES_CDS_MAX_NAME_LENGTH: ::std::os::raw::c_uint = 16;
pub const CFE_EVS_MAX_MESSAGE_LENGTH: ::std::os::raw::c_uint = 122;
pub const CFE_ES_CRC_8: ::std::os::raw::c_uint = 1;
pub const CFE_ES_CRC_16: ::std::os::raw::c_uint = 2;
pub const CFE_ES_CRC_32: ::std::os::raw::c_uint = 3;
pub const CFE_ES_DEFAULT_CRC: ::std::os::raw::c_uint = 2;
pub const CFE_TBL_MAX_NAME_LENGTH: ::std::os::raw::c_uint = 16;
pub const CFE_CMD_MID_BASE_CPU1: ::std::os::raw::c_uint = 6144;
pub const CFE_TLM_MID_BASE_CPU1: ::std::os::raw::c_uint = 2048;
pub const CFE_CMD_APPID_BASE_CPU1: ::std::os::raw::c_uint = 1;
pub const CFE_TLM_APPID_BASE_CPU1: ::std::os::raw::c_uint = 0;
pub const CFE_CMD_MID_BASE_CPU2: ::std::os::raw::c_uint = 6176;
pub const CFE_TLM_MID_BASE_CPU2: ::std::os::raw::c_uint = 2080;
pub const CFE_CMD_APPID_BASE_CPU2: ::std::os::raw::c_uint = 33;
pub const CFE_TLM_APPID_BASE_CPU2: ::std::os::raw::c_uint = 32;
pub const CFE_CMD_MID_BASE_CPU3: ::std::os::raw::c_uint = 6208;
pub const CFE_TLM_MID_BASE_CPU3: ::std::os::raw::c_uint = 2112;
pub const CFE_CMD_APPID_BASE_CPU3: ::std::os::raw::c_uint = 65;
pub const CFE_TLM_APPID_BASE_CPU3: ::std::os::raw::c_uint = 64;
pub const CFE_CMD_MID_BASE_GLOB: ::std::os::raw::c_uint = 6240;
pub const CFE_TLM_MID_BASE_GLOB: ::std::os::raw::c_uint = 2144;
pub const CFE_EVS_CMD_MSG: ::std::os::raw::c_uint = 1;
pub const CFE_SB_CMD_MSG: ::std::os::raw::c_uint = 3;
pub const CFE_TBL_CMD_MSG: ::std::os::raw::c_uint = 4;
pub const CFE_TIME_CMD_MSG: ::std::os::raw::c_uint = 5;
pub const CFE_ES_CMD_MSG: ::std::os::raw::c_uint = 6;
pub const CFE_ES_SEND_HK_MSG: ::std::os::raw::c_uint = 8;
pub const CFE_EVS_SEND_HK_MSG: ::std::os::raw::c_uint = 9;
pub const CFE_SB_SEND_HK_MSG: ::std::os::raw::c_uint = 11;
pub const CFE_TBL_SEND_HK_MSG: ::std::os::raw::c_uint = 12;
pub const CFE_TIME_SEND_HK_MSG: ::std::os::raw::c_uint = 13;
pub const CFE_TIME_TONE_CMD_MSG: ::std::os::raw::c_uint = 16;
pub const CFE_TIME_1HZ_CMD_MSG: ::std::os::raw::c_uint = 17;
pub const CFE_TIME_DATA_CMD_MSG: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_FAKE_CMD_MSG: ::std::os::raw::c_uint = 1;
pub const CFE_TIME_SEND_CMD_MSG: ::std::os::raw::c_uint = 2;
pub const CFE_ES_HK_TLM_MSG: ::std::os::raw::c_uint = 0;
pub const CFE_EVS_HK_TLM_MSG: ::std::os::raw::c_uint = 1;
pub const CFE_SB_HK_TLM_MSG: ::std::os::raw::c_uint = 3;
pub const CFE_TBL_HK_TLM_MSG: ::std::os::raw::c_uint = 4;
pub const CFE_TIME_HK_TLM_MSG: ::std::os::raw::c_uint = 5;
pub const CFE_TIME_DIAG_TLM_MSG: ::std::os::raw::c_uint = 6;
pub const CFE_EVS_EVENT_MSG_MSG: ::std::os::raw::c_uint = 8;
pub const CFE_SB_STATS_TLM_MSG: ::std::os::raw::c_uint = 10;
pub const CFE_ES_APP_TLM_MSG: ::std::os::raw::c_uint = 11;
pub const CFE_TBL_REG_TLM_MSG: ::std::os::raw::c_uint = 12;
pub const CFE_SB_ALLSUBS_TLM_MSG: ::std::os::raw::c_uint = 13;
pub const CFE_SB_ONESUB_TLM_MSG: ::std::os::raw::c_uint = 14;
pub const CFE_ES_SHELL_TLM_MSG: ::std::os::raw::c_uint = 15;
pub const CFE_ES_MEMSTATS_TLM_MSG: ::std::os::raw::c_uint = 16;
pub const CFE_EVS_CMD_MID: ::std::os::raw::c_uint = 6145;
pub const CFE_SB_CMD_MID: ::std::os::raw::c_uint = 6147;
pub const CFE_TBL_CMD_MID: ::std::os::raw::c_uint = 6148;
pub const CFE_TIME_CMD_MID: ::std::os::raw::c_uint = 6149;
pub const CFE_ES_CMD_MID: ::std::os::raw::c_uint = 6150;
pub const CFE_ES_SEND_HK_MID: ::std::os::raw::c_uint = 6152;
pub const CFE_EVS_SEND_HK_MID: ::std::os::raw::c_uint = 6153;
pub const CFE_SB_SEND_HK_MID: ::std::os::raw::c_uint = 6155;
pub const CFE_TBL_SEND_HK_MID: ::std::os::raw::c_uint = 6156;
pub const CFE_TIME_SEND_HK_MID: ::std::os::raw::c_uint = 6157;
pub const CFE_TIME_TONE_CMD_MID: ::std::os::raw::c_uint = 6160;
pub const CFE_TIME_1HZ_CMD_MID: ::std::os::raw::c_uint = 6161;
pub const CFE_TIME_DATA_CMD_MID: ::std::os::raw::c_uint = 6240;
pub const CFE_TIME_FAKE_CMD_MID: ::std::os::raw::c_uint = 6241;
pub const CFE_TIME_SEND_CMD_MID: ::std::os::raw::c_uint = 6242;
pub const CFE_ES_HK_TLM_MID: ::std::os::raw::c_uint = 2048;
pub const CFE_EVS_HK_TLM_MID: ::std::os::raw::c_uint = 2049;
pub const CFE_SB_HK_TLM_MID: ::std::os::raw::c_uint = 2051;
pub const CFE_TBL_HK_TLM_MID: ::std::os::raw::c_uint = 2052;
pub const CFE_TIME_HK_TLM_MID: ::std::os::raw::c_uint = 2053;
pub const CFE_TIME_DIAG_TLM_MID: ::std::os::raw::c_uint = 2054;
pub const CFE_EVS_EVENT_MSG_MID: ::std::os::raw::c_uint = 2056;
pub const CFE_SB_STATS_TLM_MID: ::std::os::raw::c_uint = 2058;
pub const CFE_ES_APP_TLM_MID: ::std::os::raw::c_uint = 2059;
pub const CFE_TBL_REG_TLM_MID: ::std::os::raw::c_uint = 2060;
pub const CFE_SB_ALLSUBS_TLM_MID: ::std::os::raw::c_uint = 2061;
pub const CFE_SB_ONESUB_TLM_MID: ::std::os::raw::c_uint = 2062;
pub const CFE_ES_SHELL_TLM_MID: ::std::os::raw::c_uint = 2063;
pub const CFE_ES_MEMSTATS_TLM_MID: ::std::os::raw::c_uint = 2064;
pub const CFE_CPU_ID: ::std::os::raw::c_uint = 1;
pub const CFE_CPU_NAME: &'static [u8; 5usize] = b"CPU1\x00";
pub const CFE_SB_MAX_MSG_IDS: ::std::os::raw::c_uint = 256;
pub const CFE_SB_MAX_PIPES: ::std::os::raw::c_uint = 64;
pub const CFE_SB_MAX_DEST_PER_PKT: ::std::os::raw::c_uint = 16;
pub const CFE_SB_DEFAULT_MSG_LIMIT: ::std::os::raw::c_uint = 4;
pub const CFE_SB_BUF_MEMORY_BYTES: ::std::os::raw::c_uint = 524288;
pub const CFE_SB_MAX_PIPE_DEPTH: ::std::os::raw::c_uint = 256;
pub const CFE_SB_HIGHEST_VALID_MSGID: ::std::os::raw::c_uint = 8191;
pub const CFE_SB_DEFAULT_ROUTING_FILENAME: &'static [u8; 22usize] =
    b"/ram/cfe_sb_route.dat\x00";
pub const CFE_SB_DEFAULT_PIPE_FILENAME: &'static [u8; 21usize] =
    b"/ram/cfe_sb_pipe.dat\x00";
pub const CFE_SB_DEFAULT_MAP_FILENAME: &'static [u8; 23usize] =
    b"/ram/cfe_sb_msgmap.dat\x00";
pub const CFE_SB_FILTERED_EVENT5: ::std::os::raw::c_uint = 0;
pub const CFE_SB_FILTERED_EVENT6: ::std::os::raw::c_uint = 0;
pub const CFE_SB_FILTERED_EVENT7: ::std::os::raw::c_uint = 0;
pub const CFE_SB_FILTERED_EVENT8: ::std::os::raw::c_uint = 0;
pub const CFE_SB_MEM_BLOCK_SIZE_01: ::std::os::raw::c_uint = 8;
pub const CFE_SB_MEM_BLOCK_SIZE_02: ::std::os::raw::c_uint = 16;
pub const CFE_SB_MEM_BLOCK_SIZE_03: ::std::os::raw::c_uint = 20;
pub const CFE_SB_MEM_BLOCK_SIZE_04: ::std::os::raw::c_uint = 36;
pub const CFE_SB_MEM_BLOCK_SIZE_05: ::std::os::raw::c_uint = 64;
pub const CFE_SB_MEM_BLOCK_SIZE_06: ::std::os::raw::c_uint = 96;
pub const CFE_SB_MEM_BLOCK_SIZE_07: ::std::os::raw::c_uint = 128;
pub const CFE_SB_MEM_BLOCK_SIZE_08: ::std::os::raw::c_uint = 160;
pub const CFE_SB_MEM_BLOCK_SIZE_09: ::std::os::raw::c_uint = 256;
pub const CFE_SB_MEM_BLOCK_SIZE_10: ::std::os::raw::c_uint = 512;
pub const CFE_SB_MEM_BLOCK_SIZE_11: ::std::os::raw::c_uint = 1024;
pub const CFE_SB_MEM_BLOCK_SIZE_12: ::std::os::raw::c_uint = 2048;
pub const CFE_SB_MEM_BLOCK_SIZE_13: ::std::os::raw::c_uint = 4096;
pub const CFE_SB_MEM_BLOCK_SIZE_14: ::std::os::raw::c_uint = 8192;
pub const CFE_SB_MEM_BLOCK_SIZE_15: ::std::os::raw::c_uint = 16384;
pub const CFE_SB_MEM_BLOCK_SIZE_16: ::std::os::raw::c_uint = 32768;
pub const CFE_SB_MAX_BLOCK_SIZE: ::std::os::raw::c_uint = 32808;
pub const CFE_SB_DEFAULT_REPORT_SENDER: ::std::os::raw::c_uint = 1;
pub const CFE_TIME_MAX_DELTA_SECS: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_MAX_DELTA_SUBS: ::std::os::raw::c_uint = 500000;
pub const CFE_TIME_MAX_LOCAL_SECS: ::std::os::raw::c_uint = 27;
pub const CFE_TIME_MAX_LOCAL_SUBS: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_CFG_TONE_LIMIT: ::std::os::raw::c_uint = 20000;
pub const CFE_TIME_CFG_START_FLY: ::std::os::raw::c_uint = 2;
pub const CFE_TIME_CFG_LATCH_FLY: ::std::os::raw::c_uint = 8;
pub const CFE_TIME_MAX_NUM_SYNCH_FUNCS: ::std::os::raw::c_uint = 4;
pub const CFE_ES_MAX_APPLICATIONS: ::std::os::raw::c_uint = 32;
pub const CFE_ES_MAX_LIBRARIES: ::std::os::raw::c_uint = 10;
pub const CFE_ES_ER_LOG_ENTRIES: ::std::os::raw::c_uint = 20;
pub const CFE_ES_ER_LOG_MAX_CONTEXT_SIZE: ::std::os::raw::c_uint = 128;
pub const CFE_ES_SYSTEM_LOG_SIZE: ::std::os::raw::c_uint = 3072;
pub const CFE_ES_OBJECT_TABLE_SIZE: ::std::os::raw::c_uint = 30;
pub const CFE_ES_MAX_GEN_COUNTERS: ::std::os::raw::c_uint = 8;
pub const CFE_ES_APP_SCAN_RATE: ::std::os::raw::c_uint = 1000;
pub const CFE_ES_APP_KILL_TIMEOUT: ::std::os::raw::c_uint = 5;
pub const CFE_ES_RAM_DISK_SECTOR_SIZE: ::std::os::raw::c_uint = 512;
pub const CFE_ES_RAM_DISK_NUM_SECTORS: ::std::os::raw::c_uint = 4096;
pub const CFE_ES_RAM_DISK_PERCENT_RESERVED: ::std::os::raw::c_uint = 30;
pub const CFE_ES_RAM_DISK_MOUNT_STRING: &'static [u8; 5usize] = b"/ram\x00";
pub const CFE_ES_CDS_SIZE: ::std::os::raw::c_uint = 131072;
pub const CFE_ES_USER_RESERVED_SIZE: ::std::os::raw::c_uint = 1048576;
pub const CFE_ES_RESET_AREA_SIZE: ::std::os::raw::c_uint = 174080;
pub const CFE_ES_MEMPOOL_ALIGNED: ::std::os::raw::c_uint = 1;
pub const CFE_ES_NONVOL_STARTUP_FILE: &'static [u8; 28usize] =
    b"/cf/apps/cfe_es_startup.scr\x00";
pub const CFE_ES_VOLATILE_STARTUP_FILE: &'static [u8; 29usize] =
    b"/ram/apps/cfe_es_startup.scr\x00";
pub const CFE_ES_DEFAULT_SHELL_FILENAME: &'static [u8; 18usize] =
    b"/ram/ShellCmd.out\x00";
pub const CFE_ES_MAX_SHELL_CMD: ::std::os::raw::c_uint = 64;
pub const CFE_ES_MAX_SHELL_PKT: ::std::os::raw::c_uint = 64;
pub const CFE_ES_DEFAULT_APP_LOG_FILE: &'static [u8; 25usize] =
    b"/ram/cfe_es_app_info.log\x00";
pub const CFE_ES_DEFAULT_TASK_LOG_FILE: &'static [u8; 26usize] =
    b"/ram/cfe_es_task_info.log\x00";
pub const CFE_ES_DEFAULT_SYSLOG_FILE: &'static [u8; 23usize] =
    b"/ram/cfe_es_syslog.log\x00";
pub const CFE_ES_DEFAULT_ER_LOG_FILE: &'static [u8; 19usize] =
    b"/ram/cfe_erlog.log\x00";
pub const CFE_ES_DEFAULT_PERF_DUMP_FILENAME: &'static [u8; 21usize] =
    b"/ram/cfe_es_perf.dat\x00";
pub const CFE_ES_DEFAULT_CDS_REG_DUMP_FILE: &'static [u8; 21usize] =
    b"/ram/cfe_cds_reg.log\x00";
pub const CFE_ES_DEFAULT_SYSLOG_MODE: ::std::os::raw::c_uint = 1;
pub const CFE_ES_PERF_MAX_IDS: ::std::os::raw::c_uint = 128;
pub const CFE_ES_PERF_DATA_BUFFER_SIZE: ::std::os::raw::c_uint = 10000;
pub const CFE_ES_PERF_FILTMASK_NONE: ::std::os::raw::c_uint = 0;
pub const CFE_ES_PERF_FILTMASK_ALL: ::std::os::raw::c_int = -1;
pub const CFE_ES_PERF_FILTMASK_INIT: ::std::os::raw::c_int = -1;
pub const CFE_ES_PERF_TRIGMASK_NONE: ::std::os::raw::c_uint = 0;
pub const CFE_ES_PERF_TRIGMASK_ALL: ::std::os::raw::c_int = -1;
pub const CFE_ES_PERF_TRIGMASK_INIT: ::std::os::raw::c_uint = 0;
pub const CFE_ES_PERF_CHILD_PRIORITY: ::std::os::raw::c_uint = 200;
pub const CFE_ES_PERF_CHILD_STACK_SIZE: ::std::os::raw::c_uint = 4096;
pub const CFE_ES_PERF_CHILD_MS_DELAY: ::std::os::raw::c_uint = 20;
pub const CFE_ES_PERF_ENTRIES_BTWN_DLYS: ::std::os::raw::c_uint = 50;
pub const CFE_ES_DEFAULT_STACK_SIZE: ::std::os::raw::c_uint = 8192;
pub const CFE_EVS_START_TASK_PRIORITY: ::std::os::raw::c_uint = 61;
pub const CFE_EVS_START_TASK_STACK_SIZE: ::std::os::raw::c_uint = 8192;
pub const CFE_SB_START_TASK_PRIORITY: ::std::os::raw::c_uint = 64;
pub const CFE_SB_START_TASK_STACK_SIZE: ::std::os::raw::c_uint = 8192;
pub const CFE_ES_START_TASK_PRIORITY: ::std::os::raw::c_uint = 68;
pub const CFE_ES_START_TASK_STACK_SIZE: ::std::os::raw::c_uint = 16384;
pub const CFE_TIME_START_TASK_PRIORITY: ::std::os::raw::c_uint = 60;
pub const CFE_TIME_TONE_TASK_PRIORITY: ::std::os::raw::c_uint = 25;
pub const CFE_TIME_1HZ_TASK_PRIORITY: ::std::os::raw::c_uint = 25;
pub const CFE_TIME_START_TASK_STACK_SIZE: ::std::os::raw::c_uint = 8192;
pub const CFE_TIME_TONE_TASK_STACK_SIZE: ::std::os::raw::c_uint = 4096;
pub const CFE_TIME_1HZ_TASK_STACK_SIZE: ::std::os::raw::c_uint = 8192;
pub const CFE_TBL_START_TASK_PRIORITY: ::std::os::raw::c_uint = 70;
pub const CFE_TBL_START_TASK_STACK_SIZE: ::std::os::raw::c_uint = 8192;
pub const CFE_ES_CDS_MAX_NUM_ENTRIES: ::std::os::raw::c_uint = 512;
pub const CFE_ES_MAX_PROCESSOR_RESETS: ::std::os::raw::c_uint = 2;
pub const CFE_ES_MEM_BLOCK_SIZE_01: ::std::os::raw::c_uint = 8;
pub const CFE_ES_MEM_BLOCK_SIZE_02: ::std::os::raw::c_uint = 16;
pub const CFE_ES_MEM_BLOCK_SIZE_03: ::std::os::raw::c_uint = 32;
pub const CFE_ES_MEM_BLOCK_SIZE_04: ::std::os::raw::c_uint = 48;
pub const CFE_ES_MEM_BLOCK_SIZE_05: ::std::os::raw::c_uint = 64;
pub const CFE_ES_MEM_BLOCK_SIZE_06: ::std::os::raw::c_uint = 96;
pub const CFE_ES_MEM_BLOCK_SIZE_07: ::std::os::raw::c_uint = 128;
pub const CFE_ES_MEM_BLOCK_SIZE_08: ::std::os::raw::c_uint = 160;
pub const CFE_ES_MEM_BLOCK_SIZE_09: ::std::os::raw::c_uint = 256;
pub const CFE_ES_MEM_BLOCK_SIZE_10: ::std::os::raw::c_uint = 512;
pub const CFE_ES_MEM_BLOCK_SIZE_11: ::std::os::raw::c_uint = 1024;
pub const CFE_ES_MEM_BLOCK_SIZE_12: ::std::os::raw::c_uint = 2048;
pub const CFE_ES_MEM_BLOCK_SIZE_13: ::std::os::raw::c_uint = 4096;
pub const CFE_ES_MEM_BLOCK_SIZE_14: ::std::os::raw::c_uint = 8192;
pub const CFE_ES_MEM_BLOCK_SIZE_15: ::std::os::raw::c_uint = 16384;
pub const CFE_ES_MEM_BLOCK_SIZE_16: ::std::os::raw::c_uint = 32768;
pub const CFE_ES_MAX_BLOCK_SIZE: ::std::os::raw::c_uint = 80000;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_01: ::std::os::raw::c_uint = 8;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_02: ::std::os::raw::c_uint = 16;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_03: ::std::os::raw::c_uint = 32;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_04: ::std::os::raw::c_uint = 48;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_05: ::std::os::raw::c_uint = 64;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_06: ::std::os::raw::c_uint = 96;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_07: ::std::os::raw::c_uint = 128;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_08: ::std::os::raw::c_uint = 160;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_09: ::std::os::raw::c_uint = 256;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_10: ::std::os::raw::c_uint = 512;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_11: ::std::os::raw::c_uint = 1024;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_12: ::std::os::raw::c_uint = 2048;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_13: ::std::os::raw::c_uint = 4096;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_14: ::std::os::raw::c_uint = 8192;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_15: ::std::os::raw::c_uint = 16384;
pub const CFE_ES_CDS_MEM_BLOCK_SIZE_16: ::std::os::raw::c_uint = 32768;
pub const CFE_ES_CDS_MAX_BLOCK_SIZE: ::std::os::raw::c_uint = 80000;
pub const CFE_EVS_MAX_EVENT_FILTERS: ::std::os::raw::c_uint = 8;
pub const CFE_EVS_DEFAULT_LOG_FILE: &'static [u8; 17usize] =
    b"/ram/cfe_evs.log\x00";
pub const CFE_EVS_LOG_MAX: ::std::os::raw::c_uint = 20;
pub const CFE_EVS_DEFAULT_APP_DATA_FILE: &'static [u8; 21usize] =
    b"/ram/cfe_evs_app.dat\x00";
pub const CFE_EVS_PORT_DEFAULT: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_DEFAULT_TYPE_FLAG: ::std::os::raw::c_uint = 14;
pub const CFE_EVS_DEFAULT_LOG_MODE: ::std::os::raw::c_uint = 1;
pub const CFE_TBL_BUF_MEMORY_BYTES: ::std::os::raw::c_uint = 524288;
pub const CFE_TBL_MAX_DBL_TABLE_SIZE: ::std::os::raw::c_uint = 16384;
pub const CFE_TBL_MAX_SNGL_TABLE_SIZE: ::std::os::raw::c_uint = 16384;
pub const CFE_TBL_MAX_NUM_TABLES: ::std::os::raw::c_uint = 128;
pub const CFE_TBL_MAX_CRITICAL_TABLES: ::std::os::raw::c_uint = 32;
pub const CFE_TBL_MAX_NUM_HANDLES: ::std::os::raw::c_uint = 256;
pub const CFE_TBL_MAX_SIMULTANEOUS_LOADS: ::std::os::raw::c_uint = 4;
pub const CFE_TBL_MAX_NUM_VALIDATIONS: ::std::os::raw::c_uint = 10;
pub const CFE_TBL_DEFAULT_REG_DUMP_FILE: &'static [u8; 21usize] =
    b"/ram/cfe_tbl_reg.log\x00";
pub const CFE_TBL_VALID_SCID_COUNT: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_VALID_SCID_1: ::std::os::raw::c_uint = 66;
pub const CFE_TBL_VALID_PRID_COUNT: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_VALID_PRID_1: ::std::os::raw::c_uint = 1;
pub const CFE_TBL_VALID_PRID_3: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_VALID_PRID_4: ::std::os::raw::c_uint = 0;
pub const CFE_MISSION_REV: ::std::os::raw::c_uint = 0;
pub const CFE_ES_STARTUP_SYNC_POLL_MSEC: ::std::os::raw::c_uint = 50;
pub const CFE_CORE_MAX_STARTUP_MSEC: ::std::os::raw::c_uint = 30000;
pub const CFE_ES_STARTUP_SCRIPT_TIMEOUT_MSEC: ::std::os::raw::c_uint = 30000;
pub const TRUE: ::std::os::raw::c_uint = 1;
pub const FALSE: ::std::os::raw::c_uint = 0;
pub const CCSDS_TIME_SIZE: ::std::os::raw::c_uint = 6;
pub const CCSDS_TLM: ::std::os::raw::c_uint = 0;
pub const CCSDS_CMD: ::std::os::raw::c_uint = 1;
pub const CCSDS_NO_SEC_HDR: ::std::os::raw::c_uint = 0;
pub const CCSDS_HAS_SEC_HDR: ::std::os::raw::c_uint = 1;
pub const NUM_CCSDS_APIDS: ::std::os::raw::c_uint = 2048;
pub const NUM_CCSDS_PKT_TYPES: ::std::os::raw::c_uint = 2;
pub const CCSDS_INIT_SEQ: ::std::os::raw::c_uint = 0;
pub const CCSDS_INIT_SEQFLG: ::std::os::raw::c_uint = 3;
pub const CCSDS_INIT_FC: ::std::os::raw::c_uint = 0;
pub const CCSDS_INIT_CHECKSUM: ::std::os::raw::c_uint = 0;
pub const OS_SUCCESS: ::std::os::raw::c_uint = 0;
pub const OS_ERROR: ::std::os::raw::c_int = -1;
pub const OS_INVALID_POINTER: ::std::os::raw::c_int = -2;
pub const OS_ERROR_ADDRESS_MISALIGNED: ::std::os::raw::c_int = -3;
pub const OS_ERROR_TIMEOUT: ::std::os::raw::c_int = -4;
pub const OS_INVALID_INT_NUM: ::std::os::raw::c_int = -5;
pub const OS_SEM_FAILURE: ::std::os::raw::c_int = -6;
pub const OS_SEM_TIMEOUT: ::std::os::raw::c_int = -7;
pub const OS_QUEUE_EMPTY: ::std::os::raw::c_int = -8;
pub const OS_QUEUE_FULL: ::std::os::raw::c_int = -9;
pub const OS_QUEUE_TIMEOUT: ::std::os::raw::c_int = -10;
pub const OS_QUEUE_INVALID_SIZE: ::std::os::raw::c_int = -11;
pub const OS_QUEUE_ID_ERROR: ::std::os::raw::c_int = -12;
pub const OS_ERR_NAME_TOO_LONG: ::std::os::raw::c_int = -13;
pub const OS_ERR_NO_FREE_IDS: ::std::os::raw::c_int = -14;
pub const OS_ERR_NAME_TAKEN: ::std::os::raw::c_int = -15;
pub const OS_ERR_INVALID_ID: ::std::os::raw::c_int = -16;
pub const OS_ERR_NAME_NOT_FOUND: ::std::os::raw::c_int = -17;
pub const OS_ERR_SEM_NOT_FULL: ::std::os::raw::c_int = -18;
pub const OS_ERR_INVALID_PRIORITY: ::std::os::raw::c_int = -19;
pub const OS_INVALID_SEM_VALUE: ::std::os::raw::c_int = -20;
pub const OS_ERR_FILE: ::std::os::raw::c_int = -27;
pub const OS_ERR_NOT_IMPLEMENTED: ::std::os::raw::c_int = -28;
pub const OS_TIMER_ERR_INVALID_ARGS: ::std::os::raw::c_int = -29;
pub const OS_TIMER_ERR_TIMER_ID: ::std::os::raw::c_int = -30;
pub const OS_TIMER_ERR_UNAVAILABLE: ::std::os::raw::c_int = -31;
pub const OS_TIMER_ERR_INTERNAL: ::std::os::raw::c_int = -32;
pub const OS_PEND: ::std::os::raw::c_int = -1;
pub const OS_CHECK: ::std::os::raw::c_uint = 0;
pub const OS_MAJOR_VERSION: ::std::os::raw::c_uint = 4;
pub const OS_MINOR_VERSION: ::std::os::raw::c_uint = 2;
pub const OS_REVISION: ::std::os::raw::c_uint = 1;
pub const OS_MISSION_REV: ::std::os::raw::c_uint = 0;
pub const OSAL_API_VERSION: ::std::os::raw::c_uint = 40201;
pub const OS_MAX_TASKS: ::std::os::raw::c_uint = 64;
pub const OS_MAX_QUEUES: ::std::os::raw::c_uint = 64;
pub const OS_MAX_COUNT_SEMAPHORES: ::std::os::raw::c_uint = 20;
pub const OS_MAX_BIN_SEMAPHORES: ::std::os::raw::c_uint = 20;
pub const OS_MAX_MUTEXES: ::std::os::raw::c_uint = 20;
pub const OS_MAX_PATH_LEN: ::std::os::raw::c_uint = 64;
pub const OS_MAX_API_NAME: ::std::os::raw::c_uint = 20;
pub const OS_MAX_FILE_NAME: ::std::os::raw::c_uint = 20;
pub const OS_BUFFER_SIZE: ::std::os::raw::c_uint = 172;
pub const OS_BUFFER_MSG_DEPTH: ::std::os::raw::c_uint = 100;
pub const OS_UTILITYTASK_STACK_SIZE: ::std::os::raw::c_uint = 2048;
pub const OS_UTILITYTASK_PRIORITY: ::std::os::raw::c_uint = 245;
pub const OS_MAX_CMD_LEN: ::std::os::raw::c_uint = 1000;
pub const OS_MAX_NUM_OPEN_FILES: ::std::os::raw::c_uint = 50;
pub const OS_SHELL_CMD_INPUT_FILE_NAME: &'static [u8; 20usize] =
    b"/ram/OS_ShellCmd.in\x00";
pub const OS_MAX_MODULES: ::std::os::raw::c_uint = 20;
pub const OS_MAX_SYM_LEN: ::std::os::raw::c_uint = 64;
pub const OS_MAX_TIMEBASES: ::std::os::raw::c_uint = 5;
pub const OS_MAX_TIMERS: ::std::os::raw::c_uint = 5;
pub const OS_MAX_NUM_OPEN_DIRS: ::std::os::raw::c_uint = 4;
pub const OS_QUEUE_MAX_DEPTH: ::std::os::raw::c_uint = 50;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const OS_SEM_FULL: ::std::os::raw::c_uint = 1;
pub const OS_SEM_EMPTY: ::std::os::raw::c_uint = 0;
pub const OS_FP_ENABLED: ::std::os::raw::c_uint = 1;
pub const OS_ERROR_NAME_LENGTH: ::std::os::raw::c_uint = 35;
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 23;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __ENUM_IDTYPE_T: ::std::os::raw::c_uint = 1;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _DIRENT_H: ::std::os::raw::c_uint = 1;
pub const _DIRENT_MATCHES_DIRENT64: ::std::os::raw::c_uint = 1;
pub const _BITS_POSIX1_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const NR_OPEN: ::std::os::raw::c_uint = 1024;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 65536;
pub const ARG_MAX: ::std::os::raw::c_uint = 131072;
pub const LINK_MAX: ::std::os::raw::c_uint = 127;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const PATH_MAX: ::std::os::raw::c_uint = 4096;
pub const PIPE_BUF: ::std::os::raw::c_uint = 4096;
pub const XATTR_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const XATTR_SIZE_MAX: ::std::os::raw::c_uint = 65536;
pub const XATTR_LIST_MAX: ::std::os::raw::c_uint = 65536;
pub const RTSIG_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 20;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 16384;
pub const DELAYTIMER_MAX: ::std::os::raw::c_uint = 2147483647;
pub const TTY_NAME_MAX: ::std::os::raw::c_uint = 32;
pub const LOGIN_NAME_MAX: ::std::os::raw::c_uint = 256;
pub const HOST_NAME_MAX: ::std::os::raw::c_uint = 64;
pub const MQ_PRIO_MAX: ::std::os::raw::c_uint = 32768;
pub const SEM_VALUE_MAX: ::std::os::raw::c_uint = 2147483647;
pub const MAXNAMLEN: ::std::os::raw::c_uint = 255;
pub const _SYS_STAT_H: ::std::os::raw::c_uint = 1;
pub const _BITS_STAT_H: ::std::os::raw::c_uint = 1;
pub const _STAT_VER_KERNEL: ::std::os::raw::c_uint = 0;
pub const _STAT_VER_LINUX: ::std::os::raw::c_uint = 1;
pub const _MKNOD_VER_LINUX: ::std::os::raw::c_uint = 0;
pub const _STAT_VER: ::std::os::raw::c_uint = 1;
pub const __S_IFMT: ::std::os::raw::c_uint = 61440;
pub const __S_IFDIR: ::std::os::raw::c_uint = 16384;
pub const __S_IFCHR: ::std::os::raw::c_uint = 8192;
pub const __S_IFBLK: ::std::os::raw::c_uint = 24576;
pub const __S_IFREG: ::std::os::raw::c_uint = 32768;
pub const __S_IFIFO: ::std::os::raw::c_uint = 4096;
pub const __S_IFLNK: ::std::os::raw::c_uint = 40960;
pub const __S_IFSOCK: ::std::os::raw::c_uint = 49152;
pub const __S_ISUID: ::std::os::raw::c_uint = 2048;
pub const __S_ISGID: ::std::os::raw::c_uint = 1024;
pub const __S_ISVTX: ::std::os::raw::c_uint = 512;
pub const __S_IREAD: ::std::os::raw::c_uint = 256;
pub const __S_IWRITE: ::std::os::raw::c_uint = 128;
pub const __S_IEXEC: ::std::os::raw::c_uint = 64;
pub const UTIME_NOW: ::std::os::raw::c_uint = 1073741823;
pub const UTIME_OMIT: ::std::os::raw::c_uint = 1073741822;
pub const S_IFMT: ::std::os::raw::c_uint = 61440;
pub const S_IFDIR: ::std::os::raw::c_uint = 16384;
pub const S_IFCHR: ::std::os::raw::c_uint = 8192;
pub const S_IFBLK: ::std::os::raw::c_uint = 24576;
pub const S_IFREG: ::std::os::raw::c_uint = 32768;
pub const S_IFIFO: ::std::os::raw::c_uint = 4096;
pub const S_IFLNK: ::std::os::raw::c_uint = 40960;
pub const S_IFSOCK: ::std::os::raw::c_uint = 49152;
pub const S_ISUID: ::std::os::raw::c_uint = 2048;
pub const S_ISGID: ::std::os::raw::c_uint = 1024;
pub const S_ISVTX: ::std::os::raw::c_uint = 512;
pub const S_IRUSR: ::std::os::raw::c_uint = 256;
pub const S_IWUSR: ::std::os::raw::c_uint = 128;
pub const S_IXUSR: ::std::os::raw::c_uint = 64;
pub const S_IRWXU: ::std::os::raw::c_uint = 448;
pub const S_IREAD: ::std::os::raw::c_uint = 256;
pub const S_IWRITE: ::std::os::raw::c_uint = 128;
pub const S_IEXEC: ::std::os::raw::c_uint = 64;
pub const S_IRGRP: ::std::os::raw::c_uint = 32;
pub const S_IWGRP: ::std::os::raw::c_uint = 16;
pub const S_IXGRP: ::std::os::raw::c_uint = 8;
pub const S_IRWXG: ::std::os::raw::c_uint = 56;
pub const S_IROTH: ::std::os::raw::c_uint = 4;
pub const S_IWOTH: ::std::os::raw::c_uint = 2;
pub const S_IXOTH: ::std::os::raw::c_uint = 1;
pub const S_IRWXO: ::std::os::raw::c_uint = 7;
pub const ACCESSPERMS: ::std::os::raw::c_uint = 511;
pub const ALLPERMS: ::std::os::raw::c_uint = 4095;
pub const DEFFILEMODE: ::std::os::raw::c_uint = 438;
pub const S_BLKSIZE: ::std::os::raw::c_uint = 512;
pub const _MKNOD_VER: ::std::os::raw::c_uint = 0;
pub const OS_READ_ONLY: ::std::os::raw::c_uint = 0;
pub const OS_WRITE_ONLY: ::std::os::raw::c_uint = 1;
pub const OS_READ_WRITE: ::std::os::raw::c_uint = 2;
pub const OS_SEEK_SET: ::std::os::raw::c_uint = 0;
pub const OS_SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const OS_SEEK_END: ::std::os::raw::c_uint = 2;
pub const OS_CHK_ONLY: ::std::os::raw::c_uint = 0;
pub const OS_REPAIR: ::std::os::raw::c_uint = 1;
pub const FS_BASED: ::std::os::raw::c_uint = 0;
pub const RAM_DISK: ::std::os::raw::c_uint = 1;
pub const EEPROM_DISK: ::std::os::raw::c_uint = 2;
pub const ATA_DISK: ::std::os::raw::c_uint = 3;
pub const NUM_TABLE_ENTRIES: ::std::os::raw::c_uint = 14;
pub const OS_FS_DEV_NAME_LEN: ::std::os::raw::c_uint = 32;
pub const OS_FS_PHYS_NAME_LEN: ::std::os::raw::c_uint = 64;
pub const OS_FS_VOL_NAME_LEN: ::std::os::raw::c_uint = 32;
pub const OS_FS_ERR_PATH_TOO_LONG: ::std::os::raw::c_int = -103;
pub const OS_FS_ERR_NAME_TOO_LONG: ::std::os::raw::c_int = -104;
pub const OS_FS_ERR_DRIVE_NOT_CREATED: ::std::os::raw::c_int = -106;
pub const OS_FS_ERR_DEVICE_NOT_FREE: ::std::os::raw::c_int = -107;
pub const OS_FS_ERR_PATH_INVALID: ::std::os::raw::c_int = -108;
pub const OS_FS_SUCCESS: ::std::os::raw::c_uint = 0;
pub const OS_FS_ERROR: ::std::os::raw::c_int = -1;
pub const OS_FS_ERR_INVALID_POINTER: ::std::os::raw::c_int = -2;
pub const OS_FS_ERR_NO_FREE_FDS: ::std::os::raw::c_int = -14;
pub const OS_FS_ERR_INVALID_FD: ::std::os::raw::c_int = -16;
pub const OS_FS_UNIMPLEMENTED: ::std::os::raw::c_int = -28;
pub const OS_SOCKADDR_MAX_LEN: ::std::os::raw::c_uint = 32;
pub const CFE_SUCCESS: ::std::os::raw::c_uint = 0;
pub const CFE_OS_ERROR: ::std::os::raw::c_int = -1;
pub const CFE_OS_INVALID_POINTER: ::std::os::raw::c_int = -2;
pub const CFE_OS_ERROR_ADDRESS_MISALIGNED: ::std::os::raw::c_int = -3;
pub const CFE_OS_ERROR_TIMEOUT: ::std::os::raw::c_int = -4;
pub const CFE_OS_INVALID_INT_NUM: ::std::os::raw::c_int = -5;
pub const CFE_OS_SEM_FAILURE: ::std::os::raw::c_int = -6;
pub const CFE_OS_SEM_TIMEOUT: ::std::os::raw::c_int = -7;
pub const CFE_OS_QUEUE_EMPTY: ::std::os::raw::c_int = -8;
pub const CFE_OS_QUEUE_FULL: ::std::os::raw::c_int = -9;
pub const CFE_OS_QUEUE_TIMEOUT: ::std::os::raw::c_int = -10;
pub const CFE_OS_QUEUE_INVALID_SIZE: ::std::os::raw::c_int = -11;
pub const CFE_OS_QUEUE_ID_ERROR: ::std::os::raw::c_int = -12;
pub const CFE_OS_ERR_NAME_TOO_LONG: ::std::os::raw::c_int = -13;
pub const CFE_OS_ERR_NO_FREE_IDS: ::std::os::raw::c_int = -14;
pub const CFE_OS_ERR_NAME_TAKEN: ::std::os::raw::c_int = -15;
pub const CFE_OS_ERR_INVALID_ID: ::std::os::raw::c_int = -16;
pub const CFE_OS_ERR_NAME_NOT_FOUND: ::std::os::raw::c_int = -17;
pub const CFE_OS_ERR_SEM_NOT_FULL: ::std::os::raw::c_int = -18;
pub const CFE_OS_ERR_INVALID_PRIORITY: ::std::os::raw::c_int = -19;
pub const CFE_OS_FS_ERROR: ::std::os::raw::c_int = -1;
pub const CFE_OS_FS_ERR_INVALID_POINTER: ::std::os::raw::c_int = -2;
pub const CFE_OS_FS_ERR_PATH_TOO_LONG: ::std::os::raw::c_int = -103;
pub const CFE_OS_FS_ERR_NAME_TOO_LONG: ::std::os::raw::c_int = -104;
pub const CFE_OS_FS_ERR_DRIVE_NOT_CREATED: ::std::os::raw::c_int = -106;
pub const CFE_OSAPI_NOT_IMPLEMENTED: ::std::os::raw::c_int = -28;
pub const CFE_ES_INIT_INF_EID: ::std::os::raw::c_uint = 1;
pub const CFE_ES_INITSTATS_INF_EID: ::std::os::raw::c_uint = 2;
pub const CFE_ES_NOOP_INF_EID: ::std::os::raw::c_uint = 3;
pub const CFE_ES_RESET_INF_EID: ::std::os::raw::c_uint = 4;
pub const CFE_ES_SHELL_INF_EID: ::std::os::raw::c_uint = 5;
pub const CFE_ES_START_INF_EID: ::std::os::raw::c_uint = 6;
pub const CFE_ES_STOP_DBG_EID: ::std::os::raw::c_uint = 7;
pub const CFE_ES_STOP_INF_EID: ::std::os::raw::c_uint = 8;
pub const CFE_ES_RESTART_APP_DBG_EID: ::std::os::raw::c_uint = 9;
pub const CFE_ES_RESTART_APP_INF_EID: ::std::os::raw::c_uint = 10;
pub const CFE_ES_RELOAD_APP_DBG_EID: ::std::os::raw::c_uint = 11;
pub const CFE_ES_RELOAD_APP_INF_EID: ::std::os::raw::c_uint = 12;
pub const CFE_ES_EXIT_APP_INF_EID: ::std::os::raw::c_uint = 13;
pub const CFE_ES_ERREXIT_APP_INF_EID: ::std::os::raw::c_uint = 14;
pub const CFE_ES_ONE_APP_EID: ::std::os::raw::c_uint = 15;
pub const CFE_ES_ALL_APPS_EID: ::std::os::raw::c_uint = 16;
pub const CFE_ES_SYSLOG1_INF_EID: ::std::os::raw::c_uint = 17;
pub const CFE_ES_SYSLOG2_EID: ::std::os::raw::c_uint = 18;
pub const CFE_ES_ERLOG1_INF_EID: ::std::os::raw::c_uint = 19;
pub const CFE_ES_ERLOG2_EID: ::std::os::raw::c_uint = 20;
pub const CFE_ES_MID_ERR_EID: ::std::os::raw::c_uint = 21;
pub const CFE_ES_CC1_ERR_EID: ::std::os::raw::c_uint = 22;
pub const CFE_ES_LEN_ERR_EID: ::std::os::raw::c_uint = 23;
pub const CFE_ES_BOOT_ERR_EID: ::std::os::raw::c_uint = 24;
pub const CFE_ES_SHELL_ERR_EID: ::std::os::raw::c_uint = 25;
pub const CFE_ES_START_ERR_EID: ::std::os::raw::c_uint = 26;
pub const CFE_ES_START_INVALID_FILENAME_ERR_EID: ::std::os::raw::c_uint = 27;
pub const CFE_ES_START_INVALID_ENTRY_POINT_ERR_EID: ::std::os::raw::c_uint =
    28;
pub const CFE_ES_START_NULL_APP_NAME_ERR_EID: ::std::os::raw::c_uint = 29;
pub const CFE_ES_START_STACK_ERR_EID: ::std::os::raw::c_uint = 30;
pub const CFE_ES_START_PRIORITY_ERR_EID: ::std::os::raw::c_uint = 31;
pub const CFE_ES_START_EXC_ACTION_ERR_EID: ::std::os::raw::c_uint = 32;
pub const CFE_ES_ERREXIT_APP_ERR_EID: ::std::os::raw::c_uint = 33;
pub const CFE_ES_STOP_ERR1_EID: ::std::os::raw::c_uint = 35;
pub const CFE_ES_STOP_ERR2_EID: ::std::os::raw::c_uint = 36;
pub const CFE_ES_STOP_ERR3_EID: ::std::os::raw::c_uint = 37;
pub const CFE_ES_RESTART_APP_ERR1_EID: ::std::os::raw::c_uint = 38;
pub const CFE_ES_RESTART_APP_ERR2_EID: ::std::os::raw::c_uint = 39;
pub const CFE_ES_RESTART_APP_ERR3_EID: ::std::os::raw::c_uint = 40;
pub const CFE_ES_RESTART_APP_ERR4_EID: ::std::os::raw::c_uint = 41;
pub const CFE_ES_RELOAD_APP_ERR1_EID: ::std::os::raw::c_uint = 42;
pub const CFE_ES_RELOAD_APP_ERR2_EID: ::std::os::raw::c_uint = 43;
pub const CFE_ES_RELOAD_APP_ERR3_EID: ::std::os::raw::c_uint = 44;
pub const CFE_ES_RELOAD_APP_ERR4_EID: ::std::os::raw::c_uint = 45;
pub const CFE_ES_EXIT_APP_ERR_EID: ::std::os::raw::c_uint = 46;
pub const CFE_ES_PCR_ERR1_EID: ::std::os::raw::c_uint = 47;
pub const CFE_ES_PCR_ERR2_EID: ::std::os::raw::c_uint = 48;
pub const CFE_ES_ONE_ERR_EID: ::std::os::raw::c_uint = 49;
pub const CFE_ES_ONE_APPID_ERR_EID: ::std::os::raw::c_uint = 50;
pub const CFE_ES_OSCREATE_ERR_EID: ::std::os::raw::c_uint = 51;
pub const CFE_ES_WRHDR_ERR_EID: ::std::os::raw::c_uint = 52;
pub const CFE_ES_TASKWR_ERR_EID: ::std::os::raw::c_uint = 53;
pub const CFE_ES_SYSLOG2_ERR_EID: ::std::os::raw::c_uint = 55;
pub const CFE_ES_ERLOG2_ERR_EID: ::std::os::raw::c_uint = 56;
pub const CFE_ES_PERF_STARTCMD_EID: ::std::os::raw::c_uint = 57;
pub const CFE_ES_PERF_STARTCMD_ERR_EID: ::std::os::raw::c_uint = 58;
pub const CFE_ES_PERF_STARTCMD_TRIG_ERR_EID: ::std::os::raw::c_uint = 59;
pub const CFE_ES_PERF_STOPCMD_EID: ::std::os::raw::c_uint = 60;
pub const CFE_ES_PERF_STOPCMD_ERR1_EID: ::std::os::raw::c_uint = 61;
pub const CFE_ES_PERF_STOPCMD_ERR2_EID: ::std::os::raw::c_uint = 62;
pub const CFE_ES_PERF_FILTMSKCMD_EID: ::std::os::raw::c_uint = 63;
pub const CFE_ES_PERF_FILTMSKERR_EID: ::std::os::raw::c_uint = 64;
pub const CFE_ES_PERF_TRIGMSKCMD_EID: ::std::os::raw::c_uint = 65;
pub const CFE_ES_PERF_TRIGMSKERR_EID: ::std::os::raw::c_uint = 66;
pub const CFE_ES_PERF_LOG_ERR_EID: ::std::os::raw::c_uint = 67;
pub const CFE_ES_PERF_DATAWRITTEN_EID: ::std::os::raw::c_uint = 68;
pub const CFE_ES_CDS_REGISTER_ERR_EID: ::std::os::raw::c_uint = 69;
pub const CFE_ES_SYSLOGMODE_EID: ::std::os::raw::c_uint = 70;
pub const CFE_ES_ERR_SYSLOGMODE_EID: ::std::os::raw::c_uint = 71;
pub const CFE_ES_RESET_PR_COUNT_EID: ::std::os::raw::c_uint = 72;
pub const CFE_ES_SET_MAX_PR_COUNT_EID: ::std::os::raw::c_uint = 73;
pub const CFE_ES_FILEWRITE_ERR_EID: ::std::os::raw::c_uint = 74;
pub const CFE_ES_RST_ACCESS_EID: ::std::os::raw::c_uint = 75;
pub const CFE_ES_CDS_DELETE_ERR_EID: ::std::os::raw::c_uint = 76;
pub const CFE_ES_CDS_NAME_ERR_EID: ::std::os::raw::c_uint = 77;
pub const CFE_ES_CDS_DELETED_INFO_EID: ::std::os::raw::c_uint = 78;
pub const CFE_ES_CDS_DELETE_TBL_ERR_EID: ::std::os::raw::c_uint = 79;
pub const CFE_ES_CDS_OWNER_ACTIVE_EID: ::std::os::raw::c_uint = 80;
pub const CFE_ES_TLM_POOL_STATS_INFO_EID: ::std::os::raw::c_uint = 81;
pub const CFE_ES_INVALID_POOL_HANDLE_ERR_EID: ::std::os::raw::c_uint = 82;
pub const CFE_ES_CDS_REG_DUMP_INF_EID: ::std::os::raw::c_uint = 83;
pub const CFE_ES_CDS_DUMP_ERR_EID: ::std::os::raw::c_uint = 84;
pub const CFE_ES_WRITE_CFE_HDR_ERR_EID: ::std::os::raw::c_uint = 85;
pub const CFE_ES_CREATING_CDS_DUMP_ERR_EID: ::std::os::raw::c_uint = 86;
pub const CFE_ES_TASKINFO_EID: ::std::os::raw::c_uint = 87;
pub const CFE_ES_TASKINFO_OSCREATE_ERR_EID: ::std::os::raw::c_uint = 88;
pub const CFE_ES_TASKINFO_WRHDR_ERR_EID: ::std::os::raw::c_uint = 89;
pub const CFE_ES_TASKINFO_WR_ERR_EID: ::std::os::raw::c_uint = 90;
pub const CFE_ES_VERSION_INF_EID: ::std::os::raw::c_uint = 91;
pub const CFE_ES_BUILD_INF_EID: ::std::os::raw::c_uint = 92;
pub const CFE_ES_PERF_EXIT_BIT: ::std::os::raw::c_uint = 31;
pub const CFE_ES_MAIN_PERF_ID: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_MAIN_PERF_ID: ::std::os::raw::c_uint = 2;
pub const CFE_TBL_MAIN_PERF_ID: ::std::os::raw::c_uint = 3;
pub const CFE_SB_MAIN_PERF_ID: ::std::os::raw::c_uint = 4;
pub const CFE_SB_MSG_LIM_PERF_ID: ::std::os::raw::c_uint = 5;
pub const CFE_SB_PIPE_OFLOW_PERF_ID: ::std::os::raw::c_uint = 27;
pub const CFE_TIME_MAIN_PERF_ID: ::std::os::raw::c_uint = 6;
pub const CFE_TIME_TONE1HZISR_PERF_ID: ::std::os::raw::c_uint = 7;
pub const CFE_TIME_LOCAL1HZISR_PERF_ID: ::std::os::raw::c_uint = 8;
pub const CFE_TIME_SENDMET_PERF_ID: ::std::os::raw::c_uint = 9;
pub const CFE_TIME_LOCAL1HZTASK_PERF_ID: ::std::os::raw::c_uint = 10;
pub const CFE_TIME_TONE1HZTASK_PERF_ID: ::std::os::raw::c_uint = 11;
pub const CFE_ES_MAX_MEMPOOL_BLOCK_SIZES: ::std::os::raw::c_uint = 17;
pub const CFE_ES_CDS_MAX_FULL_NAME_LEN: ::std::os::raw::c_uint = 38;
pub const CFE_ES_RUNSTATUS_APP_RUN: ::std::os::raw::c_uint = 1;
pub const CFE_ES_RUNSTATUS_APP_EXIT: ::std::os::raw::c_uint = 2;
pub const CFE_ES_RUNSTATUS_APP_ERROR: ::std::os::raw::c_uint = 3;
pub const CFE_ES_RUNSTATUS_SYS_EXCEPTION: ::std::os::raw::c_uint = 4;
pub const CFE_ES_RUNSTATUS_SYS_RESTART: ::std::os::raw::c_uint = 5;
pub const CFE_ES_RUNSTATUS_SYS_RELOAD: ::std::os::raw::c_uint = 6;
pub const CFE_ES_RUNSTATUS_SYS_DELETE: ::std::os::raw::c_uint = 7;
pub const CFE_ES_RUNSTATUS_CORE_APP_INIT_ERROR: ::std::os::raw::c_uint = 8;
pub const CFE_ES_RUNSTATUS_CORE_APP_RUNTIME_ERROR: ::std::os::raw::c_uint = 9;
pub const CFE_ES_NO_MUTEX: ::std::os::raw::c_uint = 0;
pub const CFE_ES_USE_MUTEX: ::std::os::raw::c_uint = 1;
pub const CFE_ES_APP_RUN: ::std::os::raw::c_uint = 1;
pub const CFE_ES_APP_EXIT: ::std::os::raw::c_uint = 2;
pub const CFE_ES_APP_ERROR: ::std::os::raw::c_uint = 3;
pub const CFE_ES_SYS_EXCEPTION: ::std::os::raw::c_uint = 4;
pub const CFE_ES_SYS_RESTART: ::std::os::raw::c_uint = 5;
pub const CFE_ES_SYS_RELOAD: ::std::os::raw::c_uint = 6;
pub const CFE_ES_SYS_DELETE: ::std::os::raw::c_uint = 7;
pub const CFE_ES_CORE_APP_INIT_ERROR: ::std::os::raw::c_uint = 8;
pub const CFE_ES_CORE_APP_RUNTIME_ERROR: ::std::os::raw::c_uint = 9;
pub const CFE_TIME_PRINTED_STRING_SIZE: ::std::os::raw::c_uint = 24;
pub const CFE_PSP_MEM_TABLE_SIZE: ::std::os::raw::c_uint = 10;
pub const CFE_PSP_WATCHDOG_MIN: ::std::os::raw::c_uint = 0;
pub const CFE_PSP_WATCHDOG_MAX: ::std::os::raw::c_uint = 4294967295;
pub const CFE_PSP_NUM_EEPROM_BANKS: ::std::os::raw::c_uint = 1;
pub const CFE_PSP_IMPL_MAJOR_VERSION: ::std::os::raw::c_uint = 1;
pub const CFE_PSP_IMPL_MINOR_VERSION: ::std::os::raw::c_uint = 3;
pub const CFE_PSP_IMPL_REVISION: ::std::os::raw::c_uint = 0;
pub const CFE_PSP_IMPL_MISSION_REV: ::std::os::raw::c_uint = 0;
pub const CFE_PSP_MAJOR_VERSION: ::std::os::raw::c_uint = 1;
pub const CFE_PSP_MINOR_VERSION: ::std::os::raw::c_uint = 3;
pub const CFE_PSP_REVISION: ::std::os::raw::c_uint = 0;
pub const CFE_PSP_MISSION_REV: ::std::os::raw::c_uint = 0;
pub const CFE_PSP_SUBMINOR_VERSION: ::std::os::raw::c_uint = 0;
pub const CFE_PSP_SUCCESS: ::std::os::raw::c_uint = 0;
pub const CFE_PSP_ERROR: ::std::os::raw::c_int = -1;
pub const CFE_PSP_INVALID_POINTER: ::std::os::raw::c_int = -2;
pub const CFE_PSP_ERROR_ADDRESS_MISALIGNED: ::std::os::raw::c_int = -3;
pub const CFE_PSP_ERROR_TIMEOUT: ::std::os::raw::c_int = -4;
pub const CFE_PSP_INVALID_INT_NUM: ::std::os::raw::c_int = -5;
pub const CFE_PSP_INVALID_MEM_ADDR: ::std::os::raw::c_int = -21;
pub const CFE_PSP_INVALID_MEM_TYPE: ::std::os::raw::c_int = -22;
pub const CFE_PSP_INVALID_MEM_RANGE: ::std::os::raw::c_int = -23;
pub const CFE_PSP_INVALID_MEM_WORDSIZE: ::std::os::raw::c_int = -24;
pub const CFE_PSP_INVALID_MEM_SIZE: ::std::os::raw::c_int = -25;
pub const CFE_PSP_INVALID_MEM_ATTR: ::std::os::raw::c_int = -26;
pub const CFE_PSP_ERROR_NOT_IMPLEMENTED: ::std::os::raw::c_int = -27;
pub const CFE_PSP_INVALID_MODULE_NAME: ::std::os::raw::c_int = -28;
pub const CFE_PSP_INVALID_MODULE_ID: ::std::os::raw::c_int = -29;
pub const CFE_PSP_PANIC_STARTUP: ::std::os::raw::c_uint = 1;
pub const CFE_PSP_PANIC_VOLATILE_DISK: ::std::os::raw::c_uint = 2;
pub const CFE_PSP_PANIC_MEMORY_ALLOC: ::std::os::raw::c_uint = 3;
pub const CFE_PSP_PANIC_NONVOL_DISK: ::std::os::raw::c_uint = 4;
pub const CFE_PSP_PANIC_STARTUP_SEM: ::std::os::raw::c_uint = 5;
pub const CFE_PSP_PANIC_CORE_APP: ::std::os::raw::c_uint = 6;
pub const CFE_PSP_PANIC_GENERAL_FAILURE: ::std::os::raw::c_uint = 7;
pub const BUFF_SIZE: ::std::os::raw::c_uint = 256;
pub const SIZE_BYTE: ::std::os::raw::c_uint = 1;
pub const SIZE_HALF: ::std::os::raw::c_uint = 2;
pub const SIZE_WORD: ::std::os::raw::c_uint = 3;
pub const CFE_PSP_MEM_RAM: ::std::os::raw::c_uint = 1;
pub const CFE_PSP_MEM_EEPROM: ::std::os::raw::c_uint = 2;
pub const CFE_PSP_MEM_ANY: ::std::os::raw::c_uint = 3;
pub const CFE_PSP_MEM_INVALID: ::std::os::raw::c_uint = 4;
pub const CFE_PSP_MEM_ATTR_WRITE: ::std::os::raw::c_uint = 1;
pub const CFE_PSP_MEM_ATTR_READ: ::std::os::raw::c_uint = 2;
pub const CFE_PSP_MEM_ATTR_READWRITE: ::std::os::raw::c_uint = 3;
pub const CFE_PSP_MEM_SIZE_BYTE: ::std::os::raw::c_uint = 1;
pub const CFE_PSP_MEM_SIZE_WORD: ::std::os::raw::c_uint = 2;
pub const CFE_PSP_MEM_SIZE_DWORD: ::std::os::raw::c_uint = 4;
pub const CFE_PSP_RST_TYPE_PROCESSOR: ::std::os::raw::c_uint = 1;
pub const CFE_PSP_RST_TYPE_POWERON: ::std::os::raw::c_uint = 2;
pub const CFE_PSP_RST_TYPE_MAX: ::std::os::raw::c_uint = 3;
pub const CFE_PSP_RST_SUBTYPE_POWER_CYCLE: ::std::os::raw::c_uint = 1;
pub const CFE_PSP_RST_SUBTYPE_PUSH_BUTTON: ::std::os::raw::c_uint = 2;
pub const CFE_PSP_RST_SUBTYPE_HW_SPECIAL_COMMAND: ::std::os::raw::c_uint = 3;
pub const CFE_PSP_RST_SUBTYPE_HW_WATCHDOG: ::std::os::raw::c_uint = 4;
pub const CFE_PSP_RST_SUBTYPE_RESET_COMMAND: ::std::os::raw::c_uint = 5;
pub const CFE_PSP_RST_SUBTYPE_EXCEPTION: ::std::os::raw::c_uint = 6;
pub const CFE_PSP_RST_SUBTYPE_UNDEFINED_RESET: ::std::os::raw::c_uint = 7;
pub const CFE_PSP_RST_SUBTYPE_HWDEBUG_RESET: ::std::os::raw::c_uint = 8;
pub const CFE_PSP_RST_SUBTYPE_BANKSWITCH_RESET: ::std::os::raw::c_uint = 9;
pub const CFE_PSP_RST_SUBTYPE_MAX: ::std::os::raw::c_uint = 10;
pub const CFE_SB_POLL: ::std::os::raw::c_uint = 0;
pub const CFE_SB_PEND_FOREVER: ::std::os::raw::c_int = -1;
pub const CFE_SB_SUB_ENTRIES_PER_PKT: ::std::os::raw::c_uint = 20;
pub const CFE_SB_SUBSCRIPTION: ::std::os::raw::c_uint = 0;
pub const CFE_SB_UNSUBSCRIPTION: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_NO_OPERATION_CC: ::std::os::raw::c_uint = 0;
pub const CFE_EVS_RESET_COUNTERS_CC: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_ENABLE_EVENT_TYPE_CC: ::std::os::raw::c_uint = 2;
pub const CFE_EVS_DISABLE_EVENT_TYPE_CC: ::std::os::raw::c_uint = 3;
pub const CFE_EVS_SET_EVENT_FORMAT_MODE_CC: ::std::os::raw::c_uint = 4;
pub const CFE_EVS_ENABLE_APP_EVENT_TYPE_CC: ::std::os::raw::c_uint = 5;
pub const CFE_EVS_DISABLE_APP_EVENT_TYPE_CC: ::std::os::raw::c_uint = 6;
pub const CFE_EVS_ENABLE_APP_EVENTS_CC: ::std::os::raw::c_uint = 7;
pub const CFE_EVS_DISABLE_APP_EVENTS_CC: ::std::os::raw::c_uint = 8;
pub const CFE_EVS_RESET_APP_COUNTER_CC: ::std::os::raw::c_uint = 9;
pub const CFE_EVS_SET_FILTER_CC: ::std::os::raw::c_uint = 10;
pub const CFE_EVS_ENABLE_PORTS_CC: ::std::os::raw::c_uint = 11;
pub const CFE_EVS_DISABLE_PORTS_CC: ::std::os::raw::c_uint = 12;
pub const CFE_EVS_RESET_FILTER_CC: ::std::os::raw::c_uint = 13;
pub const CFE_EVS_RESET_ALL_FILTERS_CC: ::std::os::raw::c_uint = 14;
pub const CFE_EVS_ADD_EVENT_FILTER_CC: ::std::os::raw::c_uint = 15;
pub const CFE_EVS_DELETE_EVENT_FILTER_CC: ::std::os::raw::c_uint = 16;
pub const CFE_EVS_FILE_WRITE_APP_DATA_CC: ::std::os::raw::c_uint = 17;
pub const CFE_EVS_FILE_WRITE_LOG_DATA_CC: ::std::os::raw::c_uint = 18;
pub const CFE_EVS_SET_LOG_MODE_CC: ::std::os::raw::c_uint = 19;
pub const CFE_EVS_CLEAR_LOG_CC: ::std::os::raw::c_uint = 20;
pub const CFE_EVS_SHORT_FORMAT: ::std::os::raw::c_uint = 0;
pub const CFE_EVS_LONG_FORMAT: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_DEBUG_BIT: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_INFORMATION_BIT: ::std::os::raw::c_uint = 2;
pub const CFE_EVS_ERROR_BIT: ::std::os::raw::c_uint = 4;
pub const CFE_EVS_CRITICAL_BIT: ::std::os::raw::c_uint = 8;
pub const CFE_EVS_PORT1_BIT: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_PORT2_BIT: ::std::os::raw::c_uint = 2;
pub const CFE_EVS_PORT3_BIT: ::std::os::raw::c_uint = 4;
pub const CFE_EVS_PORT4_BIT: ::std::os::raw::c_uint = 8;
pub const CFE_EVS_LOG_OVERWRITE: ::std::os::raw::c_uint = 0;
pub const CFE_EVS_LOG_DISCARD: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_BINARY_FILTER: ::std::os::raw::c_uint = 0;
pub const CFE_EVS_NO_FILTER: ::std::os::raw::c_uint = 0;
pub const CFE_EVS_FIRST_ONE_STOP: ::std::os::raw::c_uint = 65535;
pub const CFE_EVS_FIRST_TWO_STOP: ::std::os::raw::c_uint = 65534;
pub const CFE_EVS_FIRST_4_STOP: ::std::os::raw::c_uint = 65532;
pub const CFE_EVS_FIRST_8_STOP: ::std::os::raw::c_uint = 65528;
pub const CFE_EVS_FIRST_16_STOP: ::std::os::raw::c_uint = 65520;
pub const CFE_EVS_FIRST_32_STOP: ::std::os::raw::c_uint = 65504;
pub const CFE_EVS_FIRST_64_STOP: ::std::os::raw::c_uint = 65472;
pub const CFE_EVS_EVERY_OTHER_ONE: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_EVERY_OTHER_TWO: ::std::os::raw::c_uint = 2;
pub const CFE_EVS_EVERY_FOURTH_ONE: ::std::os::raw::c_uint = 3;
pub const CFE_EVS_DEBUG: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_INFORMATION: ::std::os::raw::c_uint = 2;
pub const CFE_EVS_ERROR: ::std::os::raw::c_uint = 3;
pub const CFE_EVS_CRITICAL: ::std::os::raw::c_uint = 4;
pub const CFE_EVS_PORT1: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_PORT2: ::std::os::raw::c_uint = 2;
pub const CFE_EVS_PORT3: ::std::os::raw::c_uint = 3;
pub const CFE_EVS_PORT4: ::std::os::raw::c_uint = 4;
pub const CFE_FS_HDR_DESC_MAX_LEN: ::std::os::raw::c_uint = 32;
pub const CFE_FS_FILE_CONTENT_ID: ::std::os::raw::c_uint = 1665549617;
pub const CFE_FS_ES_ERLOG_SUBTYPE: ::std::os::raw::c_uint = 1;
pub const CFE_FS_ES_SYSLOG_SUBTYPE: ::std::os::raw::c_uint = 2;
pub const CFE_FS_ES_QUERYALL_SUBTYPE: ::std::os::raw::c_uint = 3;
pub const CFE_FS_ES_PERFDATA_SUBTYPE: ::std::os::raw::c_uint = 4;
pub const CFE_FS_ES_SHELL_SUBTYPE: ::std::os::raw::c_uint = 5;
pub const CFE_FS_ES_CDS_REG_SUBTYPE: ::std::os::raw::c_uint = 6;
pub const CFE_FS_TBL_REG_SUBTYPE: ::std::os::raw::c_uint = 9;
pub const CFE_FS_TBL_IMG_SUBTYPE: ::std::os::raw::c_uint = 8;
pub const CFE_FS_EVS_APPDATA_SUBTYPE: ::std::os::raw::c_uint = 15;
pub const CFE_FS_EVS_EVENTLOG_SUBTYPE: ::std::os::raw::c_uint = 16;
pub const CFE_FS_SB_PIPEDATA_SUBTYPE: ::std::os::raw::c_uint = 20;
pub const CFE_FS_SB_ROUTEDATA_SUBTYPE: ::std::os::raw::c_uint = 21;
pub const CFE_FS_SB_MAPDATA_SUBTYPE: ::std::os::raw::c_uint = 22;
pub const CFE_FS_ES_QUERYALLTASKS_SUBTYPE: ::std::os::raw::c_uint = 23;
pub const CFE_TBL_OPT_BUFFER_MSK: ::std::os::raw::c_uint = 1;
pub const CFE_TBL_OPT_SNGL_BUFFER: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_OPT_DBL_BUFFER: ::std::os::raw::c_uint = 1;
pub const CFE_TBL_OPT_LD_DMP_MSK: ::std::os::raw::c_uint = 2;
pub const CFE_TBL_OPT_LOAD_DUMP: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_OPT_DUMP_ONLY: ::std::os::raw::c_uint = 2;
pub const CFE_TBL_OPT_USR_DEF_MSK: ::std::os::raw::c_uint = 4;
pub const CFE_TBL_OPT_NOT_USR_DEF: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_OPT_USR_DEF_ADDR: ::std::os::raw::c_uint = 6;
pub const CFE_TBL_OPT_CRITICAL_MSK: ::std::os::raw::c_uint = 8;
pub const CFE_TBL_OPT_NOT_CRITICAL: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_OPT_CRITICAL: ::std::os::raw::c_uint = 8;
pub const CFE_TBL_OPT_DEFAULT: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_MAX_FULL_NAME_LEN_COMP: ::std::os::raw::c_uint = 38;
pub const CFE_TBL_MAX_FULL_NAME_LEN: ::std::os::raw::c_uint = 40;
pub const CFE_ES_NOOP_CC: ::std::os::raw::c_uint = 0;
pub const CFE_ES_RESET_CC: ::std::os::raw::c_uint = 1;
pub const CFE_ES_RESTART_CC: ::std::os::raw::c_uint = 2;
pub const CFE_ES_SHELL_CMD_CC: ::std::os::raw::c_uint = 3;
pub const CFE_ES_START_APP_CC: ::std::os::raw::c_uint = 4;
pub const CFE_ES_STOP_APP_CC: ::std::os::raw::c_uint = 5;
pub const CFE_ES_RESTART_APP_CC: ::std::os::raw::c_uint = 6;
pub const CFE_ES_RELOAD_APP_CC: ::std::os::raw::c_uint = 7;
pub const CFE_ES_QUERY_ONE_CC: ::std::os::raw::c_uint = 8;
pub const CFE_ES_QUERY_ALL_CC: ::std::os::raw::c_uint = 9;
pub const CFE_ES_CLEAR_SYSLOG_CC: ::std::os::raw::c_uint = 10;
pub const CFE_ES_WRITE_SYSLOG_CC: ::std::os::raw::c_uint = 11;
pub const CFE_ES_CLEAR_ERLOG_CC: ::std::os::raw::c_uint = 12;
pub const CFE_ES_WRITE_ERLOG_CC: ::std::os::raw::c_uint = 13;
pub const CFE_ES_PERF_STARTDATA_CC: ::std::os::raw::c_uint = 14;
pub const CFE_ES_PERF_STOPDATA_CC: ::std::os::raw::c_uint = 15;
pub const CFE_ES_PERF_SETFILTERMASK_CC: ::std::os::raw::c_uint = 16;
pub const CFE_ES_PERF_SETTRIGMASK_CC: ::std::os::raw::c_uint = 17;
pub const CFE_ES_OVERWRITE_SYSLOG_CC: ::std::os::raw::c_uint = 18;
pub const CFE_ES_RESET_PR_COUNT_CC: ::std::os::raw::c_uint = 19;
pub const CFE_ES_SET_MAX_PR_COUNT_CC: ::std::os::raw::c_uint = 20;
pub const CFE_ES_DELETE_CDS_CC: ::std::os::raw::c_uint = 21;
pub const CFE_ES_TLM_POOL_STATS_CC: ::std::os::raw::c_uint = 22;
pub const CFE_ES_DUMP_CDS_REG_CC: ::std::os::raw::c_uint = 23;
pub const CFE_ES_QUERY_ALL_TASKS_CC: ::std::os::raw::c_uint = 24;
pub const CFE_EVS_NOOP_EID: ::std::os::raw::c_uint = 0;
pub const CFE_EVS_STARTUP_EID: ::std::os::raw::c_uint = 1;
pub const CFE_EVS_ERR_WRLOGFILE_EID: ::std::os::raw::c_uint = 2;
pub const CFE_EVS_ERR_CRLOGFILE_EID: ::std::os::raw::c_uint = 3;
pub const CFE_EVS_ERR_MSGID_EID: ::std::os::raw::c_uint = 5;
pub const CFE_EVS_ERR_EVTIDNOREGS_EID: ::std::os::raw::c_uint = 6;
pub const CFE_EVS_ERR_APPNOREGS_EID: ::std::os::raw::c_uint = 7;
pub const CFE_EVS_ERR_ILLAPPIDRANGE_EID: ::std::os::raw::c_uint = 8;
pub const CFE_EVS_ERR_NOAPPIDFOUND_EID: ::std::os::raw::c_uint = 9;
pub const CFE_EVS_ERR_ILLEGALFMTMOD_EID: ::std::os::raw::c_uint = 10;
pub const CFE_EVS_ERR_MAXREGSFILTER_EID: ::std::os::raw::c_uint = 11;
pub const CFE_EVS_ERR_WRDATFILE_EID: ::std::os::raw::c_uint = 12;
pub const CFE_EVS_ERR_CRDATFILE_EID: ::std::os::raw::c_uint = 13;
pub const CFE_EVS_ERR_CC_EID: ::std::os::raw::c_uint = 15;
pub const CFE_EVS_RSTCNT_EID: ::std::os::raw::c_uint = 16;
pub const CFE_EVS_SETFILTERMSK_EID: ::std::os::raw::c_uint = 17;
pub const CFE_EVS_ENAPORT_EID: ::std::os::raw::c_uint = 18;
pub const CFE_EVS_DISPORT_EID: ::std::os::raw::c_uint = 19;
pub const CFE_EVS_ENAEVTTYPE_EID: ::std::os::raw::c_uint = 20;
pub const CFE_EVS_DISEVTTYPE_EID: ::std::os::raw::c_uint = 21;
pub const CFE_EVS_SETEVTFMTMOD_EID: ::std::os::raw::c_uint = 22;
pub const CFE_EVS_ENAAPPEVTTYPE_EID: ::std::os::raw::c_uint = 23;
pub const CFE_EVS_DISAPPENTTYPE_EID: ::std::os::raw::c_uint = 24;
pub const CFE_EVS_ENAAPPEVT_EID: ::std::os::raw::c_uint = 25;
pub const CFE_EVS_DISAPPEVT_EID: ::std::os::raw::c_uint = 26;
pub const CFE_EVS_RSTEVTCNT_EID: ::std::os::raw::c_uint = 27;
pub const CFE_EVS_RSTFILTER_EID: ::std::os::raw::c_uint = 28;
pub const CFE_EVS_RSTALLFILTER_EID: ::std::os::raw::c_uint = 29;
pub const CFE_EVS_ADDFILTER_EID: ::std::os::raw::c_uint = 30;
pub const CFE_EVS_DELFILTER_EID: ::std::os::raw::c_uint = 31;
pub const CFE_EVS_WRDAT_EID: ::std::os::raw::c_uint = 32;
pub const CFE_EVS_WRLOG_EID: ::std::os::raw::c_uint = 33;
pub const CFE_EVS_NO_LOGSET_EID: ::std::os::raw::c_uint = 34;
pub const CFE_EVS_NO_LOGCLR_EID: ::std::os::raw::c_uint = 35;
pub const CFE_EVS_NO_LOGWR_EID: ::std::os::raw::c_uint = 36;
pub const CFE_EVS_EVT_FILTERED_EID: ::std::os::raw::c_uint = 37;
pub const CFE_EVS_LOGMODE_EID: ::std::os::raw::c_uint = 38;
pub const CFE_EVS_ERR_LOGMODE_EID: ::std::os::raw::c_uint = 39;
pub const CFE_EVS_ERR_INVALID_BITMASK_EID: ::std::os::raw::c_uint = 40;
pub const CFE_EVS_ERR_UNREGISTERED_EVS_APP: ::std::os::raw::c_uint = 41;
pub const CFE_EVS_FILTER_MAX_EID: ::std::os::raw::c_uint = 42;
pub const CFE_EVS_LEN_ERR_EID: ::std::os::raw::c_uint = 43;
pub const CFE_SB_INIT_EID: ::std::os::raw::c_uint = 1;
pub const CFE_SB_CR_PIPE_BAD_ARG_EID: ::std::os::raw::c_uint = 2;
pub const CFE_SB_MAX_PIPES_MET_EID: ::std::os::raw::c_uint = 3;
pub const CFE_SB_CR_PIPE_ERR_EID: ::std::os::raw::c_uint = 4;
pub const CFE_SB_PIPE_ADDED_EID: ::std::os::raw::c_uint = 5;
pub const CFE_SB_SUB_ARG_ERR_EID: ::std::os::raw::c_uint = 6;
pub const CFE_SB_DUP_SUBSCRIP_EID: ::std::os::raw::c_uint = 7;
pub const CFE_SB_MAX_MSGS_MET_EID: ::std::os::raw::c_uint = 8;
pub const CFE_SB_MAX_DESTS_MET_EID: ::std::os::raw::c_uint = 9;
pub const CFE_SB_SUBSCRIPTION_RCVD_EID: ::std::os::raw::c_uint = 10;
pub const CFE_SB_UNSUB_ARG_ERR_EID: ::std::os::raw::c_uint = 11;
pub const CFE_SB_UNSUB_NO_SUBS_EID: ::std::os::raw::c_uint = 12;
pub const CFE_SB_SEND_BAD_ARG_EID: ::std::os::raw::c_uint = 13;
pub const CFE_SB_SEND_NO_SUBS_EID: ::std::os::raw::c_uint = 14;
pub const CFE_SB_MSG_TOO_BIG_EID: ::std::os::raw::c_uint = 15;
pub const CFE_SB_GET_BUF_ERR_EID: ::std::os::raw::c_uint = 16;
pub const CFE_SB_MSGID_LIM_ERR_EID: ::std::os::raw::c_uint = 17;
pub const CFE_SB_RCV_BAD_ARG_EID: ::std::os::raw::c_uint = 18;
pub const CFE_SB_BAD_PIPEID_EID: ::std::os::raw::c_uint = 19;
pub const CFE_SB_DEST_BLK_ERR_EID: ::std::os::raw::c_uint = 20;
pub const CFE_SB_SEND_INV_MSGID_EID: ::std::os::raw::c_uint = 21;
pub const CFE_SB_SUBSCRIPTION_RPT_EID: ::std::os::raw::c_uint = 22;
pub const CFE_SB_UNSUBSCRIPTION_RPT_EID: ::std::os::raw::c_uint = 24;
pub const CFE_SB_Q_FULL_ERR_EID: ::std::os::raw::c_uint = 25;
pub const CFE_SB_Q_WR_ERR_EID: ::std::os::raw::c_uint = 26;
pub const CFE_SB_Q_RD_ERR_EID: ::std::os::raw::c_uint = 27;
pub const CFE_SB_CMD0_RCVD_EID: ::std::os::raw::c_uint = 28;
pub const CFE_SB_CMD1_RCVD_EID: ::std::os::raw::c_uint = 29;
pub const CFE_SB_LSTSNDER_ERR1_EID: ::std::os::raw::c_uint = 30;
pub const CFE_SB_LSTSNDER_ERR2_EID: ::std::os::raw::c_uint = 31;
pub const CFE_SB_SND_STATS_EID: ::std::os::raw::c_uint = 32;
pub const CFE_SB_ENBL_RTE1_EID: ::std::os::raw::c_uint = 33;
pub const CFE_SB_ENBL_RTE2_EID: ::std::os::raw::c_uint = 34;
pub const CFE_SB_ENBL_RTE3_EID: ::std::os::raw::c_uint = 35;
pub const CFE_SB_DSBL_RTE1_EID: ::std::os::raw::c_uint = 36;
pub const CFE_SB_DSBL_RTE2_EID: ::std::os::raw::c_uint = 37;
pub const CFE_SB_DSBL_RTE3_EID: ::std::os::raw::c_uint = 38;
pub const CFE_SB_SND_RTG_EID: ::std::os::raw::c_uint = 39;
pub const CFE_SB_SND_RTG_ERR1_EID: ::std::os::raw::c_uint = 40;
pub const CFE_SB_GLS_INV_CALLER_EID: ::std::os::raw::c_uint = 41;
pub const CFE_SB_BAD_CMD_CODE_EID: ::std::os::raw::c_uint = 42;
pub const CFE_SB_BAD_MSGID_EID: ::std::os::raw::c_uint = 43;
pub const CFE_SB_FULL_SUB_PKT_EID: ::std::os::raw::c_uint = 44;
pub const CFE_SB_PART_SUB_PKT_EID: ::std::os::raw::c_uint = 45;
pub const CFE_SB_DEL_PIPE_ERR1_EID: ::std::os::raw::c_uint = 46;
pub const CFE_SB_PIPE_DELETED_EID: ::std::os::raw::c_uint = 47;
pub const CFE_SB_SUBSCRIPTION_REMOVED_EID: ::std::os::raw::c_uint = 48;
pub const CFE_SB_FILEWRITE_ERR_EID: ::std::os::raw::c_uint = 49;
pub const CFE_SB_SUB_INV_PIPE_EID: ::std::os::raw::c_uint = 50;
pub const CFE_SB_SUB_INV_CALLER_EID: ::std::os::raw::c_uint = 51;
pub const CFE_SB_UNSUB_INV_PIPE_EID: ::std::os::raw::c_uint = 52;
pub const CFE_SB_UNSUB_INV_CALLER_EID: ::std::os::raw::c_uint = 53;
pub const CFE_SB_DEL_PIPE_ERR2_EID: ::std::os::raw::c_uint = 54;
pub const CFE_SB_NOOP_CC: ::std::os::raw::c_uint = 0;
pub const CFE_SB_RESET_CTRS_CC: ::std::os::raw::c_uint = 1;
pub const CFE_SB_SEND_SB_STATS_CC: ::std::os::raw::c_uint = 2;
pub const CFE_SB_SEND_ROUTING_INFO_CC: ::std::os::raw::c_uint = 3;
pub const CFE_SB_ENABLE_ROUTE_CC: ::std::os::raw::c_uint = 4;
pub const CFE_SB_DISABLE_ROUTE_CC: ::std::os::raw::c_uint = 5;
pub const CFE_SB_SEND_PIPE_INFO_CC: ::std::os::raw::c_uint = 7;
pub const CFE_SB_SEND_MAP_INFO_CC: ::std::os::raw::c_uint = 8;
pub const CFE_SB_ENABLE_SUB_REPORTING_CC: ::std::os::raw::c_uint = 9;
pub const CFE_SB_DISABLE_SUB_REPORTING_CC: ::std::os::raw::c_uint = 10;
pub const CFE_SB_SEND_PREV_SUBS_CC: ::std::os::raw::c_uint = 11;
pub const CFE_TBL_INIT_INF_EID: ::std::os::raw::c_uint = 1;
pub const CFE_TBL_NOOP_INF_EID: ::std::os::raw::c_uint = 10;
pub const CFE_TBL_RESET_INF_EID: ::std::os::raw::c_uint = 11;
pub const CFE_TBL_FILE_LOADED_INF_EID: ::std::os::raw::c_uint = 12;
pub const CFE_TBL_OVERWRITE_DUMP_INF_EID: ::std::os::raw::c_uint = 13;
pub const CFE_TBL_WRITE_DUMP_INF_EID: ::std::os::raw::c_uint = 14;
pub const CFE_TBL_OVERWRITE_REG_DUMP_INF_EID: ::std::os::raw::c_uint = 15;
pub const CFE_TBL_VAL_REQ_MADE_INF_EID: ::std::os::raw::c_uint = 16;
pub const CFE_TBL_LOAD_PEND_REQ_INF_EID: ::std::os::raw::c_uint = 17;
pub const CFE_TBL_TLM_REG_CMD_INF_EID: ::std::os::raw::c_uint = 18;
pub const CFE_TBL_LOAD_ABORT_INF_EID: ::std::os::raw::c_uint = 21;
pub const CFE_TBL_WRITE_REG_DUMP_INF_EID: ::std::os::raw::c_uint = 22;
pub const CFE_TBL_ASSUMED_VALID_INF_EID: ::std::os::raw::c_uint = 23;
pub const CFE_TBL_MID_ERR_EID: ::std::os::raw::c_uint = 50;
pub const CFE_TBL_CC1_ERR_EID: ::std::os::raw::c_uint = 51;
pub const CFE_TBL_LEN_ERR_EID: ::std::os::raw::c_uint = 52;
pub const CFE_TBL_FILE_ACCESS_ERR_EID: ::std::os::raw::c_uint = 53;
pub const CFE_TBL_FILE_STD_HDR_ERR_EID: ::std::os::raw::c_uint = 54;
pub const CFE_TBL_FILE_TBL_HDR_ERR_EID: ::std::os::raw::c_uint = 55;
pub const CFE_TBL_FAIL_HK_SEND_ERR_EID: ::std::os::raw::c_uint = 56;
pub const CFE_TBL_NO_SUCH_TABLE_ERR_EID: ::std::os::raw::c_uint = 57;
pub const CFE_TBL_FILE_TYPE_ERR_EID: ::std::os::raw::c_uint = 58;
pub const CFE_TBL_FILE_SUBTYPE_ERR_EID: ::std::os::raw::c_uint = 59;
pub const CFE_TBL_NO_WORK_BUFFERS_ERR_EID: ::std::os::raw::c_uint = 60;
pub const CFE_TBL_INTERNAL_ERROR_ERR_EID: ::std::os::raw::c_uint = 61;
pub const CFE_TBL_CREATING_DUMP_FILE_ERR_EID: ::std::os::raw::c_uint = 62;
pub const CFE_TBL_WRITE_CFE_HDR_ERR_EID: ::std::os::raw::c_uint = 63;
pub const CFE_TBL_WRITE_TBL_HDR_ERR_EID: ::std::os::raw::c_uint = 64;
pub const CFE_TBL_WRITE_TBL_IMG_ERR_EID: ::std::os::raw::c_uint = 65;
pub const CFE_TBL_NO_INACTIVE_BUFFER_ERR_EID: ::std::os::raw::c_uint = 66;
pub const CFE_TBL_TOO_MANY_VALIDATIONS_ERR_EID: ::std::os::raw::c_uint = 67;
pub const CFE_TBL_WRITE_TBL_REG_ERR_EID: ::std::os::raw::c_uint = 68;
pub const CFE_TBL_LOAD_ABORT_ERR_EID: ::std::os::raw::c_uint = 69;
pub const CFE_TBL_ACTIVATE_ERR_EID: ::std::os::raw::c_uint = 70;
pub const CFE_TBL_FILE_INCOMPLETE_ERR_EID: ::std::os::raw::c_uint = 71;
pub const CFE_TBL_LOAD_EXCEEDS_SIZE_ERR_EID: ::std::os::raw::c_uint = 72;
pub const CFE_TBL_ZERO_LENGTH_LOAD_ERR_EID: ::std::os::raw::c_uint = 73;
pub const CFE_TBL_PARTIAL_LOAD_ERR_EID: ::std::os::raw::c_uint = 74;
pub const CFE_TBL_FILE_TOO_BIG_ERR_EID: ::std::os::raw::c_uint = 75;
pub const CFE_TBL_TOO_MANY_DUMPS_ERR_EID: ::std::os::raw::c_uint = 76;
pub const CFE_TBL_DUMP_PENDING_ERR_EID: ::std::os::raw::c_uint = 77;
pub const CFE_TBL_ACTIVATE_DUMP_ONLY_ERR_EID: ::std::os::raw::c_uint = 78;
pub const CFE_TBL_LOADING_A_DUMP_ONLY_ERR_EID: ::std::os::raw::c_uint = 79;
pub const CFE_TBL_ILLEGAL_BUFF_PARAM_ERR_EID: ::std::os::raw::c_uint = 80;
pub const CFE_TBL_UNVALIDATED_ERR_EID: ::std::os::raw::c_uint = 81;
pub const CFE_TBL_IN_REGISTRY_ERR_EID: ::std::os::raw::c_uint = 82;
pub const CFE_TBL_NOT_CRITICAL_TBL_ERR_EID: ::std::os::raw::c_uint = 83;
pub const CFE_TBL_NOT_IN_CRIT_REG_ERR_EID: ::std::os::raw::c_uint = 84;
pub const CFE_TBL_CDS_NOT_FOUND_ERR_EID: ::std::os::raw::c_uint = 85;
pub const CFE_TBL_CDS_DELETE_ERR_EID: ::std::os::raw::c_uint = 86;
pub const CFE_TBL_CDS_OWNER_ACTIVE_ERR_EID: ::std::os::raw::c_uint = 87;
pub const CFE_TBL_LOADING_PENDING_ERR_EID: ::std::os::raw::c_uint = 88;
pub const CFE_TBL_FAIL_NOTIFY_SEND_ERR_EID: ::std::os::raw::c_uint = 89;
pub const CFE_TBL_LOAD_SUCCESS_INF_EID: ::std::os::raw::c_uint = 35;
pub const CFE_TBL_VALIDATION_INF_EID: ::std::os::raw::c_uint = 36;
pub const CFE_TBL_UPDATE_SUCCESS_INF_EID: ::std::os::raw::c_uint = 37;
pub const CFE_TBL_CDS_DELETED_INFO_EID: ::std::os::raw::c_uint = 38;
pub const CFE_TBL_REGISTER_ERR_EID: ::std::os::raw::c_uint = 90;
pub const CFE_TBL_SHARE_ERR_EID: ::std::os::raw::c_uint = 91;
pub const CFE_TBL_UNREGISTER_ERR_EID: ::std::os::raw::c_uint = 92;
pub const CFE_TBL_LOAD_ERR_EID: ::std::os::raw::c_uint = 93;
pub const CFE_TBL_LOAD_TYPE_ERR_EID: ::std::os::raw::c_uint = 94;
pub const CFE_TBL_UPDATE_ERR_EID: ::std::os::raw::c_uint = 95;
pub const CFE_TBL_VALIDATION_ERR_EID: ::std::os::raw::c_uint = 96;
pub const CFE_TBL_SPACECRAFT_ID_ERR_EID: ::std::os::raw::c_uint = 97;
pub const CFE_TBL_PROCESSOR_ID_ERR_EID: ::std::os::raw::c_uint = 98;
pub const CFE_TBL_FILDEF_MAX_NAME_LEN: ::std::os::raw::c_uint = 40;
pub const CFE_TBL_FILEDEF_FS_HDR_ALIGN32: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_FILDEF_FS_HDR_LEN: ::std::os::raw::c_uint = 32;
pub const CFE_TBL_FILEDEF_OS_FILE_ALIGN32: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_FILDEF_OS_FILE_LEN: ::std::os::raw::c_uint = 20;
pub const CFE_TBL_NOOP_CC: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_RESET_CC: ::std::os::raw::c_uint = 1;
pub const CFE_TBL_LOAD_CC: ::std::os::raw::c_uint = 2;
pub const CFE_TBL_DUMP_CC: ::std::os::raw::c_uint = 3;
pub const CFE_TBL_VALIDATE_CC: ::std::os::raw::c_uint = 4;
pub const CFE_TBL_ACTIVATE_CC: ::std::os::raw::c_uint = 5;
pub const CFE_TBL_DUMP_REG_CC: ::std::os::raw::c_uint = 6;
pub const CFE_TBL_TLM_REG_CC: ::std::os::raw::c_uint = 7;
pub const CFE_TBL_DELETE_CDS_CC: ::std::os::raw::c_uint = 8;
pub const CFE_TBL_ABORT_LOAD_CC: ::std::os::raw::c_uint = 9;
pub const CFE_TBL_INACTIVE_BUFFER: ::std::os::raw::c_uint = 0;
pub const CFE_TBL_ACTIVE_BUFFER: ::std::os::raw::c_uint = 1;
pub const CFE_TIME_INIT_EID: ::std::os::raw::c_uint = 1;
pub const CFE_TIME_NOOP_EID: ::std::os::raw::c_uint = 4;
pub const CFE_TIME_RESET_EID: ::std::os::raw::c_uint = 5;
pub const CFE_TIME_DIAG_EID: ::std::os::raw::c_uint = 6;
pub const CFE_TIME_STATE_EID: ::std::os::raw::c_uint = 7;
pub const CFE_TIME_SOURCE_EID: ::std::os::raw::c_uint = 8;
pub const CFE_TIME_SIGNAL_EID: ::std::os::raw::c_uint = 9;
pub const CFE_TIME_DELAY_EID: ::std::os::raw::c_uint = 11;
pub const CFE_TIME_TIME_EID: ::std::os::raw::c_uint = 12;
pub const CFE_TIME_MET_EID: ::std::os::raw::c_uint = 13;
pub const CFE_TIME_STCF_EID: ::std::os::raw::c_uint = 14;
pub const CFE_TIME_DELTA_EID: ::std::os::raw::c_uint = 15;
pub const CFE_TIME_1HZ_EID: ::std::os::raw::c_uint = 16;
pub const CFE_TIME_LEAPS_EID: ::std::os::raw::c_uint = 17;
pub const CFE_TIME_FLY_ON_EID: ::std::os::raw::c_uint = 20;
pub const CFE_TIME_FLY_OFF_EID: ::std::os::raw::c_uint = 21;
pub const CFE_TIME_EXIT_ERR_EID: ::std::os::raw::c_uint = 25;
pub const CFE_TIME_ID_ERR_EID: ::std::os::raw::c_uint = 26;
pub const CFE_TIME_CC_ERR_EID: ::std::os::raw::c_uint = 27;
pub const CFE_TIME_STATE_ERR_EID: ::std::os::raw::c_uint = 30;
pub const CFE_TIME_SOURCE_ERR_EID: ::std::os::raw::c_uint = 31;
pub const CFE_TIME_SIGNAL_ERR_EID: ::std::os::raw::c_uint = 32;
pub const CFE_TIME_DELAY_ERR_EID: ::std::os::raw::c_uint = 33;
pub const CFE_TIME_TIME_ERR_EID: ::std::os::raw::c_uint = 34;
pub const CFE_TIME_MET_ERR_EID: ::std::os::raw::c_uint = 35;
pub const CFE_TIME_STCF_ERR_EID: ::std::os::raw::c_uint = 36;
pub const CFE_TIME_DELTA_ERR_EID: ::std::os::raw::c_uint = 37;
pub const CFE_TIME_1HZ_ERR_EID: ::std::os::raw::c_uint = 38;
pub const CFE_TIME_SOURCE_CFG_EID: ::std::os::raw::c_uint = 40;
pub const CFE_TIME_SIGNAL_CFG_EID: ::std::os::raw::c_uint = 41;
pub const CFE_TIME_DELAY_CFG_EID: ::std::os::raw::c_uint = 42;
pub const CFE_TIME_TIME_CFG_EID: ::std::os::raw::c_uint = 43;
pub const CFE_TIME_MET_CFG_EID: ::std::os::raw::c_uint = 44;
pub const CFE_TIME_STCF_CFG_EID: ::std::os::raw::c_uint = 45;
pub const CFE_TIME_LEAPS_CFG_EID: ::std::os::raw::c_uint = 46;
pub const CFE_TIME_DELTA_CFG_EID: ::std::os::raw::c_uint = 47;
pub const CFE_TIME_1HZ_CFG_EID: ::std::os::raw::c_uint = 48;
pub const CFE_TIME_NOOP_CC: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_RESET_CC: ::std::os::raw::c_uint = 1;
pub const CFE_TIME_DIAG_TLM_CC: ::std::os::raw::c_uint = 2;
pub const CFE_TIME_SET_SOURCE_CC: ::std::os::raw::c_uint = 3;
pub const CFE_TIME_SET_STATE_CC: ::std::os::raw::c_uint = 4;
pub const CFE_TIME_ADD_DELAY_CC: ::std::os::raw::c_uint = 5;
pub const CFE_TIME_SUB_DELAY_CC: ::std::os::raw::c_uint = 6;
pub const CFE_TIME_SET_TIME_CC: ::std::os::raw::c_uint = 7;
pub const CFE_TIME_SET_MET_CC: ::std::os::raw::c_uint = 8;
pub const CFE_TIME_SET_STCF_CC: ::std::os::raw::c_uint = 9;
pub const CFE_TIME_SET_LEAPS_CC: ::std::os::raw::c_uint = 10;
pub const CFE_TIME_ADD_ADJUST_CC: ::std::os::raw::c_uint = 11;
pub const CFE_TIME_SUB_ADJUST_CC: ::std::os::raw::c_uint = 12;
pub const CFE_TIME_ADD_1HZADJ_CC: ::std::os::raw::c_uint = 13;
pub const CFE_TIME_SUB_1HZADJ_CC: ::std::os::raw::c_uint = 14;
pub const CFE_TIME_SET_SIGNAL_CC: ::std::os::raw::c_uint = 15;
pub const CFE_TIME_USE_INTERN: ::std::os::raw::c_uint = 1;
pub const CFE_TIME_USE_EXTERN: ::std::os::raw::c_uint = 2;
pub const CFE_TIME_TONE_PRI: ::std::os::raw::c_uint = 1;
pub const CFE_TIME_TONE_RED: ::std::os::raw::c_uint = 2;
pub const CFE_TIME_ADD_ADJUST: ::std::os::raw::c_uint = 1;
pub const CFE_TIME_SUB_ADJUST: ::std::os::raw::c_uint = 2;
pub const CFE_TIME_NO_FLY: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_IS_FLY: ::std::os::raw::c_uint = 1;
pub const CFE_TIME_NOT_SET: ::std::os::raw::c_uint = 0;
pub const CFE_TIME_WAS_SET: ::std::os::raw::c_uint = 1;
pub const CFE_TIME_FLAG_CLKSET: ::std::os::raw::c_uint = 32768;
pub const CFE_TIME_FLAG_FLYING: ::std::os::raw::c_uint = 16384;
pub const CFE_TIME_FLAG_SRCINT: ::std::os::raw::c_uint = 8192;
pub const CFE_TIME_FLAG_SIGPRI: ::std::os::raw::c_uint = 4096;
pub const CFE_TIME_FLAG_SRVFLY: ::std::os::raw::c_uint = 2048;
pub const CFE_TIME_FLAG_CMDFLY: ::std::os::raw::c_uint = 1024;
pub const CFE_TIME_FLAG_ADDADJ: ::std::os::raw::c_uint = 512;
pub const CFE_TIME_FLAG_ADD1HZ: ::std::os::raw::c_uint = 256;
pub const CFE_TIME_FLAG_ADDTCL: ::std::os::raw::c_uint = 128;
pub const CFE_TIME_FLAG_SERVER: ::std::os::raw::c_uint = 64;
pub const CFE_TIME_FLAG_GDTONE: ::std::os::raw::c_uint = 32;
pub const CFE_TIME_FLAG_UNUSED: ::std::os::raw::c_uint = 31;
pub const CFE_MAJOR_VERSION: ::std::os::raw::c_uint = 6;
pub const CFE_MINOR_VERSION: ::std::os::raw::c_uint = 5;
pub const CFE_REVISION: ::std::os::raw::c_uint = 0;
pub const _UNISTD_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_VERSION: ::std::os::raw::c_uint = 200809;
pub const __POSIX2_THIS_VERSION: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_VERSION: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_C_VERSION: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_C_BIND: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_C_DEV: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_SW_DEV: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_LOCALEDEF: ::std::os::raw::c_uint = 200809;
pub const _XOPEN_VERSION: ::std::os::raw::c_uint = 700;
pub const _XOPEN_XCU_VERSION: ::std::os::raw::c_uint = 4;
pub const _XOPEN_XPG2: ::std::os::raw::c_uint = 1;
pub const _XOPEN_XPG3: ::std::os::raw::c_uint = 1;
pub const _XOPEN_XPG4: ::std::os::raw::c_uint = 1;
pub const _XOPEN_UNIX: ::std::os::raw::c_uint = 1;
pub const _XOPEN_CRYPT: ::std::os::raw::c_uint = 1;
pub const _XOPEN_ENH_I18N: ::std::os::raw::c_uint = 1;
pub const _XOPEN_LEGACY: ::std::os::raw::c_uint = 1;
pub const _BITS_POSIX_OPT_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_JOB_CONTROL: ::std::os::raw::c_uint = 1;
pub const _POSIX_SAVED_IDS: ::std::os::raw::c_uint = 1;
pub const _POSIX_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 200809;
pub const _POSIX_SYNCHRONIZED_IO: ::std::os::raw::c_uint = 200809;
pub const _POSIX_FSYNC: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MAPPED_FILES: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MEMLOCK: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MEMLOCK_RANGE: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MEMORY_PROTECTION: ::std::os::raw::c_uint = 200809;
pub const _POSIX_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 0;
pub const _POSIX_VDISABLE: u8 = b'\x00';
pub const _POSIX_NO_TRUNC: ::std::os::raw::c_uint = 1;
pub const _XOPEN_REALTIME: ::std::os::raw::c_uint = 1;
pub const _XOPEN_REALTIME_THREADS: ::std::os::raw::c_uint = 1;
pub const _XOPEN_SHM: ::std::os::raw::c_uint = 1;
pub const _POSIX_THREADS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: ::std::os::raw::c_uint = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: ::std::os::raw::c_int = -1;
pub const _POSIX_SEMAPHORES: ::std::os::raw::c_uint = 200809;
pub const _POSIX_REALTIME_SIGNALS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 200809;
pub const _POSIX_ASYNC_IO: ::std::os::raw::c_uint = 1;
pub const _LFS_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 1;
pub const _POSIX_PRIORITIZED_IO: ::std::os::raw::c_uint = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 1;
pub const _LFS_LARGEFILE: ::std::os::raw::c_uint = 1;
pub const _LFS64_LARGEFILE: ::std::os::raw::c_uint = 1;
pub const _LFS64_STDIO: ::std::os::raw::c_uint = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_CPUTIME: ::std::os::raw::c_uint = 0;
pub const _POSIX_THREAD_CPUTIME: ::std::os::raw::c_uint = 0;
pub const _POSIX_REGEXP: ::std::os::raw::c_uint = 1;
pub const _POSIX_READER_WRITER_LOCKS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_SHELL: ::std::os::raw::c_uint = 1;
pub const _POSIX_TIMEOUTS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_SPIN_LOCKS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_SPAWN: ::std::os::raw::c_uint = 200809;
pub const _POSIX_TIMERS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_BARRIERS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MESSAGE_PASSING: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MONOTONIC_CLOCK: ::std::os::raw::c_uint = 0;
pub const _POSIX_CLOCK_SELECTION: ::std::os::raw::c_uint = 200809;
pub const _POSIX_ADVISORY_INFO: ::std::os::raw::c_uint = 200809;
pub const _POSIX_IPV6: ::std::os::raw::c_uint = 200809;
pub const _POSIX_RAW_SOCKETS: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_CHAR_TERM: ::std::os::raw::c_uint = 200809;
pub const _POSIX_SPORADIC_SERVER: ::std::os::raw::c_int = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE_EVENT_FILTER: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE_INHERIT: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE_LOG: ::std::os::raw::c_int = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: ::std::os::raw::c_int = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: ::std::os::raw::c_int = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: ::std::os::raw::c_int = -1;
pub const _XBS5_LPBIG_OFFBIG: ::std::os::raw::c_int = -1;
pub const _POSIX_V7_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const _POSIX_V6_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const _XBS5_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const __ILP32_OFF32_CFLAGS: &'static [u8; 5usize] = b"-m32\x00";
pub const __ILP32_OFF32_LDFLAGS: &'static [u8; 5usize] = b"-m32\x00";
pub const __ILP32_OFFBIG_CFLAGS: &'static [u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\x00";
pub const __ILP32_OFFBIG_LDFLAGS: &'static [u8; 5usize] = b"-m32\x00";
pub const __LP64_OFF64_CFLAGS: &'static [u8; 5usize] = b"-m64\x00";
pub const __LP64_OFF64_LDFLAGS: &'static [u8; 5usize] = b"-m64\x00";
pub const STDIN_FILENO: ::std::os::raw::c_uint = 0;
pub const STDOUT_FILENO: ::std::os::raw::c_uint = 1;
pub const STDERR_FILENO: ::std::os::raw::c_uint = 2;
pub const R_OK: ::std::os::raw::c_uint = 4;
pub const W_OK: ::std::os::raw::c_uint = 2;
pub const X_OK: ::std::os::raw::c_uint = 1;
pub const F_OK: ::std::os::raw::c_uint = 0;
pub const L_SET: ::std::os::raw::c_uint = 0;
pub const L_INCR: ::std::os::raw::c_uint = 1;
pub const L_XTND: ::std::os::raw::c_uint = 2;
pub const F_ULOCK: ::std::os::raw::c_uint = 0;
pub const F_LOCK: ::std::os::raw::c_uint = 1;
pub const F_TLOCK: ::std::os::raw::c_uint = 2;
pub const F_TEST: ::std::os::raw::c_uint = 3;
pub const _SYS_SOCKET_H: ::std::os::raw::c_uint = 1;
pub const _SYS_UIO_H: ::std::os::raw::c_uint = 1;
pub const _BITS_UIO_H: ::std::os::raw::c_uint = 1;
pub const UIO_MAXIOV: ::std::os::raw::c_uint = 1024;
pub const PF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const PF_LOCAL: ::std::os::raw::c_uint = 1;
pub const PF_UNIX: ::std::os::raw::c_uint = 1;
pub const PF_FILE: ::std::os::raw::c_uint = 1;
pub const PF_INET: ::std::os::raw::c_uint = 2;
pub const PF_AX25: ::std::os::raw::c_uint = 3;
pub const PF_IPX: ::std::os::raw::c_uint = 4;
pub const PF_APPLETALK: ::std::os::raw::c_uint = 5;
pub const PF_NETROM: ::std::os::raw::c_uint = 6;
pub const PF_BRIDGE: ::std::os::raw::c_uint = 7;
pub const PF_ATMPVC: ::std::os::raw::c_uint = 8;
pub const PF_X25: ::std::os::raw::c_uint = 9;
pub const PF_INET6: ::std::os::raw::c_uint = 10;
pub const PF_ROSE: ::std::os::raw::c_uint = 11;
pub const PF_DECnet: ::std::os::raw::c_uint = 12;
pub const PF_NETBEUI: ::std::os::raw::c_uint = 13;
pub const PF_SECURITY: ::std::os::raw::c_uint = 14;
pub const PF_KEY: ::std::os::raw::c_uint = 15;
pub const PF_NETLINK: ::std::os::raw::c_uint = 16;
pub const PF_ROUTE: ::std::os::raw::c_uint = 16;
pub const PF_PACKET: ::std::os::raw::c_uint = 17;
pub const PF_ASH: ::std::os::raw::c_uint = 18;
pub const PF_ECONET: ::std::os::raw::c_uint = 19;
pub const PF_ATMSVC: ::std::os::raw::c_uint = 20;
pub const PF_RDS: ::std::os::raw::c_uint = 21;
pub const PF_SNA: ::std::os::raw::c_uint = 22;
pub const PF_IRDA: ::std::os::raw::c_uint = 23;
pub const PF_PPPOX: ::std::os::raw::c_uint = 24;
pub const PF_WANPIPE: ::std::os::raw::c_uint = 25;
pub const PF_LLC: ::std::os::raw::c_uint = 26;
pub const PF_IB: ::std::os::raw::c_uint = 27;
pub const PF_MPLS: ::std::os::raw::c_uint = 28;
pub const PF_CAN: ::std::os::raw::c_uint = 29;
pub const PF_TIPC: ::std::os::raw::c_uint = 30;
pub const PF_BLUETOOTH: ::std::os::raw::c_uint = 31;
pub const PF_IUCV: ::std::os::raw::c_uint = 32;
pub const PF_RXRPC: ::std::os::raw::c_uint = 33;
pub const PF_ISDN: ::std::os::raw::c_uint = 34;
pub const PF_PHONET: ::std::os::raw::c_uint = 35;
pub const PF_IEEE802154: ::std::os::raw::c_uint = 36;
pub const PF_CAIF: ::std::os::raw::c_uint = 37;
pub const PF_ALG: ::std::os::raw::c_uint = 38;
pub const PF_NFC: ::std::os::raw::c_uint = 39;
pub const PF_VSOCK: ::std::os::raw::c_uint = 40;
pub const PF_MAX: ::std::os::raw::c_uint = 41;
pub const AF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const AF_LOCAL: ::std::os::raw::c_uint = 1;
pub const AF_UNIX: ::std::os::raw::c_uint = 1;
pub const AF_FILE: ::std::os::raw::c_uint = 1;
pub const AF_INET: ::std::os::raw::c_uint = 2;
pub const AF_AX25: ::std::os::raw::c_uint = 3;
pub const AF_IPX: ::std::os::raw::c_uint = 4;
pub const AF_APPLETALK: ::std::os::raw::c_uint = 5;
pub const AF_NETROM: ::std::os::raw::c_uint = 6;
pub const AF_BRIDGE: ::std::os::raw::c_uint = 7;
pub const AF_ATMPVC: ::std::os::raw::c_uint = 8;
pub const AF_X25: ::std::os::raw::c_uint = 9;
pub const AF_INET6: ::std::os::raw::c_uint = 10;
pub const AF_ROSE: ::std::os::raw::c_uint = 11;
pub const AF_DECnet: ::std::os::raw::c_uint = 12;
pub const AF_NETBEUI: ::std::os::raw::c_uint = 13;
pub const AF_SECURITY: ::std::os::raw::c_uint = 14;
pub const AF_KEY: ::std::os::raw::c_uint = 15;
pub const AF_NETLINK: ::std::os::raw::c_uint = 16;
pub const AF_ROUTE: ::std::os::raw::c_uint = 16;
pub const AF_PACKET: ::std::os::raw::c_uint = 17;
pub const AF_ASH: ::std::os::raw::c_uint = 18;
pub const AF_ECONET: ::std::os::raw::c_uint = 19;
pub const AF_ATMSVC: ::std::os::raw::c_uint = 20;
pub const AF_RDS: ::std::os::raw::c_uint = 21;
pub const AF_SNA: ::std::os::raw::c_uint = 22;
pub const AF_IRDA: ::std::os::raw::c_uint = 23;
pub const AF_PPPOX: ::std::os::raw::c_uint = 24;
pub const AF_WANPIPE: ::std::os::raw::c_uint = 25;
pub const AF_LLC: ::std::os::raw::c_uint = 26;
pub const AF_IB: ::std::os::raw::c_uint = 27;
pub const AF_MPLS: ::std::os::raw::c_uint = 28;
pub const AF_CAN: ::std::os::raw::c_uint = 29;
pub const AF_TIPC: ::std::os::raw::c_uint = 30;
pub const AF_BLUETOOTH: ::std::os::raw::c_uint = 31;
pub const AF_IUCV: ::std::os::raw::c_uint = 32;
pub const AF_RXRPC: ::std::os::raw::c_uint = 33;
pub const AF_ISDN: ::std::os::raw::c_uint = 34;
pub const AF_PHONET: ::std::os::raw::c_uint = 35;
pub const AF_IEEE802154: ::std::os::raw::c_uint = 36;
pub const AF_CAIF: ::std::os::raw::c_uint = 37;
pub const AF_ALG: ::std::os::raw::c_uint = 38;
pub const AF_NFC: ::std::os::raw::c_uint = 39;
pub const AF_VSOCK: ::std::os::raw::c_uint = 40;
pub const AF_MAX: ::std::os::raw::c_uint = 41;
pub const SOL_RAW: ::std::os::raw::c_uint = 255;
pub const SOL_DECNET: ::std::os::raw::c_uint = 261;
pub const SOL_X25: ::std::os::raw::c_uint = 262;
pub const SOL_PACKET: ::std::os::raw::c_uint = 263;
pub const SOL_ATM: ::std::os::raw::c_uint = 264;
pub const SOL_AAL: ::std::os::raw::c_uint = 265;
pub const SOL_IRDA: ::std::os::raw::c_uint = 266;
pub const SOMAXCONN: ::std::os::raw::c_uint = 128;
pub const _BITS_SOCKADDR_H: ::std::os::raw::c_uint = 1;
pub const _SS_SIZE: ::std::os::raw::c_uint = 128;
pub const FIOSETOWN: ::std::os::raw::c_uint = 35073;
pub const SIOCSPGRP: ::std::os::raw::c_uint = 35074;
pub const FIOGETOWN: ::std::os::raw::c_uint = 35075;
pub const SIOCGPGRP: ::std::os::raw::c_uint = 35076;
pub const SIOCATMARK: ::std::os::raw::c_uint = 35077;
pub const SIOCGSTAMP: ::std::os::raw::c_uint = 35078;
pub const SIOCGSTAMPNS: ::std::os::raw::c_uint = 35079;
pub const SOL_SOCKET: ::std::os::raw::c_uint = 1;
pub const SO_DEBUG: ::std::os::raw::c_uint = 1;
pub const SO_REUSEADDR: ::std::os::raw::c_uint = 2;
pub const SO_TYPE: ::std::os::raw::c_uint = 3;
pub const SO_ERROR: ::std::os::raw::c_uint = 4;
pub const SO_DONTROUTE: ::std::os::raw::c_uint = 5;
pub const SO_BROADCAST: ::std::os::raw::c_uint = 6;
pub const SO_SNDBUF: ::std::os::raw::c_uint = 7;
pub const SO_RCVBUF: ::std::os::raw::c_uint = 8;
pub const SO_SNDBUFFORCE: ::std::os::raw::c_uint = 32;
pub const SO_RCVBUFFORCE: ::std::os::raw::c_uint = 33;
pub const SO_KEEPALIVE: ::std::os::raw::c_uint = 9;
pub const SO_OOBINLINE: ::std::os::raw::c_uint = 10;
pub const SO_NO_CHECK: ::std::os::raw::c_uint = 11;
pub const SO_PRIORITY: ::std::os::raw::c_uint = 12;
pub const SO_LINGER: ::std::os::raw::c_uint = 13;
pub const SO_BSDCOMPAT: ::std::os::raw::c_uint = 14;
pub const SO_REUSEPORT: ::std::os::raw::c_uint = 15;
pub const SO_PASSCRED: ::std::os::raw::c_uint = 16;
pub const SO_PEERCRED: ::std::os::raw::c_uint = 17;
pub const SO_RCVLOWAT: ::std::os::raw::c_uint = 18;
pub const SO_SNDLOWAT: ::std::os::raw::c_uint = 19;
pub const SO_RCVTIMEO: ::std::os::raw::c_uint = 20;
pub const SO_SNDTIMEO: ::std::os::raw::c_uint = 21;
pub const SO_SECURITY_AUTHENTICATION: ::std::os::raw::c_uint = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::std::os::raw::c_uint = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: ::std::os::raw::c_uint = 24;
pub const SO_BINDTODEVICE: ::std::os::raw::c_uint = 25;
pub const SO_ATTACH_FILTER: ::std::os::raw::c_uint = 26;
pub const SO_DETACH_FILTER: ::std::os::raw::c_uint = 27;
pub const SO_GET_FILTER: ::std::os::raw::c_uint = 26;
pub const SO_PEERNAME: ::std::os::raw::c_uint = 28;
pub const SO_TIMESTAMP: ::std::os::raw::c_uint = 29;
pub const SCM_TIMESTAMP: ::std::os::raw::c_uint = 29;
pub const SO_ACCEPTCONN: ::std::os::raw::c_uint = 30;
pub const SO_PEERSEC: ::std::os::raw::c_uint = 31;
pub const SO_PASSSEC: ::std::os::raw::c_uint = 34;
pub const SO_TIMESTAMPNS: ::std::os::raw::c_uint = 35;
pub const SCM_TIMESTAMPNS: ::std::os::raw::c_uint = 35;
pub const SO_MARK: ::std::os::raw::c_uint = 36;
pub const SO_TIMESTAMPING: ::std::os::raw::c_uint = 37;
pub const SCM_TIMESTAMPING: ::std::os::raw::c_uint = 37;
pub const SO_PROTOCOL: ::std::os::raw::c_uint = 38;
pub const SO_DOMAIN: ::std::os::raw::c_uint = 39;
pub const SO_RXQ_OVFL: ::std::os::raw::c_uint = 40;
pub const SO_WIFI_STATUS: ::std::os::raw::c_uint = 41;
pub const SCM_WIFI_STATUS: ::std::os::raw::c_uint = 41;
pub const SO_PEEK_OFF: ::std::os::raw::c_uint = 42;
pub const SO_NOFCS: ::std::os::raw::c_uint = 43;
pub const SO_LOCK_FILTER: ::std::os::raw::c_uint = 44;
pub const SO_SELECT_ERR_QUEUE: ::std::os::raw::c_uint = 45;
pub const SO_BUSY_POLL: ::std::os::raw::c_uint = 46;
pub const SO_MAX_PACING_RATE: ::std::os::raw::c_uint = 47;
pub const SO_BPF_EXTENSIONS: ::std::os::raw::c_uint = 48;
pub const SO_INCOMING_CPU: ::std::os::raw::c_uint = 49;
pub const SO_ATTACH_BPF: ::std::os::raw::c_uint = 50;
pub const SO_DETACH_BPF: ::std::os::raw::c_uint = 27;
pub const _ARPA_INET_H: ::std::os::raw::c_uint = 1;
pub const _NETINET_IN_H: ::std::os::raw::c_uint = 1;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const IP_OPTIONS: ::std::os::raw::c_uint = 4;
pub const IP_HDRINCL: ::std::os::raw::c_uint = 3;
pub const IP_TOS: ::std::os::raw::c_uint = 1;
pub const IP_TTL: ::std::os::raw::c_uint = 2;
pub const IP_RECVOPTS: ::std::os::raw::c_uint = 6;
pub const IP_RETOPTS: ::std::os::raw::c_uint = 7;
pub const IP_MULTICAST_IF: ::std::os::raw::c_uint = 32;
pub const IP_MULTICAST_TTL: ::std::os::raw::c_uint = 33;
pub const IP_MULTICAST_LOOP: ::std::os::raw::c_uint = 34;
pub const IP_ADD_MEMBERSHIP: ::std::os::raw::c_uint = 35;
pub const IP_DROP_MEMBERSHIP: ::std::os::raw::c_uint = 36;
pub const IP_UNBLOCK_SOURCE: ::std::os::raw::c_uint = 37;
pub const IP_BLOCK_SOURCE: ::std::os::raw::c_uint = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: ::std::os::raw::c_uint = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: ::std::os::raw::c_uint = 40;
pub const IP_MSFILTER: ::std::os::raw::c_uint = 41;
pub const MCAST_JOIN_GROUP: ::std::os::raw::c_uint = 42;
pub const MCAST_BLOCK_SOURCE: ::std::os::raw::c_uint = 43;
pub const MCAST_UNBLOCK_SOURCE: ::std::os::raw::c_uint = 44;
pub const MCAST_LEAVE_GROUP: ::std::os::raw::c_uint = 45;
pub const MCAST_JOIN_SOURCE_GROUP: ::std::os::raw::c_uint = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: ::std::os::raw::c_uint = 47;
pub const MCAST_MSFILTER: ::std::os::raw::c_uint = 48;
pub const IP_MULTICAST_ALL: ::std::os::raw::c_uint = 49;
pub const IP_UNICAST_IF: ::std::os::raw::c_uint = 50;
pub const MCAST_EXCLUDE: ::std::os::raw::c_uint = 0;
pub const MCAST_INCLUDE: ::std::os::raw::c_uint = 1;
pub const IP_ROUTER_ALERT: ::std::os::raw::c_uint = 5;
pub const IP_PKTINFO: ::std::os::raw::c_uint = 8;
pub const IP_PKTOPTIONS: ::std::os::raw::c_uint = 9;
pub const IP_PMTUDISC: ::std::os::raw::c_uint = 10;
pub const IP_MTU_DISCOVER: ::std::os::raw::c_uint = 10;
pub const IP_RECVERR: ::std::os::raw::c_uint = 11;
pub const IP_RECVTTL: ::std::os::raw::c_uint = 12;
pub const IP_RECVTOS: ::std::os::raw::c_uint = 13;
pub const IP_MTU: ::std::os::raw::c_uint = 14;
pub const IP_FREEBIND: ::std::os::raw::c_uint = 15;
pub const IP_IPSEC_POLICY: ::std::os::raw::c_uint = 16;
pub const IP_XFRM_POLICY: ::std::os::raw::c_uint = 17;
pub const IP_PASSSEC: ::std::os::raw::c_uint = 18;
pub const IP_TRANSPARENT: ::std::os::raw::c_uint = 19;
pub const IP_ORIGDSTADDR: ::std::os::raw::c_uint = 20;
pub const IP_RECVORIGDSTADDR: ::std::os::raw::c_uint = 20;
pub const IP_MINTTL: ::std::os::raw::c_uint = 21;
pub const IP_NODEFRAG: ::std::os::raw::c_uint = 22;
pub const IP_CHECKSUM: ::std::os::raw::c_uint = 23;
pub const IP_BIND_ADDRESS_NO_PORT: ::std::os::raw::c_uint = 24;
pub const IP_PMTUDISC_DONT: ::std::os::raw::c_uint = 0;
pub const IP_PMTUDISC_WANT: ::std::os::raw::c_uint = 1;
pub const IP_PMTUDISC_DO: ::std::os::raw::c_uint = 2;
pub const IP_PMTUDISC_PROBE: ::std::os::raw::c_uint = 3;
pub const IP_PMTUDISC_INTERFACE: ::std::os::raw::c_uint = 4;
pub const IP_PMTUDISC_OMIT: ::std::os::raw::c_uint = 5;
pub const SOL_IP: ::std::os::raw::c_uint = 0;
pub const IP_DEFAULT_MULTICAST_TTL: ::std::os::raw::c_uint = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: ::std::os::raw::c_uint = 1;
pub const IP_MAX_MEMBERSHIPS: ::std::os::raw::c_uint = 20;
pub const IPV6_ADDRFORM: ::std::os::raw::c_uint = 1;
pub const IPV6_2292PKTINFO: ::std::os::raw::c_uint = 2;
pub const IPV6_2292HOPOPTS: ::std::os::raw::c_uint = 3;
pub const IPV6_2292DSTOPTS: ::std::os::raw::c_uint = 4;
pub const IPV6_2292RTHDR: ::std::os::raw::c_uint = 5;
pub const IPV6_2292PKTOPTIONS: ::std::os::raw::c_uint = 6;
pub const IPV6_CHECKSUM: ::std::os::raw::c_uint = 7;
pub const IPV6_2292HOPLIMIT: ::std::os::raw::c_uint = 8;
pub const IPV6_NEXTHOP: ::std::os::raw::c_uint = 9;
pub const IPV6_AUTHHDR: ::std::os::raw::c_uint = 10;
pub const IPV6_UNICAST_HOPS: ::std::os::raw::c_uint = 16;
pub const IPV6_MULTICAST_IF: ::std::os::raw::c_uint = 17;
pub const IPV6_MULTICAST_HOPS: ::std::os::raw::c_uint = 18;
pub const IPV6_MULTICAST_LOOP: ::std::os::raw::c_uint = 19;
pub const IPV6_JOIN_GROUP: ::std::os::raw::c_uint = 20;
pub const IPV6_LEAVE_GROUP: ::std::os::raw::c_uint = 21;
pub const IPV6_ROUTER_ALERT: ::std::os::raw::c_uint = 22;
pub const IPV6_MTU_DISCOVER: ::std::os::raw::c_uint = 23;
pub const IPV6_MTU: ::std::os::raw::c_uint = 24;
pub const IPV6_RECVERR: ::std::os::raw::c_uint = 25;
pub const IPV6_V6ONLY: ::std::os::raw::c_uint = 26;
pub const IPV6_JOIN_ANYCAST: ::std::os::raw::c_uint = 27;
pub const IPV6_LEAVE_ANYCAST: ::std::os::raw::c_uint = 28;
pub const IPV6_IPSEC_POLICY: ::std::os::raw::c_uint = 34;
pub const IPV6_XFRM_POLICY: ::std::os::raw::c_uint = 35;
pub const IPV6_RECVPKTINFO: ::std::os::raw::c_uint = 49;
pub const IPV6_PKTINFO: ::std::os::raw::c_uint = 50;
pub const IPV6_RECVHOPLIMIT: ::std::os::raw::c_uint = 51;
pub const IPV6_HOPLIMIT: ::std::os::raw::c_uint = 52;
pub const IPV6_RECVHOPOPTS: ::std::os::raw::c_uint = 53;
pub const IPV6_HOPOPTS: ::std::os::raw::c_uint = 54;
pub const IPV6_RTHDRDSTOPTS: ::std::os::raw::c_uint = 55;
pub const IPV6_RECVRTHDR: ::std::os::raw::c_uint = 56;
pub const IPV6_RTHDR: ::std::os::raw::c_uint = 57;
pub const IPV6_RECVDSTOPTS: ::std::os::raw::c_uint = 58;
pub const IPV6_DSTOPTS: ::std::os::raw::c_uint = 59;
pub const IPV6_RECVPATHMTU: ::std::os::raw::c_uint = 60;
pub const IPV6_PATHMTU: ::std::os::raw::c_uint = 61;
pub const IPV6_DONTFRAG: ::std::os::raw::c_uint = 62;
pub const IPV6_RECVTCLASS: ::std::os::raw::c_uint = 66;
pub const IPV6_TCLASS: ::std::os::raw::c_uint = 67;
pub const IPV6_ADD_MEMBERSHIP: ::std::os::raw::c_uint = 20;
pub const IPV6_DROP_MEMBERSHIP: ::std::os::raw::c_uint = 21;
pub const IPV6_RXHOPOPTS: ::std::os::raw::c_uint = 54;
pub const IPV6_RXDSTOPTS: ::std::os::raw::c_uint = 59;
pub const IPV6_PMTUDISC_DONT: ::std::os::raw::c_uint = 0;
pub const IPV6_PMTUDISC_WANT: ::std::os::raw::c_uint = 1;
pub const IPV6_PMTUDISC_DO: ::std::os::raw::c_uint = 2;
pub const IPV6_PMTUDISC_PROBE: ::std::os::raw::c_uint = 3;
pub const IPV6_PMTUDISC_INTERFACE: ::std::os::raw::c_uint = 4;
pub const IPV6_PMTUDISC_OMIT: ::std::os::raw::c_uint = 5;
pub const SOL_IPV6: ::std::os::raw::c_uint = 41;
pub const SOL_ICMPV6: ::std::os::raw::c_uint = 58;
pub const IPV6_RTHDR_LOOSE: ::std::os::raw::c_uint = 0;
pub const IPV6_RTHDR_STRICT: ::std::os::raw::c_uint = 1;
pub const IPV6_RTHDR_TYPE_0: ::std::os::raw::c_uint = 0;
pub const IN_CLASSA_NET: ::std::os::raw::c_uint = 4278190080;
pub const IN_CLASSA_NSHIFT: ::std::os::raw::c_uint = 24;
pub const IN_CLASSA_HOST: ::std::os::raw::c_uint = 16777215;
pub const IN_CLASSA_MAX: ::std::os::raw::c_uint = 128;
pub const IN_CLASSB_NET: ::std::os::raw::c_uint = 4294901760;
pub const IN_CLASSB_NSHIFT: ::std::os::raw::c_uint = 16;
pub const IN_CLASSB_HOST: ::std::os::raw::c_uint = 65535;
pub const IN_CLASSB_MAX: ::std::os::raw::c_uint = 65536;
pub const IN_CLASSC_NET: ::std::os::raw::c_uint = 4294967040;
pub const IN_CLASSC_NSHIFT: ::std::os::raw::c_uint = 8;
pub const IN_CLASSC_HOST: ::std::os::raw::c_uint = 255;
pub const IN_LOOPBACKNET: ::std::os::raw::c_uint = 127;
pub const INET_ADDRSTRLEN: ::std::os::raw::c_uint = 16;
pub const INET6_ADDRSTRLEN: ::std::os::raw::c_uint = 46;
pub const _NETINET_TCP_H: ::std::os::raw::c_uint = 1;
pub const TCP_NODELAY: ::std::os::raw::c_uint = 1;
pub const TCP_MAXSEG: ::std::os::raw::c_uint = 2;
pub const TCP_CORK: ::std::os::raw::c_uint = 3;
pub const TCP_KEEPIDLE: ::std::os::raw::c_uint = 4;
pub const TCP_KEEPINTVL: ::std::os::raw::c_uint = 5;
pub const TCP_KEEPCNT: ::std::os::raw::c_uint = 6;
pub const TCP_SYNCNT: ::std::os::raw::c_uint = 7;
pub const TCP_LINGER2: ::std::os::raw::c_uint = 8;
pub const TCP_DEFER_ACCEPT: ::std::os::raw::c_uint = 9;
pub const TCP_WINDOW_CLAMP: ::std::os::raw::c_uint = 10;
pub const TCP_INFO: ::std::os::raw::c_uint = 11;
pub const TCP_QUICKACK: ::std::os::raw::c_uint = 12;
pub const TCP_CONGESTION: ::std::os::raw::c_uint = 13;
pub const TCP_MD5SIG: ::std::os::raw::c_uint = 14;
pub const TCP_COOKIE_TRANSACTIONS: ::std::os::raw::c_uint = 15;
pub const TCP_THIN_LINEAR_TIMEOUTS: ::std::os::raw::c_uint = 16;
pub const TCP_THIN_DUPACK: ::std::os::raw::c_uint = 17;
pub const TCP_USER_TIMEOUT: ::std::os::raw::c_uint = 18;
pub const TCP_REPAIR: ::std::os::raw::c_uint = 19;
pub const TCP_REPAIR_QUEUE: ::std::os::raw::c_uint = 20;
pub const TCP_QUEUE_SEQ: ::std::os::raw::c_uint = 21;
pub const TCP_REPAIR_OPTIONS: ::std::os::raw::c_uint = 22;
pub const TCP_FASTOPEN: ::std::os::raw::c_uint = 23;
pub const TCP_TIMESTAMP: ::std::os::raw::c_uint = 24;
pub const TCP_NOTSENT_LOWAT: ::std::os::raw::c_uint = 25;
pub const TCP_CC_INFO: ::std::os::raw::c_uint = 26;
pub const TCP_SAVE_SYN: ::std::os::raw::c_uint = 27;
pub const TCP_SAVED_SYN: ::std::os::raw::c_uint = 28;
pub const TH_FIN: ::std::os::raw::c_uint = 1;
pub const TH_SYN: ::std::os::raw::c_uint = 2;
pub const TH_RST: ::std::os::raw::c_uint = 4;
pub const TH_PUSH: ::std::os::raw::c_uint = 8;
pub const TH_ACK: ::std::os::raw::c_uint = 16;
pub const TH_URG: ::std::os::raw::c_uint = 32;
pub const TCPOPT_EOL: ::std::os::raw::c_uint = 0;
pub const TCPOPT_NOP: ::std::os::raw::c_uint = 1;
pub const TCPOPT_MAXSEG: ::std::os::raw::c_uint = 2;
pub const TCPOLEN_MAXSEG: ::std::os::raw::c_uint = 4;
pub const TCPOPT_WINDOW: ::std::os::raw::c_uint = 3;
pub const TCPOLEN_WINDOW: ::std::os::raw::c_uint = 3;
pub const TCPOPT_SACK_PERMITTED: ::std::os::raw::c_uint = 4;
pub const TCPOLEN_SACK_PERMITTED: ::std::os::raw::c_uint = 2;
pub const TCPOPT_SACK: ::std::os::raw::c_uint = 5;
pub const TCPOPT_TIMESTAMP: ::std::os::raw::c_uint = 8;
pub const TCPOLEN_TIMESTAMP: ::std::os::raw::c_uint = 10;
pub const TCPOLEN_TSTAMP_APPA: ::std::os::raw::c_uint = 12;
pub const TCPOPT_TSTAMP_HDR: ::std::os::raw::c_uint = 16844810;
pub const TCP_MSS: ::std::os::raw::c_uint = 512;
pub const TCP_MAXWIN: ::std::os::raw::c_uint = 65535;
pub const TCP_MAX_WINSHIFT: ::std::os::raw::c_uint = 14;
pub const SOL_TCP: ::std::os::raw::c_uint = 6;
pub const TCPI_OPT_TIMESTAMPS: ::std::os::raw::c_uint = 1;
pub const TCPI_OPT_SACK: ::std::os::raw::c_uint = 2;
pub const TCPI_OPT_WSCALE: ::std::os::raw::c_uint = 4;
pub const TCPI_OPT_ECN: ::std::os::raw::c_uint = 8;
pub const TCPI_OPT_ECN_SEEN: ::std::os::raw::c_uint = 16;
pub const TCPI_OPT_SYN_DATA: ::std::os::raw::c_uint = 32;
pub const TCP_MD5SIG_MAXKEYLEN: ::std::os::raw::c_uint = 80;
pub const TCP_COOKIE_MIN: ::std::os::raw::c_uint = 8;
pub const TCP_COOKIE_MAX: ::std::os::raw::c_uint = 16;
pub const TCP_COOKIE_PAIR_SIZE: ::std::os::raw::c_uint = 32;
pub const TCP_COOKIE_IN_ALWAYS: ::std::os::raw::c_uint = 1;
pub const TCP_COOKIE_OUT_NEVER: ::std::os::raw::c_uint = 2;
pub const TCP_S_DATA_IN: ::std::os::raw::c_uint = 4;
pub const TCP_S_DATA_OUT: ::std::os::raw::c_uint = 8;
pub const TCP_MSS_DEFAULT: ::std::os::raw::c_uint = 536;
pub const TCP_MSS_DESIRED: ::std::os::raw::c_uint = 1220;
pub const _FCNTL_H: ::std::os::raw::c_uint = 1;
pub const __O_LARGEFILE: ::std::os::raw::c_uint = 0;
pub const F_GETLK64: ::std::os::raw::c_uint = 5;
pub const F_SETLK64: ::std::os::raw::c_uint = 6;
pub const F_SETLKW64: ::std::os::raw::c_uint = 7;
pub const O_ACCMODE: ::std::os::raw::c_uint = 3;
pub const O_RDONLY: ::std::os::raw::c_uint = 0;
pub const O_WRONLY: ::std::os::raw::c_uint = 1;
pub const O_RDWR: ::std::os::raw::c_uint = 2;
pub const O_CREAT: ::std::os::raw::c_uint = 64;
pub const O_EXCL: ::std::os::raw::c_uint = 128;
pub const O_NOCTTY: ::std::os::raw::c_uint = 256;
pub const O_TRUNC: ::std::os::raw::c_uint = 512;
pub const O_APPEND: ::std::os::raw::c_uint = 1024;
pub const O_NONBLOCK: ::std::os::raw::c_uint = 2048;
pub const O_NDELAY: ::std::os::raw::c_uint = 2048;
pub const O_SYNC: ::std::os::raw::c_uint = 1052672;
pub const O_FSYNC: ::std::os::raw::c_uint = 1052672;
pub const O_ASYNC: ::std::os::raw::c_uint = 8192;
pub const __O_DIRECTORY: ::std::os::raw::c_uint = 65536;
pub const __O_NOFOLLOW: ::std::os::raw::c_uint = 131072;
pub const __O_CLOEXEC: ::std::os::raw::c_uint = 524288;
pub const __O_DIRECT: ::std::os::raw::c_uint = 16384;
pub const __O_NOATIME: ::std::os::raw::c_uint = 262144;
pub const __O_PATH: ::std::os::raw::c_uint = 2097152;
pub const __O_DSYNC: ::std::os::raw::c_uint = 4096;
pub const __O_TMPFILE: ::std::os::raw::c_uint = 4259840;
pub const F_GETLK: ::std::os::raw::c_uint = 5;
pub const F_SETLK: ::std::os::raw::c_uint = 6;
pub const F_SETLKW: ::std::os::raw::c_uint = 7;
pub const O_DIRECTORY: ::std::os::raw::c_uint = 65536;
pub const O_NOFOLLOW: ::std::os::raw::c_uint = 131072;
pub const O_CLOEXEC: ::std::os::raw::c_uint = 524288;
pub const O_DSYNC: ::std::os::raw::c_uint = 4096;
pub const O_RSYNC: ::std::os::raw::c_uint = 1052672;
pub const F_DUPFD: ::std::os::raw::c_uint = 0;
pub const F_GETFD: ::std::os::raw::c_uint = 1;
pub const F_SETFD: ::std::os::raw::c_uint = 2;
pub const F_GETFL: ::std::os::raw::c_uint = 3;
pub const F_SETFL: ::std::os::raw::c_uint = 4;
pub const __F_SETOWN: ::std::os::raw::c_uint = 8;
pub const __F_GETOWN: ::std::os::raw::c_uint = 9;
pub const F_SETOWN: ::std::os::raw::c_uint = 8;
pub const F_GETOWN: ::std::os::raw::c_uint = 9;
pub const __F_SETSIG: ::std::os::raw::c_uint = 10;
pub const __F_GETSIG: ::std::os::raw::c_uint = 11;
pub const __F_SETOWN_EX: ::std::os::raw::c_uint = 15;
pub const __F_GETOWN_EX: ::std::os::raw::c_uint = 16;
pub const F_DUPFD_CLOEXEC: ::std::os::raw::c_uint = 1030;
pub const FD_CLOEXEC: ::std::os::raw::c_uint = 1;
pub const F_RDLCK: ::std::os::raw::c_uint = 0;
pub const F_WRLCK: ::std::os::raw::c_uint = 1;
pub const F_UNLCK: ::std::os::raw::c_uint = 2;
pub const F_EXLCK: ::std::os::raw::c_uint = 4;
pub const F_SHLCK: ::std::os::raw::c_uint = 8;
pub const LOCK_SH: ::std::os::raw::c_uint = 1;
pub const LOCK_EX: ::std::os::raw::c_uint = 2;
pub const LOCK_NB: ::std::os::raw::c_uint = 4;
pub const LOCK_UN: ::std::os::raw::c_uint = 8;
pub const FAPPEND: ::std::os::raw::c_uint = 1024;
pub const FFSYNC: ::std::os::raw::c_uint = 1052672;
pub const FASYNC: ::std::os::raw::c_uint = 8192;
pub const FNONBLOCK: ::std::os::raw::c_uint = 2048;
pub const FNDELAY: ::std::os::raw::c_uint = 2048;
pub const __POSIX_FADV_DONTNEED: ::std::os::raw::c_uint = 4;
pub const __POSIX_FADV_NOREUSE: ::std::os::raw::c_uint = 5;
pub const POSIX_FADV_NORMAL: ::std::os::raw::c_uint = 0;
pub const POSIX_FADV_RANDOM: ::std::os::raw::c_uint = 1;
pub const POSIX_FADV_SEQUENTIAL: ::std::os::raw::c_uint = 2;
pub const POSIX_FADV_WILLNEED: ::std::os::raw::c_uint = 3;
pub const POSIX_FADV_DONTNEED: ::std::os::raw::c_uint = 4;
pub const POSIX_FADV_NOREUSE: ::std::os::raw::c_uint = 5;
pub const AT_FDCWD: ::std::os::raw::c_int = -100;
pub const AT_SYMLINK_NOFOLLOW: ::std::os::raw::c_uint = 256;
pub const AT_REMOVEDIR: ::std::os::raw::c_uint = 512;
pub const AT_SYMLINK_FOLLOW: ::std::os::raw::c_uint = 1024;
pub const AT_EACCESS: ::std::os::raw::c_uint = 512;
pub type osalbool = ::std::os::raw::c_uchar;
pub type int8 = ::std::os::raw::c_schar;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type int64 = ::std::os::raw::c_long;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type uint64 = ::std::os::raw::c_ulong;
pub type cpuaddr = ::std::os::raw::c_ulong;
pub type cpusize = ::std::os::raw::c_ulong;
pub type cpudiff = ::std::os::raw::c_long;
pub type boolean = osalbool;
pub type TypeUint8WrongSize = [::std::os::raw::c_char; 1usize];
pub type TypeUint16WrongSize = [::std::os::raw::c_char; 1usize];
pub type TypeUint32WrongSize = [::std::os::raw::c_char; 1usize];
pub type TypeUint64WrongSize = [::std::os::raw::c_char; 1usize];
pub type Typeint8WrongSize = [::std::os::raw::c_char; 1usize];
pub type Typeint16WrongSize = [::std::os::raw::c_char; 1usize];
pub type Typeint32WrongSize = [::std::os::raw::c_char; 1usize];
pub type Typeint64WrongSize = [::std::os::raw::c_char; 1usize];
pub type TypePtrWrongSize = [::std::os::raw::c_char; 1usize];
/**********************************************************************
** Structure definitions for CCSDS headers.  All items in the structure
** must be aligned on 16-bit words.  Bitfields must be avoided since
** some compilers (such as gcc) force them into 32-bit alignment.
**********************************************************************/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CCSDS_PriHdr_t {
    pub StreamId: [uint8; 2usize],
    pub Sequence: [uint8; 2usize],
    pub Length: [uint8; 2usize],
}
#[test]
fn bindgen_test_layout_CCSDS_PriHdr_t() {
    assert_eq!(::std::mem::size_of::<CCSDS_PriHdr_t>() , 6usize , concat ! (
               "Size of: " , stringify ! ( CCSDS_PriHdr_t ) ));
    assert_eq! (::std::mem::align_of::<CCSDS_PriHdr_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( CCSDS_PriHdr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CCSDS_PriHdr_t ) ) . StreamId as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CCSDS_PriHdr_t ) , "::"
                , stringify ! ( StreamId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CCSDS_PriHdr_t ) ) . Sequence as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( CCSDS_PriHdr_t ) , "::"
                , stringify ! ( Sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CCSDS_PriHdr_t ) ) . Length as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CCSDS_PriHdr_t ) , "::"
                , stringify ! ( Length ) ));
}
impl Clone for CCSDS_PriHdr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CCSDS_CmdSecHdr_t {
    pub Command: uint16,
}
#[test]
fn bindgen_test_layout_CCSDS_CmdSecHdr_t() {
    assert_eq!(::std::mem::size_of::<CCSDS_CmdSecHdr_t>() , 2usize , concat !
               ( "Size of: " , stringify ! ( CCSDS_CmdSecHdr_t ) ));
    assert_eq! (::std::mem::align_of::<CCSDS_CmdSecHdr_t>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( CCSDS_CmdSecHdr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CCSDS_CmdSecHdr_t ) ) . Command as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CCSDS_CmdSecHdr_t ) ,
                "::" , stringify ! ( Command ) ));
}
impl Clone for CCSDS_CmdSecHdr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CCSDS_TlmSecHdr_t {
    pub Time: [uint8; 6usize],
}
#[test]
fn bindgen_test_layout_CCSDS_TlmSecHdr_t() {
    assert_eq!(::std::mem::size_of::<CCSDS_TlmSecHdr_t>() , 6usize , concat !
               ( "Size of: " , stringify ! ( CCSDS_TlmSecHdr_t ) ));
    assert_eq! (::std::mem::align_of::<CCSDS_TlmSecHdr_t>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( CCSDS_TlmSecHdr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CCSDS_TlmSecHdr_t ) ) . Time as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CCSDS_TlmSecHdr_t ) ,
                "::" , stringify ! ( Time ) ));
}
impl Clone for CCSDS_TlmSecHdr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CCSDS_CmdPkt_t {
    pub PriHdr: CCSDS_PriHdr_t,
    pub SecHdr: CCSDS_CmdSecHdr_t,
}
#[test]
fn bindgen_test_layout_CCSDS_CmdPkt_t() {
    assert_eq!(::std::mem::size_of::<CCSDS_CmdPkt_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( CCSDS_CmdPkt_t ) ));
    assert_eq! (::std::mem::align_of::<CCSDS_CmdPkt_t>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( CCSDS_CmdPkt_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CCSDS_CmdPkt_t ) ) . PriHdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CCSDS_CmdPkt_t ) , "::"
                , stringify ! ( PriHdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CCSDS_CmdPkt_t ) ) . SecHdr as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( CCSDS_CmdPkt_t ) , "::"
                , stringify ! ( SecHdr ) ));
}
impl Clone for CCSDS_CmdPkt_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CCSDS_TlmPkt_t {
    pub PriHdr: CCSDS_PriHdr_t,
    pub SecHdr: CCSDS_TlmSecHdr_t,
}
#[test]
fn bindgen_test_layout_CCSDS_TlmPkt_t() {
    assert_eq!(::std::mem::size_of::<CCSDS_TlmPkt_t>() , 12usize , concat ! (
               "Size of: " , stringify ! ( CCSDS_TlmPkt_t ) ));
    assert_eq! (::std::mem::align_of::<CCSDS_TlmPkt_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( CCSDS_TlmPkt_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CCSDS_TlmPkt_t ) ) . PriHdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CCSDS_TlmPkt_t ) , "::"
                , stringify ! ( PriHdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CCSDS_TlmPkt_t ) ) . SecHdr as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( CCSDS_TlmPkt_t ) , "::"
                , stringify ! ( SecHdr ) ));
}
impl Clone for CCSDS_TlmPkt_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /******************************************************************************
**  Function:  CCSDS_InitPkt()
**
**  Purpose:
**    Initialize a CCSDS packet.  The primary header is initialized with
**    specified values, and if the Clear flag is set, the rest of the packet
**    is filled with zeros.
**
**  Arguments:
**    PktPtr   : Pointer to primary header of packet.
**    StreamId : Stream ID to use for the packet.
**    Length   : Length of the packet in bytes.
**    Clear    : Indicates whether to clear the entire packet:
**                TRUE = fill sequence count and packet data with zeros
**                       (used after a cold restart)
**                FALSE = leave sequence count and packet data unchanged
**                       (used after a warm restart if data must be preserved)
**
**  Return:
**    (none)
*/
    pub fn CCSDS_InitPkt(PktPtr: *mut CCSDS_PriHdr_t, StreamId: uint16,
                         Length: uint16, Clear: boolean);
}
extern "C" {
    /******************************************************************************
**  Function:  CCSDS_LoadCheckSum()
**
**  Purpose:
**    Compute and load a checksum for a CCSDS command packet that has a
**    secondary header.
**
**  Arguments:
**    PktPtr   : Pointer to header of command packet.  The packet must
**               have a secondary header and the length in the primary
**               header must be correct.  The checksum field in the packet
**               will be modified.
**
**  Return:
**    (none)
*/
    pub fn CCSDS_LoadCheckSum(PktPtr: *mut CCSDS_CmdPkt_t);
}
extern "C" {
    /******************************************************************************
**  Function:  CCSDS_ValidCheckSum()
**
**  Purpose:
**    Determine whether a checksum in a command packet is valid.
**
**  Arguments:
**    PktPtr   : Pointer to header of command packet.  The packet must
**               have a secondary header and the length in the primary
**               header must be correct.
**
**  Return:
**    TRUE if checksum of packet is valid; FALSE if not.
**    A valid checksum is 0.
*/
    pub fn CCSDS_ValidCheckSum(PktPtr: *mut CCSDS_CmdPkt_t) -> boolean;
}
extern "C" {
    /******************************************************************************
**  Function:  CCSDS_ComputeCheckSum()
**
**  Purpose:
**    Compute the checksum for a command packet.  The checksum is the XOR of
**    all bytes in the packet; a valid checksum is zero.
**
**  Arguments:
**    PktPtr   : Pointer to header of command packet.  The packet must
**               have a secondary header and the length in the primary
**               header must be correct.
**
**  Return:
**    TRUE if checksum of packet is valid; FALSE if not.
*/
    pub fn CCSDS_ComputeCheckSum(PktPtr: *mut CCSDS_CmdPkt_t) -> uint8;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_task_prop_t {
    pub name: [::std::os::raw::c_char; 20usize],
    pub creator: uint32,
    pub stack_size: uint32,
    pub priority: uint32,
    pub OStask_id: uint32,
}
#[test]
fn bindgen_test_layout_OS_task_prop_t() {
    assert_eq!(::std::mem::size_of::<OS_task_prop_t>() , 36usize , concat ! (
               "Size of: " , stringify ! ( OS_task_prop_t ) ));
    assert_eq! (::std::mem::align_of::<OS_task_prop_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( OS_task_prop_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_task_prop_t ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_task_prop_t ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_task_prop_t ) ) . creator as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_task_prop_t ) , "::"
                , stringify ! ( creator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_task_prop_t ) ) . stack_size as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_task_prop_t ) , "::"
                , stringify ! ( stack_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_task_prop_t ) ) . priority as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_task_prop_t ) , "::"
                , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_task_prop_t ) ) . OStask_id as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_task_prop_t ) , "::"
                , stringify ! ( OStask_id ) ));
}
impl Clone for OS_task_prop_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_queue_prop_t {
    pub name: [::std::os::raw::c_char; 20usize],
    pub creator: uint32,
}
#[test]
fn bindgen_test_layout_OS_queue_prop_t() {
    assert_eq!(::std::mem::size_of::<OS_queue_prop_t>() , 24usize , concat ! (
               "Size of: " , stringify ! ( OS_queue_prop_t ) ));
    assert_eq! (::std::mem::align_of::<OS_queue_prop_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( OS_queue_prop_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_queue_prop_t ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_queue_prop_t ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_queue_prop_t ) ) . creator as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_queue_prop_t ) ,
                "::" , stringify ! ( creator ) ));
}
impl Clone for OS_queue_prop_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_bin_sem_prop_t {
    pub name: [::std::os::raw::c_char; 20usize],
    pub creator: uint32,
    pub value: int32,
}
#[test]
fn bindgen_test_layout_OS_bin_sem_prop_t() {
    assert_eq!(::std::mem::size_of::<OS_bin_sem_prop_t>() , 28usize , concat !
               ( "Size of: " , stringify ! ( OS_bin_sem_prop_t ) ));
    assert_eq! (::std::mem::align_of::<OS_bin_sem_prop_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( OS_bin_sem_prop_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_bin_sem_prop_t ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_bin_sem_prop_t ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_bin_sem_prop_t ) ) . creator as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_bin_sem_prop_t ) ,
                "::" , stringify ! ( creator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_bin_sem_prop_t ) ) . value as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_bin_sem_prop_t ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for OS_bin_sem_prop_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_count_sem_prop_t {
    pub name: [::std::os::raw::c_char; 20usize],
    pub creator: uint32,
    pub value: int32,
}
#[test]
fn bindgen_test_layout_OS_count_sem_prop_t() {
    assert_eq!(::std::mem::size_of::<OS_count_sem_prop_t>() , 28usize , concat
               ! ( "Size of: " , stringify ! ( OS_count_sem_prop_t ) ));
    assert_eq! (::std::mem::align_of::<OS_count_sem_prop_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( OS_count_sem_prop_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_count_sem_prop_t ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_count_sem_prop_t ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_count_sem_prop_t ) ) . creator as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_count_sem_prop_t ) ,
                "::" , stringify ! ( creator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_count_sem_prop_t ) ) . value as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_count_sem_prop_t ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for OS_count_sem_prop_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_mut_sem_prop_t {
    pub name: [::std::os::raw::c_char; 20usize],
    pub creator: uint32,
}
#[test]
fn bindgen_test_layout_OS_mut_sem_prop_t() {
    assert_eq!(::std::mem::size_of::<OS_mut_sem_prop_t>() , 24usize , concat !
               ( "Size of: " , stringify ! ( OS_mut_sem_prop_t ) ));
    assert_eq! (::std::mem::align_of::<OS_mut_sem_prop_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( OS_mut_sem_prop_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_mut_sem_prop_t ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_mut_sem_prop_t ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_mut_sem_prop_t ) ) . creator as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_mut_sem_prop_t ) ,
                "::" , stringify ! ( creator ) ));
}
impl Clone for OS_mut_sem_prop_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_time_t {
    pub seconds: uint32,
    pub microsecs: uint32,
}
#[test]
fn bindgen_test_layout_OS_time_t() {
    assert_eq!(::std::mem::size_of::<OS_time_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( OS_time_t ) ));
    assert_eq! (::std::mem::align_of::<OS_time_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( OS_time_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_time_t ) ) . seconds as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_time_t ) , "::" ,
                stringify ! ( seconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_time_t ) ) . microsecs as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_time_t ) , "::" ,
                stringify ! ( microsecs ) ));
}
impl Clone for OS_time_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_heap_prop_t {
    pub free_bytes: uint32,
    pub free_blocks: uint32,
    pub largest_free_block: uint32,
}
#[test]
fn bindgen_test_layout_OS_heap_prop_t() {
    assert_eq!(::std::mem::size_of::<OS_heap_prop_t>() , 12usize , concat ! (
               "Size of: " , stringify ! ( OS_heap_prop_t ) ));
    assert_eq! (::std::mem::align_of::<OS_heap_prop_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( OS_heap_prop_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_heap_prop_t ) ) . free_bytes as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_heap_prop_t ) , "::"
                , stringify ! ( free_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_heap_prop_t ) ) . free_blocks as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_heap_prop_t ) , "::"
                , stringify ! ( free_blocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_heap_prop_t ) ) . largest_free_block
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_heap_prop_t ) , "::"
                , stringify ! ( largest_free_block ) ));
}
impl Clone for OS_heap_prop_t {
    fn clone(&self) -> Self { *self }
}
pub type os_err_name_t = [::std::os::raw::c_char; 35usize];
pub type osal_task = ::std::os::raw::c_void;
pub type osal_task_entry = ::std::option::Option<unsafe extern "C" fn()>;
pub type OS_ArgCallback_t =
    ::std::option::Option<unsafe extern "C" fn(object_id: uint32,
                                               arg:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn OS_Application_Startup();
}
extern "C" {
    pub fn OS_API_Init() -> int32;
}
extern "C" {
    pub fn OS_IdleLoop();
}
extern "C" {
    pub fn OS_DeleteAllObjects();
}
extern "C" {
    pub fn OS_ApplicationShutdown(flag: uint8);
}
extern "C" {
    pub fn OS_TaskCreate(task_id: *mut uint32,
                         task_name: *const ::std::os::raw::c_char,
                         function_pointer: osal_task_entry,
                         stack_pointer: *mut uint32, stack_size: uint32,
                         priority: uint32, flags: uint32) -> int32;
}
extern "C" {
    pub fn OS_TaskDelete(task_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_TaskExit();
}
extern "C" {
    pub fn OS_TaskInstallDeleteHandler(function_pointer: osal_task_entry)
     -> int32;
}
extern "C" {
    pub fn OS_TaskDelay(millisecond: uint32) -> int32;
}
extern "C" {
    pub fn OS_TaskSetPriority(task_id: uint32, new_priority: uint32) -> int32;
}
extern "C" {
    pub fn OS_TaskRegister() -> int32;
}
extern "C" {
    pub fn OS_TaskGetId() -> uint32;
}
extern "C" {
    pub fn OS_TaskGetIdByName(task_id: *mut uint32,
                              task_name: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn OS_TaskGetInfo(task_id: uint32, task_prop: *mut OS_task_prop_t)
     -> int32;
}
extern "C" {
    pub fn OS_QueueCreate(queue_id: *mut uint32,
                          queue_name: *const ::std::os::raw::c_char,
                          queue_depth: uint32, data_size: uint32,
                          flags: uint32) -> int32;
}
extern "C" {
    pub fn OS_QueueDelete(queue_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_QueueGet(queue_id: uint32, data: *mut ::std::os::raw::c_void,
                       size: uint32, size_copied: *mut uint32, timeout: int32)
     -> int32;
}
extern "C" {
    pub fn OS_QueuePut(queue_id: uint32, data: *const ::std::os::raw::c_void,
                       size: uint32, flags: uint32) -> int32;
}
extern "C" {
    pub fn OS_QueueGetIdByName(queue_id: *mut uint32,
                               queue_name: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn OS_QueueGetInfo(queue_id: uint32, queue_prop: *mut OS_queue_prop_t)
     -> int32;
}
extern "C" {
    pub fn OS_BinSemCreate(sem_id: *mut uint32,
                           sem_name: *const ::std::os::raw::c_char,
                           sem_initial_value: uint32, options: uint32)
     -> int32;
}
extern "C" {
    pub fn OS_BinSemFlush(sem_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_BinSemGive(sem_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_BinSemTake(sem_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_BinSemTimedWait(sem_id: uint32, msecs: uint32) -> int32;
}
extern "C" {
    pub fn OS_BinSemDelete(sem_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_BinSemGetIdByName(sem_id: *mut uint32,
                                sem_name: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn OS_BinSemGetInfo(sem_id: uint32, bin_prop: *mut OS_bin_sem_prop_t)
     -> int32;
}
extern "C" {
    pub fn OS_CountSemCreate(sem_id: *mut uint32,
                             sem_name: *const ::std::os::raw::c_char,
                             sem_initial_value: uint32, options: uint32)
     -> int32;
}
extern "C" {
    pub fn OS_CountSemGive(sem_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_CountSemTake(sem_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_CountSemTimedWait(sem_id: uint32, msecs: uint32) -> int32;
}
extern "C" {
    pub fn OS_CountSemDelete(sem_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_CountSemGetIdByName(sem_id: *mut uint32,
                                  sem_name: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn OS_CountSemGetInfo(sem_id: uint32,
                              count_prop: *mut OS_count_sem_prop_t) -> int32;
}
extern "C" {
    pub fn OS_MutSemCreate(sem_id: *mut uint32,
                           sem_name: *const ::std::os::raw::c_char,
                           options: uint32) -> int32;
}
extern "C" {
    pub fn OS_MutSemGive(sem_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_MutSemTake(sem_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_MutSemDelete(sem_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_MutSemGetIdByName(sem_id: *mut uint32,
                                sem_name: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn OS_MutSemGetInfo(sem_id: uint32, mut_prop: *mut OS_mut_sem_prop_t)
     -> int32;
}
extern "C" {
    pub fn OS_Milli2Ticks(milli_seconds: uint32) -> int32;
}
extern "C" {
    pub fn OS_Tick2Micros() -> int32;
}
extern "C" {
    pub fn OS_GetLocalTime(time_struct: *mut OS_time_t) -> int32;
}
extern "C" {
    pub fn OS_SetLocalTime(time_struct: *mut OS_time_t) -> int32;
}
extern "C" {
    pub fn OS_ExcAttachHandler(ExceptionNumber: uint32,
                               ExceptionHandler:
                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                  uint32,
                                                                              arg2:
                                                                                  *const ::std::os::raw::c_void,
                                                                              arg3:
                                                                                  uint32)>,
                               parameter: int32) -> int32;
}
extern "C" {
    pub fn OS_ExcEnable(ExceptionNumber: int32) -> int32;
}
extern "C" {
    pub fn OS_ExcDisable(ExceptionNumber: int32) -> int32;
}
extern "C" {
    pub fn OS_FPUExcAttachHandler(ExceptionNumber: uint32,
                                  ExceptionHandler:
                                      *mut ::std::os::raw::c_void,
                                  parameter: int32) -> int32;
}
extern "C" {
    pub fn OS_FPUExcEnable(ExceptionNumber: int32) -> int32;
}
extern "C" {
    pub fn OS_FPUExcDisable(ExceptionNumber: int32) -> int32;
}
extern "C" {
    pub fn OS_FPUExcSetMask(mask: uint32) -> int32;
}
extern "C" {
    pub fn OS_FPUExcGetMask(mask: *mut uint32) -> int32;
}
extern "C" {
    pub fn OS_IntAttachHandler(InterruptNumber: uint32,
                               InterruptHandler: osal_task_entry,
                               parameter: int32) -> int32;
}
extern "C" {
    pub fn OS_IntUnlock(IntLevel: int32) -> int32;
}
extern "C" {
    pub fn OS_IntLock() -> int32;
}
extern "C" {
    pub fn OS_IntEnable(Level: int32) -> int32;
}
extern "C" {
    pub fn OS_IntDisable(Level: int32) -> int32;
}
extern "C" {
    pub fn OS_IntSetMask(mask: uint32) -> int32;
}
extern "C" {
    pub fn OS_IntGetMask(mask: *mut uint32) -> int32;
}
extern "C" {
    pub fn OS_IntAck(InterruptNumber: int32) -> int32;
}
extern "C" {
    pub fn OS_ShMemInit() -> int32;
}
extern "C" {
    pub fn OS_ShMemCreate(Id: *mut uint32, NBytes: uint32,
                          SegName: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_ShMemSemTake(Id: uint32) -> int32;
}
extern "C" {
    pub fn OS_ShMemSemGive(Id: uint32) -> int32;
}
extern "C" {
    pub fn OS_ShMemAttach(Address: *mut cpuaddr, Id: uint32) -> int32;
}
extern "C" {
    pub fn OS_ShMemGetIdByName(ShMemId: *mut uint32,
                               SegName: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn OS_HeapGetInfo(heap_prop: *mut OS_heap_prop_t) -> int32;
}
extern "C" {
    pub fn OS_GetErrorName(error_num: int32, err_name: *mut os_err_name_t)
     -> int32;
}
extern "C" {
    pub fn OS_printf(string: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn OS_printf_disable();
}
extern "C" {
    pub fn OS_printf_enable();
}
extern "C" {
    pub fn OS_ApplicationExit(Status: int32);
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait {
    pub w_status: __BindgenUnionField<::std::os::raw::c_int>,
    pub __wait_terminated: __BindgenUnionField<wait__bindgen_ty_1>,
    pub __wait_stopped: __BindgenUnionField<wait__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 127u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 127u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_termsig: ::std::os::raw::c_uint,
                          __w_coredump: ::std::os::raw::c_uint,
                          __w_retcode: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((__w_termsig as u32 as u32) << 0usize) &
                           (127u64 as u32))
              } | ((__w_coredump as u32 as u32) << 7usize) & (128u64 as u32))
         } | ((__w_retcode as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_stopval: ::std::os::raw::c_uint,
                          __w_stopsig: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((__w_stopval as u32 as u32) << 0usize) & (255u64 as u32))
         } | ((__w_stopsig as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize , concat ! (
               "Size of: " , stringify ! ( wait ) ));
    assert_eq! (::std::mem::align_of::<wait>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_terminated as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_terminated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_stopped as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_stopped ) ));
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __WAIT_STATUS {
    pub __uptr: __BindgenUnionField<*mut wait>,
    pub __iptr: __BindgenUnionField<*mut ::std::os::raw::c_int>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(::std::mem::size_of::<__WAIT_STATUS>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (::std::mem::align_of::<__WAIT_STATUS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __uptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __uptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __iptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __iptr ) ));
}
impl Clone for __WAIT_STATUS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<pthread_mutex_t___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutexattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<pthread_cond_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_condattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t {
    pub __data: __BindgenUnionField<pthread_rwlock_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers_queued as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_writers_queued as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlockattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrier_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrierattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(::std::mem::size_of::<dirent>() , 280usize , concat ! (
               "Size of: " , stringify ! ( dirent ) ));
    assert_eq! (::std::mem::align_of::<dirent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dirent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dirent ) ) . d_ino as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dirent ) , "::" ,
                stringify ! ( d_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dirent ) ) . d_off as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dirent ) , "::" ,
                stringify ! ( d_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dirent ) ) . d_reclen as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( dirent ) , "::" ,
                stringify ! ( d_reclen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dirent ) ) . d_type as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( dirent ) , "::" ,
                stringify ! ( d_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dirent ) ) . d_name as * const _ as usize
                } , 19usize , concat ! (
                "Alignment of field: " , stringify ! ( dirent ) , "::" ,
                stringify ! ( d_name ) ));
}
pub const DT_UNKNOWN: _bindgen_ty_1 = _bindgen_ty_1::DT_UNKNOWN;
pub const DT_FIFO: _bindgen_ty_1 = _bindgen_ty_1::DT_FIFO;
pub const DT_CHR: _bindgen_ty_1 = _bindgen_ty_1::DT_CHR;
pub const DT_DIR: _bindgen_ty_1 = _bindgen_ty_1::DT_DIR;
pub const DT_BLK: _bindgen_ty_1 = _bindgen_ty_1::DT_BLK;
pub const DT_REG: _bindgen_ty_1 = _bindgen_ty_1::DT_REG;
pub const DT_LNK: _bindgen_ty_1 = _bindgen_ty_1::DT_LNK;
pub const DT_SOCK: _bindgen_ty_1 = _bindgen_ty_1::DT_SOCK;
pub const DT_WHT: _bindgen_ty_1 = _bindgen_ty_1::DT_WHT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(__dirp: *mut DIR, __entry: *mut dirent,
                     __result: *mut *mut dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir(__dir: *const ::std::os::raw::c_char,
                   __namelist: *mut *mut *mut dirent,
                   __selector:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const dirent)
                                                 -> ::std::os::raw::c_int>,
                   __cmp:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut *const dirent,
                                                                  arg2:
                                                                      *mut *const dirent)
                                                 -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentries(__fd: ::std::os::raw::c_int,
                         __buf: *mut ::std::os::raw::c_char, __nbytes: usize,
                         __basep: *mut __off_t) -> __ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(::std::mem::size_of::<stat>() , 144usize , concat ! (
               "Size of: " , stringify ! ( stat ) ));
    assert_eq! (::std::mem::align_of::<stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_dev as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_ino as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_nlink as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_nlink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_mode as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_uid as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_gid as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . __pad0 as * const _ as usize }
                , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( __pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_rdev as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_rdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_size as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_blksize as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_blocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_blocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_atim as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_atim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_mtim as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_mtim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_ctim as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_ctim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . __glibc_reserved as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( __glibc_reserved ) ));
}
impl Clone for stat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn stat(__file: *const ::std::os::raw::c_char, __buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(__fd: ::std::os::raw::c_int,
                   __file: *const ::std::os::raw::c_char, __buf: *mut stat,
                   __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(__file: *const ::std::os::raw::c_char, __buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodat(__fd: ::std::os::raw::c_int,
                    __file: *const ::std::os::raw::c_char, __mode: __mode_t,
                    __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(__fd: ::std::os::raw::c_int,
                   __path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(__path: *const ::std::os::raw::c_char, __mode: __mode_t,
                 __dev: __dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(__fd: ::std::os::raw::c_int,
                   __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                   __dev: __dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(__fd: ::std::os::raw::c_int,
                    __path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(__fd: ::std::os::raw::c_int,
                     __path: *const ::std::os::raw::c_char,
                     __times: *const timespec, __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstat(__ver: ::std::os::raw::c_int,
                    __fildes: ::std::os::raw::c_int, __stat_buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xstat(__ver: ::std::os::raw::c_int,
                   __filename: *const ::std::os::raw::c_char,
                   __stat_buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lxstat(__ver: ::std::os::raw::c_int,
                    __filename: *const ::std::os::raw::c_char,
                    __stat_buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstatat(__ver: ::std::os::raw::c_int,
                      __fildes: ::std::os::raw::c_int,
                      __filename: *const ::std::os::raw::c_char,
                      __stat_buf: *mut stat, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknod(__ver: ::std::os::raw::c_int,
                    __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                    __dev: *mut __dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknodat(__ver: ::std::os::raw::c_int,
                      __fd: ::std::os::raw::c_int,
                      __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                      __dev: *mut __dev_t) -> ::std::os::raw::c_int;
}
pub type os_fs_err_name_t = os_err_name_t;
#[repr(C)]
pub struct OS_VolumeInfo_t {
    pub DeviceName: [::std::os::raw::c_char; 32usize],
    pub PhysDevName: [::std::os::raw::c_char; 64usize],
    pub VolumeType: uint32,
    pub VolatileFlag: uint8,
    pub FreeFlag: uint8,
    pub IsMounted: uint8,
    pub VolumeName: [::std::os::raw::c_char; 32usize],
    pub MountPoint: [::std::os::raw::c_char; 64usize],
    pub BlockSize: uint32,
}
#[test]
fn bindgen_test_layout_OS_VolumeInfo_t() {
    assert_eq!(::std::mem::size_of::<OS_VolumeInfo_t>() , 204usize , concat !
               ( "Size of: " , stringify ! ( OS_VolumeInfo_t ) ));
    assert_eq! (::std::mem::align_of::<OS_VolumeInfo_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( OS_VolumeInfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_VolumeInfo_t ) ) . DeviceName as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_VolumeInfo_t ) ,
                "::" , stringify ! ( DeviceName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_VolumeInfo_t ) ) . PhysDevName as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_VolumeInfo_t ) ,
                "::" , stringify ! ( PhysDevName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_VolumeInfo_t ) ) . VolumeType as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_VolumeInfo_t ) ,
                "::" , stringify ! ( VolumeType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_VolumeInfo_t ) ) . VolatileFlag as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_VolumeInfo_t ) ,
                "::" , stringify ! ( VolatileFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_VolumeInfo_t ) ) . FreeFlag as * const
                _ as usize } , 101usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_VolumeInfo_t ) ,
                "::" , stringify ! ( FreeFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_VolumeInfo_t ) ) . IsMounted as *
                const _ as usize } , 102usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_VolumeInfo_t ) ,
                "::" , stringify ! ( IsMounted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_VolumeInfo_t ) ) . VolumeName as *
                const _ as usize } , 103usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_VolumeInfo_t ) ,
                "::" , stringify ! ( VolumeName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_VolumeInfo_t ) ) . MountPoint as *
                const _ as usize } , 135usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_VolumeInfo_t ) ,
                "::" , stringify ! ( MountPoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_VolumeInfo_t ) ) . BlockSize as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_VolumeInfo_t ) ,
                "::" , stringify ! ( BlockSize ) ));
}
#[repr(C)]
pub struct OS_FDTableEntry {
    pub OSfd: int32,
    pub Path: [::std::os::raw::c_char; 64usize],
    pub User: uint32,
    pub IsValid: uint8,
}
#[test]
fn bindgen_test_layout_OS_FDTableEntry() {
    assert_eq!(::std::mem::size_of::<OS_FDTableEntry>() , 76usize , concat ! (
               "Size of: " , stringify ! ( OS_FDTableEntry ) ));
    assert_eq! (::std::mem::align_of::<OS_FDTableEntry>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( OS_FDTableEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_FDTableEntry ) ) . OSfd as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_FDTableEntry ) ,
                "::" , stringify ! ( OSfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_FDTableEntry ) ) . Path as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_FDTableEntry ) ,
                "::" , stringify ! ( Path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_FDTableEntry ) ) . User as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_FDTableEntry ) ,
                "::" , stringify ! ( User ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_FDTableEntry ) ) . IsValid as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_FDTableEntry ) ,
                "::" , stringify ! ( IsValid ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct os_fsinfo_t {
    pub MaxFds: uint32,
    pub FreeFds: uint32,
    pub MaxVolumes: uint32,
    pub FreeVolumes: uint32,
}
#[test]
fn bindgen_test_layout_os_fsinfo_t() {
    assert_eq!(::std::mem::size_of::<os_fsinfo_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( os_fsinfo_t ) ));
    assert_eq! (::std::mem::align_of::<os_fsinfo_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( os_fsinfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const os_fsinfo_t ) ) . MaxFds as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( os_fsinfo_t ) , "::" ,
                stringify ! ( MaxFds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const os_fsinfo_t ) ) . FreeFds as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( os_fsinfo_t ) , "::" ,
                stringify ! ( FreeFds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const os_fsinfo_t ) ) . MaxVolumes as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( os_fsinfo_t ) , "::" ,
                stringify ! ( MaxVolumes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const os_fsinfo_t ) ) . FreeVolumes as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( os_fsinfo_t ) , "::" ,
                stringify ! ( FreeVolumes ) ));
}
impl Clone for os_fsinfo_t {
    fn clone(&self) -> Self { *self }
}
pub type os_fstat_t = stat;
pub type os_dirp_t = *mut DIR;
pub type os_dirent_t = dirent;
pub type os_fshealth_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn OS_FS_Init() -> int32;
}
extern "C" {
    pub fn OS_creat(path: *const ::std::os::raw::c_char, access: int32)
     -> int32;
}
extern "C" {
    pub fn OS_open(path: *const ::std::os::raw::c_char, access: int32,
                   mode: uint32) -> int32;
}
extern "C" {
    pub fn OS_close(filedes: int32) -> int32;
}
extern "C" {
    pub fn OS_read(filedes: int32, buffer: *mut ::std::os::raw::c_void,
                   nbytes: uint32) -> int32;
}
extern "C" {
    pub fn OS_write(filedes: int32, buffer: *mut ::std::os::raw::c_void,
                    nbytes: uint32) -> int32;
}
extern "C" {
    pub fn OS_chmod(path: *const ::std::os::raw::c_char, access: uint32)
     -> int32;
}
extern "C" {
    pub fn OS_stat(path: *const ::std::os::raw::c_char,
                   filestats: *mut os_fstat_t) -> int32;
}
extern "C" {
    pub fn OS_lseek(filedes: int32, offset: int32, whence: uint32) -> int32;
}
extern "C" {
    pub fn OS_remove(path: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_rename(old_filename: *const ::std::os::raw::c_char,
                     new_filename: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_cp(src: *const ::std::os::raw::c_char,
                 dest: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_mv(src: *const ::std::os::raw::c_char,
                 dest: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_FDGetInfo(filedes: int32, fd_prop: *mut OS_FDTableEntry)
     -> int32;
}
extern "C" {
    pub fn OS_FileOpenCheck(Filename: *mut ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_CloseAllFiles() -> int32;
}
extern "C" {
    pub fn OS_CloseFileByName(Filename: *mut ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_mkdir(path: *const ::std::os::raw::c_char, access: uint32)
     -> int32;
}
extern "C" {
    pub fn OS_opendir(path: *const ::std::os::raw::c_char) -> os_dirp_t;
}
extern "C" {
    pub fn OS_closedir(directory: os_dirp_t) -> int32;
}
extern "C" {
    pub fn OS_rewinddir(directory: os_dirp_t);
}
extern "C" {
    pub fn OS_readdir(directory: os_dirp_t) -> *mut os_dirent_t;
}
extern "C" {
    pub fn OS_rmdir(path: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_mkfs(address: *mut ::std::os::raw::c_char,
                   devname: *mut ::std::os::raw::c_char,
                   volname: *mut ::std::os::raw::c_char, blocksize: uint32,
                   numblocks: uint32) -> int32;
}
extern "C" {
    pub fn OS_mount(devname: *const ::std::os::raw::c_char,
                    mountpoint: *mut ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_initfs(address: *mut ::std::os::raw::c_char,
                     devname: *mut ::std::os::raw::c_char,
                     volname: *mut ::std::os::raw::c_char, blocksize: uint32,
                     numblocks: uint32) -> int32;
}
extern "C" {
    pub fn OS_rmfs(devname: *mut ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_unmount(mountpoint: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_fsBlocksFree(name: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_fsBytesFree(name: *const ::std::os::raw::c_char,
                          bytes_free: *mut uint64) -> int32;
}
extern "C" {
    pub fn OS_chkfs(name: *const ::std::os::raw::c_char, repair: boolean)
     -> os_fshealth_t;
}
extern "C" {
    pub fn OS_FS_GetPhysDriveName(PhysDriveName: *mut ::std::os::raw::c_char,
                                  MountPoint: *mut ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn OS_TranslatePath(VirtualPath: *const ::std::os::raw::c_char,
                            LocalPath: *mut ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_GetFsInfo(filesys_info: *mut os_fsinfo_t) -> int32;
}
extern "C" {
    pub fn OS_ShellOutputToFile(Cmd: *mut ::std::os::raw::c_char,
                                OS_fd: int32) -> int32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OS_SocketDomain_t {
    OS_SocketDomain_INVALID = 0,
    OS_SocketDomain_INET = 1,
    OS_SocketDomain_INET6 = 2,
    OS_SocketDomain_MAX = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OS_SocketType_t {
    OS_SocketType_INVALID = 0,
    OS_SocketType_DATAGRAM = 1,
    OS_SocketType_STREAM = 2,
    OS_SocketType_MAX = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_SockAddr_t {
    pub ActualLength: uint32,
    pub AddrData: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_OS_SockAddr_t() {
    assert_eq!(::std::mem::size_of::<OS_SockAddr_t>() , 36usize , concat ! (
               "Size of: " , stringify ! ( OS_SockAddr_t ) ));
    assert_eq! (::std::mem::align_of::<OS_SockAddr_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( OS_SockAddr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_SockAddr_t ) ) . ActualLength as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_SockAddr_t ) , "::"
                , stringify ! ( ActualLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_SockAddr_t ) ) . AddrData as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_SockAddr_t ) , "::"
                , stringify ! ( AddrData ) ));
}
impl Clone for OS_SockAddr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_socket_prop_t {
    pub name: [::std::os::raw::c_char; 20usize],
    pub creator: uint32,
}
#[test]
fn bindgen_test_layout_OS_socket_prop_t() {
    assert_eq!(::std::mem::size_of::<OS_socket_prop_t>() , 24usize , concat !
               ( "Size of: " , stringify ! ( OS_socket_prop_t ) ));
    assert_eq! (::std::mem::align_of::<OS_socket_prop_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( OS_socket_prop_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_socket_prop_t ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_socket_prop_t ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_socket_prop_t ) ) . creator as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_socket_prop_t ) ,
                "::" , stringify ! ( creator ) ));
}
impl Clone for OS_socket_prop_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn OS_SocketOpen(sock_id: *mut uint32, Domain: OS_SocketDomain_t,
                         Type: OS_SocketType_t) -> int32;
}
extern "C" {
    pub fn OS_SocketClose(sock_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_SocketBind(sock_id: uint32, Addr: *const OS_SockAddr_t)
     -> int32;
}
extern "C" {
    pub fn OS_SocketConnect(sock_id: uint32, Addr: *const OS_SockAddr_t,
                            timeout: int32) -> int32;
}
extern "C" {
    pub fn OS_SocketAccept(sock_id: uint32, connsock_id: *mut uint32,
                           Addr: *mut OS_SockAddr_t, timeout: int32) -> int32;
}
extern "C" {
    pub fn OS_SocketRecvFrom(sock_id: uint32,
                             buffer: *mut ::std::os::raw::c_void,
                             buflen: uint32, RemoteAddr: *mut OS_SockAddr_t,
                             timeout: int32) -> int32;
}
extern "C" {
    pub fn OS_SocketSendTo(sock_id: uint32,
                           buffer: *const ::std::os::raw::c_void,
                           buflen: uint32, RemoteAddr: *const OS_SockAddr_t)
     -> int32;
}
extern "C" {
    pub fn OS_SocketGetIdByName(sock_id: *mut uint32,
                                sock_name: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn OS_SocketGetInfo(sock_id: uint32, sock_prop: *mut OS_socket_prop_t)
     -> int32;
}
extern "C" {
    pub fn OS_SocketAddrInit(Addr: *mut OS_SockAddr_t,
                             Domain: OS_SocketDomain_t) -> int32;
}
extern "C" {
    pub fn OS_SocketAddrToString(buffer: *mut ::std::os::raw::c_char,
                                 buflen: uint32, Addr: *const OS_SockAddr_t)
     -> int32;
}
extern "C" {
    pub fn OS_SocketAddrFromString(Addr: *mut OS_SockAddr_t,
                                   string: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn OS_SocketAddrGetPort(PortNum: *mut uint16,
                                Addr: *const OS_SockAddr_t) -> int32;
}
extern "C" {
    pub fn OS_SocketAddrSetPort(Addr: *mut OS_SockAddr_t, PortNum: uint16)
     -> int32;
}
extern "C" {
    pub fn OS_NetworkGetID() -> int32;
}
extern "C" {
    pub fn OS_NetworkGetHostName(host_name: *mut ::std::os::raw::c_char,
                                 name_len: uint32) -> int32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_module_address_t {
    pub valid: uint32,
    pub flags: uint32,
    pub code_address: cpuaddr,
    pub code_size: cpuaddr,
    pub data_address: cpuaddr,
    pub data_size: cpuaddr,
    pub bss_address: cpuaddr,
    pub bss_size: cpuaddr,
}
#[test]
fn bindgen_test_layout_OS_module_address_t() {
    assert_eq!(::std::mem::size_of::<OS_module_address_t>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( OS_module_address_t ) ));
    assert_eq! (::std::mem::align_of::<OS_module_address_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( OS_module_address_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_address_t ) ) . valid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_address_t ) ,
                "::" , stringify ! ( valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_address_t ) ) . flags as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_address_t ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_address_t ) ) . code_address as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_address_t ) ,
                "::" , stringify ! ( code_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_address_t ) ) . code_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_address_t ) ,
                "::" , stringify ! ( code_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_address_t ) ) . data_address as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_address_t ) ,
                "::" , stringify ! ( data_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_address_t ) ) . data_size as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_address_t ) ,
                "::" , stringify ! ( data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_address_t ) ) . bss_address as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_address_t ) ,
                "::" , stringify ! ( bss_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_address_t ) ) . bss_size as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_address_t ) ,
                "::" , stringify ! ( bss_size ) ));
}
impl Clone for OS_module_address_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct OS_module_prop_t {
    pub entry_point: cpuaddr,
    pub host_module_id: uint32,
    pub filename: [::std::os::raw::c_char; 64usize],
    pub name: [::std::os::raw::c_char; 20usize],
    pub addr: OS_module_address_t,
}
#[test]
fn bindgen_test_layout_OS_module_prop_t() {
    assert_eq!(::std::mem::size_of::<OS_module_prop_t>() , 152usize , concat !
               ( "Size of: " , stringify ! ( OS_module_prop_t ) ));
    assert_eq! (::std::mem::align_of::<OS_module_prop_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( OS_module_prop_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_prop_t ) ) . entry_point as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_prop_t ) ,
                "::" , stringify ! ( entry_point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_prop_t ) ) . host_module_id as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_prop_t ) ,
                "::" , stringify ! ( host_module_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_prop_t ) ) . filename as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_prop_t ) ,
                "::" , stringify ! ( filename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_prop_t ) ) . name as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_prop_t ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_module_prop_t ) ) . addr as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_module_prop_t ) ,
                "::" , stringify ! ( addr ) ));
}
pub type OS_module_record_t = OS_module_prop_t;
extern "C" {
    pub fn OS_ModuleTableInit() -> int32;
}
extern "C" {
    pub fn OS_SymbolLookup(symbol_address: *mut cpuaddr,
                           symbol_name: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn OS_SymbolTableDump(filename: *const ::std::os::raw::c_char,
                              size_limit: uint32) -> int32;
}
extern "C" {
    pub fn OS_ModuleLoad(module_id: *mut uint32,
                         module_name: *const ::std::os::raw::c_char,
                         filename: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_ModuleUnload(module_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_ModuleInfo(module_id: uint32,
                         module_info: *mut OS_module_prop_t) -> int32;
}
pub type OS_TimerCallback_t =
    ::std::option::Option<unsafe extern "C" fn(timer_id: uint32)>;
pub type OS_TimerSync_t =
    ::std::option::Option<unsafe extern "C" fn(timer_id: uint32) -> int32>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_timer_prop_t {
    pub name: [::std::os::raw::c_char; 20usize],
    pub creator: uint32,
    pub start_time: uint32,
    pub interval_time: uint32,
    pub accuracy: uint32,
}
#[test]
fn bindgen_test_layout_OS_timer_prop_t() {
    assert_eq!(::std::mem::size_of::<OS_timer_prop_t>() , 36usize , concat ! (
               "Size of: " , stringify ! ( OS_timer_prop_t ) ));
    assert_eq! (::std::mem::align_of::<OS_timer_prop_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( OS_timer_prop_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_timer_prop_t ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_timer_prop_t ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_timer_prop_t ) ) . creator as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_timer_prop_t ) ,
                "::" , stringify ! ( creator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_timer_prop_t ) ) . start_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_timer_prop_t ) ,
                "::" , stringify ! ( start_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_timer_prop_t ) ) . interval_time as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_timer_prop_t ) ,
                "::" , stringify ! ( interval_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_timer_prop_t ) ) . accuracy as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_timer_prop_t ) ,
                "::" , stringify ! ( accuracy ) ));
}
impl Clone for OS_timer_prop_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OS_timebase_prop_t {
    pub name: [::std::os::raw::c_char; 20usize],
    pub creator: uint32,
    pub interval_time: uint32,
    pub accuracy: uint32,
}
#[test]
fn bindgen_test_layout_OS_timebase_prop_t() {
    assert_eq!(::std::mem::size_of::<OS_timebase_prop_t>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( OS_timebase_prop_t ) ));
    assert_eq! (::std::mem::align_of::<OS_timebase_prop_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( OS_timebase_prop_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_timebase_prop_t ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_timebase_prop_t ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_timebase_prop_t ) ) . creator as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_timebase_prop_t ) ,
                "::" , stringify ! ( creator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_timebase_prop_t ) ) . interval_time as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_timebase_prop_t ) ,
                "::" , stringify ! ( interval_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const OS_timebase_prop_t ) ) . accuracy as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( OS_timebase_prop_t ) ,
                "::" , stringify ! ( accuracy ) ));
}
impl Clone for OS_timebase_prop_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn OS_TimerAPIInit() -> int32;
}
extern "C" {
    pub fn OS_TimeBaseCreate(timer_id: *mut uint32,
                             timebase_name: *const ::std::os::raw::c_char,
                             external_sync: OS_TimerSync_t) -> int32;
}
extern "C" {
    pub fn OS_TimeBaseSet(timer_id: uint32, start_time: uint32,
                          interval_time: uint32) -> int32;
}
extern "C" {
    pub fn OS_TimeBaseDelete(timer_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_TimeBaseGetIdByName(timer_id: *mut uint32,
                                  timebase_name:
                                      *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn OS_TimerCreate(timer_id: *mut uint32,
                          timer_name: *const ::std::os::raw::c_char,
                          clock_accuracy: *mut uint32,
                          callback_ptr: OS_TimerCallback_t) -> int32;
}
extern "C" {
    pub fn OS_TimerAdd(timer_id: *mut uint32,
                       timer_name: *const ::std::os::raw::c_char,
                       timebase_id: uint32, callback_ptr: OS_ArgCallback_t,
                       callback_arg: *mut ::std::os::raw::c_void) -> int32;
}
extern "C" {
    pub fn OS_TimerSet(timer_id: uint32, start_time: uint32,
                       interval_time: uint32) -> int32;
}
extern "C" {
    pub fn OS_TimerDelete(timer_id: uint32) -> int32;
}
extern "C" {
    pub fn OS_TimerGetIdByName(timer_id: *mut uint32,
                               timer_name: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn OS_TimerGetInfo(timer_id: uint32, timer_prop: *mut OS_timer_prop_t)
     -> int32;
}
/*****************************************************************************/
pub type CFE_ES_MemHandle_t = cpuaddr;
#[repr(C)]
pub struct CFE_ES_AppInfo_t {
    /**< \cfetlmmnemonic \ES_APP_ID
                                                 \brief Application ID for this Application */
    pub AppId: uint32,
    /**< \cfetlmmnemonic \ES_APPTYPE
                                                 \brief The type of App: CORE or EXTERNAL */
    pub Type: uint32,
    /**< \cfetlmmnemonic \ES_APPNAME
                                                 \brief The Registered Name of the Application */
    pub Name: [::std::os::raw::c_char; 20usize],
    /**< \cfetlmmnemonic \ES_APPENTRYPT
                                                 \brief The Entry Point label for the Application */
    pub EntryPoint: [::std::os::raw::c_char; 20usize],
    /**< \cfetlmmnemonic \ES_APPFILENAME
                                                 \brief The Filename of the file containing the Application */
    pub FileName: [::std::os::raw::c_char; 64usize],
    /**< \cfetlmmnemonic \ES_STACKSIZE
                                                 \brief The Stack Size of the Application */
    pub StackSize: uint32,
    /**< \cfetlmmnemonic \ES_MODULEID
                                                 \brief The ID of the Loadable Module for the Application */
    pub ModuleId: uint32,
    /**< \cfetlmmnemonic \ES_ADDRVALID
                                                 \brief Indicates that the Code, Data, and BSS addresses/sizes are valid */
    pub AddressesAreValid: uint32,
    /**< \cfetlmmnemonic \ES_CODEADDR
                                                 \brief The Address of the Application Code Segment*/
    pub CodeAddress: uint32,
    /**< \cfetlmmnemonic \ES_CODESIZE
                                                 \brief The Code Size of the Application */
    pub CodeSize: uint32,
    /**< \cfetlmmnemonic \ES_DATAADDR
                                                 \brief The Address of the Application Data Segment*/
    pub DataAddress: uint32,
    /**< \cfetlmmnemonic \ES_DATASIZE
                                                 \brief The Data Size of the Application */
    pub DataSize: uint32,
    /**< \cfetlmmnemonic \ES_BSSADDR
                                                 \brief The Address of the Application BSS Segment*/
    pub BSSAddress: uint32,
    /**< \cfetlmmnemonic \ES_BSSSIZE
                                                  \brief The BSS Size of the Application */
    pub BSSSize: uint32,
    /**< \cfetlmmnemonic \ES_STARTADDR
                                                 \brief The Start Address of the Application */
    pub StartAddress: uint32,
    /**< \cfetlmmnemonic \ES_EXCEPTNACTN
                                                 \brief What should occur if Application has an exception
                                                 (Restart Application OR Restart Processor) */
    pub ExceptionAction: uint16,
    /**< \cfetlmmnemonic \ES_PRIORITY
                                                 \brief The Priority of the Application */
    pub Priority: uint16,
    /**< \cfetlmmnemonic \ES_MAINTASKID
                                                 \brief The Application's Main Task ID */
    pub MainTaskId: uint32,
    /**< \cfetlmmnemonic \ES_MAINTASKEXECNT
                                                 \brief The Application's Main Task Execution Counter */
    pub ExecutionCounter: uint32,
    /**< \cfetlmmnemonic \ES_MAINTASKNAME
                                                 \brief The Application's Main Task ID */
    pub MainTaskName: [::std::os::raw::c_char; 20usize],
    /**< \cfetlmmnemonic \ES_CHILDTASKS
                                                 \brief Number of Child tasks for an App */
    pub NumOfChildTasks: uint32,
}
#[test]
fn bindgen_test_layout_CFE_ES_AppInfo_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_AppInfo_t>() , 188usize , concat !
               ( "Size of: " , stringify ! ( CFE_ES_AppInfo_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_AppInfo_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( CFE_ES_AppInfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . AppId as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( AppId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . Type as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( Type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . Name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( Name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . EntryPoint as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( EntryPoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . FileName as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( FileName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . StackSize as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( StackSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . ModuleId as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( ModuleId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . AddressesAreValid
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( AddressesAreValid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . CodeAddress as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( CodeAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . CodeSize as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( CodeSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . DataAddress as *
                const _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( DataAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . DataSize as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( DataSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . BSSAddress as *
                const _ as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( BSSAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . BSSSize as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( BSSSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . StartAddress as *
                const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( StartAddress ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . ExceptionAction as
                * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( ExceptionAction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . Priority as *
                const _ as usize } , 154usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( Priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . MainTaskId as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( MainTaskId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . ExecutionCounter
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( ExecutionCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . MainTaskName as *
                const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( MainTaskName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppInfo_t ) ) . NumOfChildTasks as
                * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppInfo_t ) ,
                "::" , stringify ! ( NumOfChildTasks ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_TaskInfo_t {
    /**< \brief Task Id */
    pub TaskId: uint32,
    pub ExecutionCounter: uint32,
    /**< \brief Task Name */
    pub TaskName: [uint8; 20usize],
    /**< \brief Parent Application ID */
    pub AppId: uint32,
    /**< \brief Parent Application Name */
    pub AppName: [uint8; 20usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_TaskInfo_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_TaskInfo_t>() , 52usize , concat !
               ( "Size of: " , stringify ! ( CFE_ES_TaskInfo_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_TaskInfo_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_ES_TaskInfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_TaskInfo_t ) ) . TaskId as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_TaskInfo_t ) ,
                "::" , stringify ! ( TaskId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_TaskInfo_t ) ) . ExecutionCounter
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_TaskInfo_t ) ,
                "::" , stringify ! ( ExecutionCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_TaskInfo_t ) ) . TaskName as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_TaskInfo_t ) ,
                "::" , stringify ! ( TaskName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_TaskInfo_t ) ) . AppId as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_TaskInfo_t ) ,
                "::" , stringify ! ( AppId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_TaskInfo_t ) ) . AppName as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_TaskInfo_t ) ,
                "::" , stringify ! ( AppName ) ));
}
impl Clone for CFE_ES_TaskInfo_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_BlockStats_t {
    /**< \brief Number of bytes in each of these blocks */
    pub BlockSize: uint32,
    /**< \brief Number of Memory Blocks of this size created */
    pub NumCreated: uint32,
    /**< \brief Number of Memory Blocks of this size that are free */
    pub NumFree: uint32,
}
#[test]
fn bindgen_test_layout_CFE_ES_BlockStats_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_BlockStats_t>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( CFE_ES_BlockStats_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_BlockStats_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_BlockStats_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_BlockStats_t ) ) . BlockSize as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_BlockStats_t ) ,
                "::" , stringify ! ( BlockSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_BlockStats_t ) ) . NumCreated as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_BlockStats_t ) ,
                "::" , stringify ! ( NumCreated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_BlockStats_t ) ) . NumFree as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_BlockStats_t ) ,
                "::" , stringify ! ( NumFree ) ));
}
impl Clone for CFE_ES_BlockStats_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_MemPoolStats_t {
    /**< \cfetlmmnemonic \ES_POOLSIZE
                                                        \brief  Size of Memory Pool (in bytes) */
    pub PoolSize: uint32,
    /**< \cfetlmmnemonic \ES_BLKSREQ
                                                        \brief Number of times a memory block has been allocated */
    pub NumBlocksRequested: uint32,
    /**< \cfetlmmnemonic \ES_BLKERRCTR
                                                        \brief Number of errors detected when freeing a memory block */
    pub CheckErrCtr: uint32,
    /**< \cfetlmmnemonic \ES_FREEBYTES
                                                        \brief Number of bytes never allocated to a block */
    pub NumFreeBytes: uint32,
    /**< \cfetlmmnemonic \ES_BLKSTATS
                                                                           \brief Contains stats on each block size */
    pub BlockStats: [CFE_ES_BlockStats_t; 17usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_MemPoolStats_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_MemPoolStats_t>() , 220usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_MemPoolStats_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_MemPoolStats_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_MemPoolStats_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_MemPoolStats_t ) ) . PoolSize as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_MemPoolStats_t )
                , "::" , stringify ! ( PoolSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_MemPoolStats_t ) ) .
                NumBlocksRequested as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! ( CFE_ES_MemPoolStats_t )
                , "::" , stringify ! ( NumBlocksRequested ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_MemPoolStats_t ) ) . CheckErrCtr
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_MemPoolStats_t )
                , "::" , stringify ! ( CheckErrCtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_MemPoolStats_t ) ) . NumFreeBytes
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_MemPoolStats_t )
                , "::" , stringify ! ( NumFreeBytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_MemPoolStats_t ) ) . BlockStats as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_MemPoolStats_t )
                , "::" , stringify ! ( BlockStats ) ));
}
impl Clone for CFE_ES_MemPoolStats_t {
    fn clone(&self) -> Self { *self }
}
pub type CFE_ES_CDSHandle_t = cpuaddr;
#[repr(C)]
pub struct CFE_ES_CDSRegDumpRec_t {
    /**< \brief Handle of CDS */
    pub Handle: CFE_ES_CDSHandle_t,
    /**< \brief Size, in bytes, of the CDS memory block */
    pub Size: uint32,
    /**< \brief Flag that indicates whether CDS contains a Critical Table */
    pub Table: boolean,
    /**< \brief Processor Unique Name of CDS */
    pub Name: [::std::os::raw::c_char; 38usize],
    /**< \brief Spare byte to insure structure size is multiple of 4 bytes */
    pub ByteAlignSpare1: uint8,
}
#[test]
fn bindgen_test_layout_CFE_ES_CDSRegDumpRec_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_CDSRegDumpRec_t>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_CDSRegDumpRec_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_CDSRegDumpRec_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_CDSRegDumpRec_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_CDSRegDumpRec_t ) ) . Handle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_CDSRegDumpRec_t
                ) , "::" , stringify ! ( Handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_CDSRegDumpRec_t ) ) . Size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_CDSRegDumpRec_t
                ) , "::" , stringify ! ( Size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_CDSRegDumpRec_t ) ) . Table as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_CDSRegDumpRec_t
                ) , "::" , stringify ! ( Table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_CDSRegDumpRec_t ) ) . Name as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_CDSRegDumpRec_t
                ) , "::" , stringify ! ( Name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_CDSRegDumpRec_t ) ) .
                ByteAlignSpare1 as * const _ as usize } , 51usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_CDSRegDumpRec_t
                ) , "::" , stringify ! ( ByteAlignSpare1 ) ));
}
pub type CFE_ES_ChildTaskMainFuncPtr_t =
    ::std::option::Option<unsafe extern "C" fn()>;
pub type CFE_ES_LibraryEntryFuncPtr_t =
    ::std::option::Option<unsafe extern "C" fn() -> int32>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CFE_ES_StaticEntryType_t {
    CFE_ES_STATICENTRYTYPE_INVALID = 0,
    CFE_ES_STATICENTRYTYPE_FIRST_VALID = 2000,
    CFE_ES_STATICENTRYTYPE_APPLICATION = 2001,
    CFE_ES_STATICENTRYTYPE_LIBRARY = 2002,
    CFE_ES_STATICENTRYTYPE_MAX = 2003,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2 {
    pub EntryType: CFE_ES_StaticEntryType_t,
    pub Ptrs: _bindgen_ty_2__bindgen_ty_1,
    pub Priority: uint32,
    pub StackSize: uint32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2__bindgen_ty_1 {
    /**< \brief Entry point for Application */
    pub AppEntryFunc: __BindgenUnionField<CFE_ES_ChildTaskMainFuncPtr_t>,
    /**< \brief Initialization function for Library */
    pub LibInitFunc: __BindgenUnionField<CFE_ES_LibraryEntryFuncPtr_t>,
    pub EntryFuncAddr: __BindgenUnionField<cpuaddr>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_2__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( _bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_bindgen_ty_2__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _bindgen_ty_2__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_2__bindgen_ty_1 ) ) .
                AppEntryFunc as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                AppEntryFunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_2__bindgen_ty_1 ) ) .
                LibInitFunc as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                LibInitFunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_2__bindgen_ty_1 ) ) .
                EntryFuncAddr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                EntryFuncAddr ) ));
}
impl Clone for _bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_2>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<_bindgen_ty_2>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_2 ) ) . EntryType as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_2 ) , "::"
                , stringify ! ( EntryType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_2 ) ) . Ptrs as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_2 ) , "::"
                , stringify ! ( Ptrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_2 ) ) . Priority as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_2 ) , "::"
                , stringify ! ( Priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_2 ) ) . StackSize as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_2 ) , "::"
                , stringify ! ( StackSize ) ));
}
impl Clone for _bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
pub type CFE_ES_AppStaticModuleApi_t = _bindgen_ty_2;
extern "C" {
    /*****************************************************************************/
/**
** \brief cFE Main Entry Point used by Board Support Package to start cFE
**
** \par Description
**        cFE main entry point. This is the entry point into the cFE software.
**        It is called only by the Board Support Package software.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  StartType     Identifies whether this was a #CFE_PSP_RST_TYPE_POWERON or #CFE_PSP_RST_TYPE_PROCESSOR.
**
** \param[in]  StartSubtype  Specifies, in more detail, what caused the \c StartType identified above.
**                           See #CFE_ES_POWER_CYCLE for possible examples.
**
** \param[in]  ModeId        Identifies the source of the Boot as determined by the BSP.
**
** \param[in]  StartFilePath Identifies the startup file to use to initialize the cFE apps.
**
** \sa #CFE_ES_ResetCFE
**
******************************************************************************/
    pub fn CFE_ES_Main(StartType: uint32, StartSubtype: uint32,
                       ModeId: uint32,
                       StartFilePath: *const ::std::os::raw::c_char);
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Return the most recent Reset Type
**
** \par Description
**        Provides the caller with codes that identifies the type of Reset
**        the processor most recently underwent.  The caller can also obtain
**        information on what caused the reset by supplying a pointer to a
**        variable that will be filled with the Reset Sub-Type.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]   ResetSubtypePtr    Pointer to \c uint32 type variable in which the Reset Sub-Type will be stored.
**                                 The caller can set this pointer to NULL if the Sub-Type is of no interest.
**
** \param[out]  *ResetSubtypePtr   If the provided pointer was not \c NULL, the Reset Sub-Type is stored at the given address.
**                                 For a list of possible Sub-Type values, see \link #CFE_ES_POWER_CYCLE "Reset Sub-Types" \endlink.
**
** \returns
** \retcode #CFE_PSP_RST_TYPE_POWERON   \retdesc \copydoc CFE_PSP_RST_TYPE_POWERON    \endcode
** \retcode #CFE_PSP_RST_TYPE_PROCESSOR \retdesc \copydoc CFE_PSP_RST_TYPE_PROCESSOR  \endcode
** \endreturns
**
** \sa #CFE_ES_GetAppID, #CFE_ES_GetAppIDByName, #CFE_ES_GetAppName, #CFE_ES_GetTaskInfo
**
******************************************************************************/
    pub fn CFE_ES_GetResetType(ResetSubtypePtr: *mut uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Reset the cFE Core and all cFE Applications
**
** \par Description
**        This API causes an immediate reset of the cFE Kernel and all cFE Applications.
**        The caller can specify whether the reset should clear all memory (#CFE_PSP_RST_TYPE_POWERON)
**        or try to retain volatile memory areas (#CFE_PSP_RST_TYPE_PROCESSOR).
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  ResetType    Identifies the type of reset desired.  Allowable settings are:
**                          \arg #CFE_PSP_RST_TYPE_POWERON     - Causes all memory to be cleared 
**                          \arg #CFE_PSP_RST_TYPE_PROCESSOR   - Attempts to retain volatile disk, critical data store and user reserved memory. 
**
** \returns
** \retcode #CFE_ES_BAD_ARGUMENT    \retdesc \copydoc CFE_ES_BAD_ARGUMENT     \endcode
** \retcode #CFE_ES_NOT_IMPLEMENTED \retdesc \copydoc CFE_ES_NOT_IMPLEMENTED  \endcode
** \endreturns
**
** \sa #CFE_ES_Main
**
******************************************************************************/
    pub fn CFE_ES_ResetCFE(ResetType: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Restart a single cFE Application
**
** \par Description
**        This API causes a cFE Application to be stopped and restarted.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  AppID       Identifies the application to be reset.
**
** \returns
** \retcode #CFE_ES_NOT_IMPLEMENTED \retdesc \copydoc CFE_ES_NOT_IMPLEMENTED  \endcode
** \endreturns
**
** \sa #CFE_ES_ReloadApp, #CFE_ES_DeleteApp
**
******************************************************************************/
    pub fn CFE_ES_RestartApp(AppID: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Reload a single cFE Application
**
** \par Description
**        This API causes a cFE Application to be stopped and restarted from
**        the specified file.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  AppID       Identifies the application to be reset.
**
** \param[in]  AppFileName Identifies the new file to start.
**
** \returns
** \retcode #CFE_ES_NOT_IMPLEMENTED \retdesc \copydoc CFE_ES_NOT_IMPLEMENTED  \endcode
** \endreturns
**
** \sa #CFE_ES_RestartApp, #CFE_ES_DeleteApp
**
******************************************************************************/
    pub fn CFE_ES_ReloadApp(AppID: uint32,
                            AppFileName: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Delete a cFE Application
**
** \par Description
**        This API causes a cFE Application to be stopped deleted.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  AppID       Identifies the application to be reset.
**
** \returns
** \retcode #CFE_ES_NOT_IMPLEMENTED \retdesc \copydoc CFE_ES_NOT_IMPLEMENTED  \endcode
** \endreturns
**
** \sa #CFE_ES_RestartApp, #CFE_ES_ReloadApp
**
******************************************************************************/
    pub fn CFE_ES_DeleteApp(AppID: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Exit a cFE Application
**
** \par Description
**        This API is the "Exit Point" for the cFE application
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  ExitStatus     .
**
** \returns
** \retcode #CFE_ES_NOT_IMPLEMENTED \retdesc \copydoc CFE_ES_NOT_IMPLEMENTED  \endcode
** \endreturns
**
** \sa #CFE_ES_RunLoop, #CFE_ES_RegisterApp
**
******************************************************************************/
    pub fn CFE_ES_ExitApp(ExitStatus: uint32);
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Check for Exit, Restart, or Reload commands
**
** \par Description
**        This is the API that allows an app to check for exit requests from
**         the system.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  ExitStatus   A pointer to a variable containing the Application's
**                          desired run status.  Acceptable values are:
**                          \arg #CFE_ES_APP_RUN - \copydoc CFE_ES_APP_RUN
**                          \arg #CFE_ES_APP_EXIT - \copydoc CFE_ES_APP_EXIT
**                          \arg #CFE_ES_APP_ERROR - \copydoc CFE_ES_APP_ERROR
**
** \returns
** \retcode #TRUE  \retdesc The application should continue executing \endcode
** \retcode #FALSE \retdesc The application should terminate itself \endcode
** \endreturns
**
** \sa #CFE_ES_ExitApp, #CFE_ES_RegisterApp
**
******************************************************************************/
    pub fn CFE_ES_RunLoop(ExitStatus: *mut uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Allow an Application to Wait for others to start up
**
** \par Description
**        This is the API that allows an app to wait for the "rest" of the apps
**        to finish initializing before continuing. It is most useful for 
**        applications such as Health and Safety or the Scheduler that need
**        to wait until applications exist and are running before sending out
**        packets to them.
**
** \par Assumptions, External Events, and Notes:
**          This API should only be called as the last item of an Apps initialization.
**          In addition, this API should only be called by an App that is started
**          from the ES Startup file. It should not be used by an App that is 
**          started after the system is running. ( Although it will cause no harm )
**
** \param[in]  TimeOutMilliseconds   The timeout value in Milliseconds.
**                                   This parameter must be at least 1000. Lower values
**                                   will be rounded up. There is not an option to 
**                                   wait indefinitely to avoid hanging a critical
**                                   application because a non-critical app did not start. 
**
**
** \sa #CFE_ES_RunLoop
**
******************************************************************************/
    pub fn CFE_ES_WaitForStartupSync(TimeOutMilliseconds: uint32);
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Registers a cFE Application with the Executive Services
**
** \par Description
**        This API registers the calling Application with the cFE.
**
** \par Assumptions, External Events, and Notes:
**        NOTE: This function \b MUST be called before any other cFE API functions are called.
**
** \returns
** \retstmt Return codes from #OS_TaskRegister          \endcode
** \retstmt Return codes from #OS_BinSemTake            \endcode
** \retcode #CFE_SUCCESS \retdesc \copydoc CFE_SUCCESS  \endcode
** \endreturns
**
** \sa #CFE_ES_ExitApp, #CFE_ES_RunLoop
**
******************************************************************************/
    pub fn CFE_ES_RegisterApp() -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get an Application ID for the calling Application
**
** \par Description
**        This routine retrieves the cFE Application ID for the calling Application.  
**
** \par Assumptions, External Events, and Notes:
**        NOTE: \b All tasks associated with the Application would return the same Application ID.
**
** \param[in]   AppIdPtr       Pointer to variable that is to receive the Application's ID.
**
** \param[out]  *AppIdPtr      Application ID of the calling Application.
**
** \returns
** \retcode #CFE_SUCCESS       \retdesc \copydoc CFE_SUCCESS        \endcode
** \retcode #CFE_ES_ERR_APPID  \retdesc \copydoc CFE_ES_ERR_APPID   \endcode
** \retcode #CFE_ES_ERR_BUFFER \retdesc \copydoc CFE_ES_ERR_BUFFER  \endcode
** \endreturns
**
** \sa #CFE_ES_GetResetType, #CFE_ES_GetAppIDByName, #CFE_ES_GetAppName, #CFE_ES_GetTaskInfo
**
******************************************************************************/
    pub fn CFE_ES_GetAppID(AppIdPtr: *mut uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get an Application ID associated with a specified Application name
**
** \par Description
**        This routine retrieves the cFE Application ID associated with a
**        specified Application name.  
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   AppIdPtr       Pointer to variable that is to receive the Application's ID.
**
** \param[in]   AppName        Pointer to null terminated character string containing an Application name.
**
** \param[out]  *AppIdPtr      Application ID of the calling Application.
**
** \returns
** \retcode #CFE_SUCCESS         \retdesc \copydoc CFE_SUCCESS         \endcode
** \retcode #CFE_ES_ERR_APPNAME  \retdesc \copydoc CFE_ES_ERR_APPNAME  \endcode
** \retcode #CFE_ES_ERR_BUFFER   \retdesc \copydoc CFE_ES_ERR_BUFFER   \endcode
** \endreturns
**
** \sa #CFE_ES_GetResetType, #CFE_ES_GetAppID, #CFE_ES_GetAppName, #CFE_ES_GetTaskInfo
**
******************************************************************************/
    pub fn CFE_ES_GetAppIDByName(AppIdPtr: *mut uint32,
                                 AppName: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get an Application name for a specified Application ID
**
** \par Description
**        This routine retrieves the cFE Application ID associated with a
**        specified Application name.  
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   AppName       Pointer to a character array of at least \c BufferLength in size that will
**                            be filled with the appropriate Application name.
**
** \param[in]   AppId         Application ID of Application whose name is being requested.
**
** \param[in]   BufferLength  The maximum number of characters, including the null terminator, that can be put
**                            into the \c AppName buffer.  This routine will truncate the name to this length,
**                            if necessary.
**
** \param[out]  *AppName      Null terminated Application name of the Application associated with the 
**                            specified Application ID.
**
** \returns
** \retcode #CFE_SUCCESS         \retdesc \copydoc CFE_SUCCESS        \endcode
** \retcode #CFE_ES_ERR_APPID    \retdesc \copydoc CFE_ES_ERR_APPID   \endcode
** \retcode #CFE_ES_ERR_BUFFER   \retdesc \copydoc CFE_ES_ERR_BUFFER  \endcode
** \endreturns
**
** \sa #CFE_ES_GetResetType, #CFE_ES_GetAppID, #CFE_ES_GetAppIDByName, #CFE_ES_GetTaskInfo
**
******************************************************************************/
    pub fn CFE_ES_GetAppName(AppName: *mut ::std::os::raw::c_char,
                             AppId: uint32, BufferLength: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get Application Information given a specified App ID
**
** \par Description
**        This routine retrieves the information about an App associated with a
**        specified App ID. The information includes all of the information ES 
**        maintains for an application ( documented in the CFE_ES_AppInfo_t type ) 
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   AppInfo      Pointer to a \c CFE_ES_AppInfo_t structure that holds the specific 
**                            Application information.
**
** \param[in]   AppId        Application ID of Application whose name is being requested.
**
** \param[out]  *AppInfo     Filled out \c CFE_ES_AppInfo_t structure containing the 
**                            App Name, and application memory addresses among other fields.
**
** \returns
** \retcode #CFE_SUCCESS         \retdesc \copydoc CFE_SUCCESS         \endcode
** \retcode #CFE_ES_ERR_APPID    \retdesc \copydoc CFE_ES_ERR_APPID    \endcode
** \retcode #CFE_ES_ERR_BUFFER   \retdesc \copydoc CFE_ES_ERR_BUFFER   \endcode
** \endreturns
**
** \sa #CFE_ES_GetResetType, #CFE_ES_GetAppID, #CFE_ES_GetAppIDByName, #CFE_ES_GetAppName
**
******************************************************************************/
    pub fn CFE_ES_GetAppInfo(AppInfo: *mut CFE_ES_AppInfo_t, AppId: uint32)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get Task Information given a specified Task ID
**
** \par Description
**        This routine retrieves the information about a Task associated with a
**        specified Task ID. The information includes Task Name, and Parent/Creator 
**        Application ID.
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   TaskInfo      Pointer to a \c CFE_ES_TaskInfo_t structure that holds the specific 
**                            task information.
**
** \param[in]   TaskId        Application ID of Application whose name is being requested.
**
** \param[out]  *TaskInfo     Filled out \c CFE_ES_TaskInfo_t structure containing the 
**                            Task Name, Parent App Name, Parent App ID among other fields.
**
** \returns
** \retcode #CFE_SUCCESS         \retdesc \copydoc CFE_SUCCESS         \endcode
** \retcode #CFE_ES_ERR_TASKID   \retdesc \copydoc CFE_ES_ERR_TASKID   \endcode
** \retcode #CFE_ES_ERR_BUFFER   \retdesc \copydoc CFE_ES_ERR_BUFFER   \endcode
** \endreturns
**
** \sa #CFE_ES_GetResetType, #CFE_ES_GetAppID, #CFE_ES_GetAppIDByName, #CFE_ES_GetAppName
**
******************************************************************************/
    pub fn CFE_ES_GetTaskInfo(TaskInfo: *mut CFE_ES_TaskInfo_t,
                              TaskId: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Registers a cFE Child task associated with a cFE Application
**
** \par Description
**        This routine registers a cFE Child task and associates it with its parent
**        cFE Application.  
**
** \par Assumptions, External Events, and Notes:
**        NOTE: This API \b MUST be called by the Child Task before any other cFE API calls are made.
**
** \returns
** \retcode #CFE_SUCCESS                       \retdesc \copydoc CFE_SUCCESS                     \endcode
** \retcode #CFE_ES_ERR_CHILD_TASK_REGISTER    \retdesc \copydoc CFE_ES_ERR_CHILD_TASK_REGISTER  \endcode
** \endreturns
**
** \sa #CFE_ES_CreateChildTask, #CFE_ES_DeleteChildTask, #CFE_ES_ExitChildTask
**
******************************************************************************/
    pub fn CFE_ES_RegisterChildTask() -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Creates a new task under an existing Application
**
** \par Description
**        This routine creates a new task (a separate execution thread) owned by the calling Application.  
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   TaskIdPtr     A pointer to a variable that will be filled in with the new task's ID.
**
** \param[in]   TaskName      A pointer to a string containing the desired name of the new task.  
**                            This can be up to #OS_MAX_API_NAME characters, including the trailing null.
**
** \param[in]   FunctionPtr   A pointer to the function that will be spawned as a new task.  This function 
**                            must have the following signature: uint32 function(void).  Input parameters 
**                            for the new task are not supported.
**
** \param[in]   StackPtr      A pointer to the location where the child task's stack pointer should start.   
**                            NOTE: Not all underlying operating systems support this parameter.
**
** \param[in]   StackSize     The number of bytes to allocate for the new task's stack.
**
** \param[in]   Priority      The priority for the new task.  Lower numbers are higher priority, with 0 being 
**                            the highest priority.  Applications cannot create tasks with a higher priority 
**                            (lower number) than their own priority.
**
** \param[in]   Flags         Reserved for future expansion.
**
** \param[out]  *TaskIdPtr    The Task ID of the newly created child task.
**
** \returns
** \retcode #CFE_SUCCESS                     \retdesc \copydoc CFE_SUCCESS                   \endcode
** \retcode #CFE_ES_ERR_CHILD_TASK_CREATE    \retdesc \copydoc CFE_ES_ERR_CHILD_TASK_CREATE  \endcode
** \endreturns
**
** \sa #CFE_ES_RegisterChildTask, #CFE_ES_DeleteChildTask, #CFE_ES_ExitChildTask
**
******************************************************************************/
    pub fn CFE_ES_CreateChildTask(TaskIdPtr: *mut uint32,
                                  TaskName: *const ::std::os::raw::c_char,
                                  FunctionPtr: CFE_ES_ChildTaskMainFuncPtr_t,
                                  StackPtr: *mut uint32, StackSize: uint32,
                                  Priority: uint32, Flags: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Deletes a task under an existing Application
**
** \par Description
**        This routine deletes a task under an Application specified by the \c TaskId obtained
**        when the child task was created using the #CFE_ES_CreateChildTask API.
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   TaskId     The task ID previously obtained when the Child Task was created with the #CFE_ES_CreateChildTask API.
**
** \returns
** \retcode #CFE_ES_NOT_IMPLEMENTED \retdesc \copydoc CFE_ES_NOT_IMPLEMENTED  \endcode
** \endreturns
**
** \sa #CFE_ES_RegisterChildTask, #CFE_ES_CreateChildTask, #CFE_ES_ExitChildTask
**
******************************************************************************/
    pub fn CFE_ES_DeleteChildTask(TaskId: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Exits a child task
**
** \par Description
**        This routine allows the current executing child task to exit and 
**        be deleted by ES.
**
** \par Assumptions, External Events, and Notes:
**        This function cannot be called from an Application's Main Task.
**
** \returns
** \retstmt
**        This function does not return a value, but if it does return
**        at all, it is assumed that the Task was either unregistered or
**        this function was called from a cFE Application's main task.   \endcode
** \endreturns
**
** \sa #CFE_ES_RegisterChildTask, #CFE_ES_CreateChildTask, #CFE_ES_DeleteChildTask
**
******************************************************************************/
    pub fn CFE_ES_ExitChildTask();
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Increments the execution counter for the calling task
**
** \par Description
**        This routine increments the execution counter that is stored for
**        the calling task. It can be called from cFE Application main tasks, child
**        tasks, or cFE Core application main tasks. Normally, the call is not 
**        necessary from a cFE Application, since the CFE_ES_RunLoop call increments
**        the counter for the Application. 
**
** \par Assumptions, External Events, and Notes:
**        NOTE: This API is not needed for Appplications that call the CFE_ES_RunLoop call.
**
** \returns
** \retstmt
**        This function does not return a value.   \endcode
** \endreturns
**
** \sa #CFE_ES_RunLoop
**
******************************************************************************/
    pub fn CFE_ES_IncrementTaskCounter();
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Write a string to the cFE System Log
**
** \par Description
**        This routine writes a formatted string to the cFE system log.  This 
**        can be used to record very low-level errors that can't be reported 
**        using the Event Services. This function is used in place of printf 
**        for flight software. It should be used for significant startup events, 
**        critical errors, and conditionally compiled debug software. 
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   SpecStringPtr     The format string for the log message.  
**                                This is similar to the format string for a printf() call.
**
** \returns
** \retcode #CFE_SUCCESS             \retdesc \copydoc CFE_SUCCESS             \endcode
** \retcode #CFE_ES_ERR_SYS_LOG_FULL \retdesc \copydoc CFE_ES_ERR_SYS_LOG_FULL \endcode
** \endreturns
**
** \sa
**
******************************************************************************/
    pub fn CFE_ES_WriteToSysLog(SpecStringPtr:
                                    *const ::std::os::raw::c_char, ...)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Calculate a CRC on a block of memory
**
** \par Description
**        This routine calculates a cyclic redundancy check (CRC) on a block of memory.  The CRC algorithm
**        used is determined by the last parameter. 
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   DataPtr     Pointer to the base of the memory block.
**
** \param[in]   DataLength  The number of bytes in the memory block.
**
** \param[in]   InputCRC    A starting value for use in the CRC calculation.  This parameter
**                          allows the user to calculate the CRC of non-contiguous blocks as
**                          a single value.  Nominally, the user should set this value to zero.
**
** \param[in]   TypeCRC     One of the following CRC algorithm selections:
**
**                          \arg \c CFE_ES_CRC_8 - (Not currently implemented)
**                          \arg \c CFE_ES_CRC_16 - a CRC-16 algorithm
**                          \arg \c CFE_ES_CRC_32 - (not currently implemented)
**
** \returns
** \retstmt The result of the CRC calculation on the specified memory block. \endcode
** \endreturns
**
******************************************************************************/
    pub fn CFE_ES_CalculateCRC(DataPtr: *const ::std::os::raw::c_void,
                               DataLength: uint32, InputCRC: uint32,
                               TypeCRC: uint32) -> uint32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Reserve space (or re-obtain previously reserved space) in the Critical Data Store (CDS)
**
** \par Description
**        This routine allocates a block of memory in the Critical Data Store and associates it with
**        the calling Application.  The memory can survive an Application restart as well as a Processor Reset. 
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   HandlePtr   Pointer Application's variable that will contain the CDS Memory Block Handle.
**
** \param[in]   BlockSize   The number of bytes needed in the CDS.
**
** \param[in]   Name        A pointer to a character string containing an application 
**                          unique name of #CFE_ES_CDS_MAX_NAME_LENGTH characters or less.
**
** \param[out]  *HandlePtr  The handle of the CDS block that can be used in 
**                          #CFE_ES_CopyToCDS and #CFE_ES_RestoreFromCDS.
**
** \returns
** \retcode #CFE_SUCCESS  \retdesc The memory block was successfully created in the CDS.           \endcode
** \retcode #CFE_ES_NOT_IMPLEMENTED \retdesc The processor does not support a Critical Data Store. \endcode
** \retcode #CFE_ES_CDS_ALREADY_EXISTS \retdesc \copydoc CFE_ES_CDS_ALREADY_EXISTS                 \endcode
** \retcode #CFE_ES_CDS_INVALID_SIZE   \retdesc \copydoc CFE_ES_CDS_INVALID_SIZE                   \endcode
** \retcode #CFE_ES_CDS_INVALID_NAME   \retdesc \copydoc CFE_ES_CDS_INVALID_NAME                   \endcode
** \retcode #CFE_ES_CDS_REGISTRY_FULL  \retdesc \copydoc CFE_ES_CDS_REGISTRY_FULL                  \endcode
** \endreturns
**
** \sa #CFE_ES_CopyToCDS, #CFE_ES_RestoreFromCDS
**
******************************************************************************/
    pub fn CFE_ES_RegisterCDS(HandlePtr: *mut CFE_ES_CDSHandle_t,
                              BlockSize: int32,
                              Name: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Save a block of data in the Critical Data Store (CDS)
**
** \par Description
**        This routine copies a specified block of memory into the Critical Data Store that
**        had been previously registered via #CFE_ES_RegisterCDS.  The block of memory to be
**        copied must be at least as big as the size specified when registering the CDS.
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   Handle       The handle of the CDS block that was previously obtained from #CFE_ES_RegisterCDS.
**
** \param[in]   DataToCopy   A Pointer to the block of memory to be copied into the CDS.
**
** \returns
** \retcode #OS_SUCCESS              \retdesc \copydoc OS_SUCCESS              \endcode
** \retcode #CFE_ES_ERR_MEM_HANDLE   \retdesc \copydoc CFE_ES_ERR_MEM_HANDLE   \endcode
** \retcode #OS_ERROR                \retdesc Problem with handle or a size mismatch   \endcode
** \endreturns
**
** \sa #CFE_ES_RegisterCDS, #CFE_ES_RestoreFromCDS
**
*/
    pub fn CFE_ES_CopyToCDS(Handle: CFE_ES_CDSHandle_t,
                            DataToCopy: *mut ::std::os::raw::c_void) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Recover a block of data from the Critical Data Store (CDS)
**
** \par Description
**        This routine copies data from the Critical Data Store identified with the \c Handle into
**        the area of memory pointed to by the \c RestoreToMemory pointer.  The area of memory to
**        be copied into must be at least as big as the size specified when registering the CDS.
**        The recovery will indicate an error if the data integrity check maintained by the CDS 
**        indicates the contents of the CDS have changed.  However, the contents will still be
**        copied into the specified area of memory.
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   Handle             The handle of the CDS block that was previously obtained from #CFE_ES_RegisterCDS.
**
** \param[in]   RestoreToMemory    A Pointer to the block of memory that is to be restored with the contents of the CDS.
**
** \param[out]  *RestoreToMemory   The contents of the specified CDS.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS                     \endcode
** \retcode #CFE_ES_CDS_BLOCK_CRC_ERR   \retdesc \copydoc CFE_ES_CDS_BLOCK_CRC_ERR        \endcode
** \retcode #OS_ERROR                   \retdesc Problem with handle or a size mismatch   \endcode
** \endreturns
**
** \sa #CFE_ES_RegisterCDS, #CFE_ES_CopyToCDS
**
*/
    pub fn CFE_ES_RestoreFromCDS(RestoreToMemory: *mut ::std::os::raw::c_void,
                                 Handle: CFE_ES_CDSHandle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Initializes a memory pool created by an application without using a semaphore during processing.
**
** \par Description
**        This routine initializes a pool of memory supplied by the calling application.  When a memory pool
**        created by this routine is processed, no mutex handling is performed.  
**
** \par Assumptions, External Events, and Notes:
**        -# The size of the pool must be an integral number of 32-bit words
**        -# The start address of the pool must be 32-bit aligned
**        -# 168 bytes are used for internal bookkeeping, therefore, they will not be available for allocation.
**
** \param[in]   HandlePtr   A pointer to the variable the caller wishes to have the memory pool handle kept in.
**
** \param[in]   MemPtr      A Pointer to the pool of memory created by the calling application. This address must
**                          be on a 32-bit boundary.
**
** \param[in]   Size        The size of the pool of memory.  Note that this must be an integral number of 32 bit words.
**
** \param[out]  *HandlePtr  The memory pool handle.
**
** \returns
** \retcode #CFE_SUCCESS           \retdesc \copydoc CFE_SUCCESS           \endcode
** \retcode #CFE_ES_BAD_ARGUMENT   \retdesc \copydoc CFE_ES_BAD_ARGUMENT   \endcode
** \endreturns
**
** \sa #CFE_ES_PoolCreate, #CFE_ES_PoolCreateEx, #CFE_ES_GetPoolBuf, #CFE_ES_PutPoolBuf, #CFE_ES_GetMemPoolStats
**
******************************************************************************/
    pub fn CFE_ES_PoolCreateNoSem(HandlePtr: *mut CFE_ES_MemHandle_t,
                                  MemPtr: *mut uint8, Size: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Initializes a memory pool created by an application while using a semaphore during processing.
**
** \par Description
**        This routine initializes a pool of memory supplied by the calling application.  When a memory pool
**        created by this routine is processed, mutex handling will be performed.  
**
** \par Assumptions, External Events, and Notes:
**        -# The size of the pool must be an integral number of 32-bit words
**        -# The start address of the pool must be 32-bit aligned
**        -# 168 bytes are used for internal bookkeeping, therefore, they will not be available for allocation.
**
** \param[in]   HandlePtr   A pointer to the variable the caller wishes to have the memory pool handle kept in.
**
** \param[in]   MemPtr      A Pointer to the pool of memory created by the calling application. This address must
**                          be on a 32-bit boundary.
**
** \param[in]   Size        The size of the pool of memory.  Note that this must be an integral number of 32 bit words.
**
** \param[out]  *HandlePtr  The memory pool handle.
**
** \returns
** \retcode #CFE_SUCCESS           \retdesc \copydoc CFE_SUCCESS           \endcode
** \retcode #CFE_ES_BAD_ARGUMENT   \retdesc \copydoc CFE_ES_BAD_ARGUMENT   \endcode
** \endreturns
**
** \sa #CFE_ES_PoolCreateNoSem, #CFE_ES_PoolCreateEx, #CFE_ES_GetPoolBuf, #CFE_ES_PutPoolBuf, #CFE_ES_GetMemPoolStats
**
******************************************************************************/
    pub fn CFE_ES_PoolCreate(HandlePtr: *mut CFE_ES_MemHandle_t,
                             MemPtr: *mut uint8, Size: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Initializes a memory pool created by an application with application specified block sizes.
**
** \par Description
**        This routine initializes a pool of memory supplied by the calling application.  
**
** \par Assumptions, External Events, and Notes:
**        -# The size of the pool must be an integral number of 32-bit words
**        -# The start address of the pool must be 32-bit aligned
**        -# 168 bytes are used for internal bookkeeping, therefore, they will not be available for allocation.
**
** \param[in]   HandlePtr      A pointer to the variable the caller wishes to have the memory pool handle kept in.
**
** \param[in]   MemPtr         A Pointer to the pool of memory created by the calling application. This address must
**                             be on a 32-bit boundary.
**
** \param[in]   Size           The size of the pool of memory.  Note that this must be an integral number of 32 bit words.
**
** \param[in]   NumBlockSizes  The number of different block sizes specified in the \c BlockSizes array. If set equal to
**                             zero or if greater than 17, then default block sizes are used.
**
** \param[in]   BlockSizes     Pointer to an array of sizes to be used instead of the default block sizes specified by
**                             #CFE_ES_MEM_BLOCK_SIZE_01 through #CFE_ES_MAX_BLOCK_SIZE.  If the pointer is equal to NULL,
**                             the default block sizes are used.
**
** \param[in]   UseMutex       Flag indicating whether the new memory pool will be processing with mutex handling or not.
**                             Valid parameter values are #CFE_ES_USE_MUTEX and #CFE_ES_NO_MUTEX
**
** \param[out]  *HandlePtr     The memory pool handle.
**
** \returns
** \retcode #CFE_SUCCESS           \retdesc \copydoc CFE_SUCCESS          \endcode
** \retcode #CFE_ES_BAD_ARGUMENT   \retdesc \copydoc CFE_ES_BAD_ARGUMENT  \endcode
** \endreturns
**
** \sa #CFE_ES_PoolCreate, #CFE_ES_PoolCreateNoSem, #CFE_ES_GetPoolBuf, #CFE_ES_PutPoolBuf, #CFE_ES_GetMemPoolStats
**
******************************************************************************/
    pub fn CFE_ES_PoolCreateEx(HandlePtr: *mut CFE_ES_MemHandle_t,
                               MemPtr: *mut uint8, Size: uint32,
                               NumBlockSizes: uint32, BlockSizes: *mut uint32,
                               UseMutex: uint16) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Gets a buffer from the memory pool created by #CFE_ES_PoolCreate or #CFE_ES_PoolCreateNoSem
**
** \par Description
**        This routine obtains a block of memory from the memory pool supplied by the calling application.    
**
** \par Assumptions, External Events, and Notes:
**        -# The size allocated from the memory pool is, at a minimum, 12 bytes more than requested.
**
** \param[in]   BufPtr      A pointer to the Application's pointer in which will be stored the address of the allocated memory buffer.
**
** \param[in]   HandlePtr   The handle to the memory pool as returned by #CFE_ES_PoolCreate or #CFE_ES_PoolCreateNoSem.
**
** \param[in]   Size        The size of the buffer requested.  NOTE: The size allocated may be larger.
**
** \param[out]  *BufPtr     The address of the requested buffer.
**
** \returns
** \retstmt When successful, the return value is a positive number and is the number of bytes 
**          actually allocated for the buffer. \endcode
** \retcode #CFE_ES_ERR_MEM_HANDLE      \retdesc \copydoc CFE_ES_ERR_MEM_HANDLE       \endcode
** \retcode #CFE_ES_ERR_MEM_BLOCK_SIZE  \retdesc \copydoc CFE_ES_ERR_MEM_BLOCK_SIZE   \endcode
** \endreturns
**
** \sa #CFE_ES_PoolCreate, #CFE_ES_PoolCreateNoSem, #CFE_ES_PoolCreateEx, #CFE_ES_PutPoolBuf, #CFE_ES_GetMemPoolStats, #CFE_ES_GetPoolBufInfo
**
******************************************************************************/
    pub fn CFE_ES_GetPoolBuf(BufPtr: *mut *mut uint32,
                             HandlePtr: CFE_ES_MemHandle_t, Size: uint32)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Gets info on a buffer previously allocated via #CFE_ES_GetPoolBuf
**
** \par Description
**        This routine gets info on a buffer in the memory pool.    
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   HandlePtr   The handle to the memory pool as returned by #CFE_ES_PoolCreate or #CFE_ES_PoolCreateNoSem.
**
** \param[in]   BufPtr      A pointer to the memory buffer to provide status for.
**
** \returns
** \retstmt When successful, the return value is a positive number and is the number of bytes actually allocated. \endcode
** \retcode #CFE_ES_ERR_MEM_HANDLE      \retdesc \copydoc CFE_ES_ERR_MEM_HANDLE   \endcode
** \retcode #CFE_ES_BUFFER_NOT_IN_POOL  \retdesc \copydoc CFE_ES_BUFFER_NOT_IN_POOL   \endcode
** \endreturns
**
** \sa #CFE_ES_PoolCreate, #CFE_ES_PoolCreateNoSem, #CFE_ES_PoolCreateEx, #CFE_ES_GetPoolBuf, #CFE_ES_GetMemPoolStats, #CFE_ES_PutPoolBuf
**
******************************************************************************/
    pub fn CFE_ES_GetPoolBufInfo(HandlePtr: CFE_ES_MemHandle_t,
                                 BufPtr: *mut uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Releases a buffer from the memory pool that was previously allocated via #CFE_ES_GetPoolBuf
**
** \par Description
**        This routine releases a buffer back into the memory pool.    
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   HandlePtr   The handle to the memory pool as returned by #CFE_ES_PoolCreate or #CFE_ES_PoolCreateNoSem.
**
** \param[in]   BufPtr      A pointer to the memory buffer to be released.
**
** \returns
** \retstmt When successful, the return value is a positive number and is the number of bytes actually released. \endcode
** \retcode #CFE_ES_ERR_MEM_HANDLE      \retdesc \copydoc CFE_ES_ERR_MEM_HANDLE   \endcode
** \endreturns
**
** \sa #CFE_ES_PoolCreate, #CFE_ES_PoolCreateNoSem, #CFE_ES_PoolCreateEx, #CFE_ES_GetPoolBuf, #CFE_ES_GetMemPoolStats, #CFE_ES_GetPoolBufInfo
**
******************************************************************************/
    pub fn CFE_ES_PutPoolBuf(HandlePtr: CFE_ES_MemHandle_t,
                             BufPtr: *mut uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Extracts the statistics maintained by the memory pool software
**
** \par Description
**        This routine fills the #CFE_ES_MemPoolStats_t data structure with the statistics
**        maintained by the memory pool software.  These statistics can then be telemetered
**        by the calling Application.    
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   BufPtr      Pointer to #CFE_ES_MemPoolStats_t data structure to be 
**                          filled with memory statistics.
**
** \param[in]   Handle      The handle to the memory pool whose statistics are desired.
**
** \param[out] *BufPtr      Memory Pool Statistics stored in given data structure.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_ES_ERR_MEM_HANDLE      \retdesc \copydoc CFE_ES_ERR_MEM_HANDLE  \endcode
** \endreturns
**
** \sa #CFE_ES_PoolCreate, #CFE_ES_PoolCreateNoSem, #CFE_ES_PoolCreateEx, #CFE_ES_GetPoolBuf, #CFE_ES_PutPoolBuf
**
******************************************************************************/
    pub fn CFE_ES_GetMemPoolStats(BufPtr: *mut CFE_ES_MemPoolStats_t,
                                  Handle: CFE_ES_MemHandle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Function called by CFE_ES_PerfLogEntry and CFE_ES_PerfLogExit macros
**
** \par Description
**        This function logs the entry and exit marker for the specified 
**        \c id. This function is used by the Software Performance Analysis 
**        tool (see section 5.15).    
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]   Marker          Identifier of the specific event or marker.
** \param[in]   EntryExit       Used to specify Entry(0) or Exit(1)
**
** \sa #CFE_ES_PerfLogEntry, #CFE_ES_PerfLogExit
**
******************************************************************************/
    pub fn CFE_ES_PerfLogAdd(Marker: uint32, EntryExit: uint32);
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Register a generic counter
**
** \par Description
**        This routine registers a generic counter. 
**
** \par Assumptions, External Events, and Notes:
**        None.
**
** \param[in]  *CounterName   The Name of the generic counter.
**
** \param[out] *CounterIdPtr  The Counter Id of the newly created counter.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_ES_BAD_ARGUMENT      \retdesc \copydoc CFE_ES_BAD_ARGUMENT  \endcode
** \endreturns
**
** \sa #CFE_ES_IncrementGenCounter, #CFE_ES_DeleteGenCounter, #CFE_ES_SetGenCount, #CFE_ES_GetGenCount, #CFE_ES_GetGenCounterIDByName
**
******************************************************************************/
    pub fn CFE_ES_RegisterGenCounter(CounterIdPtr: *mut uint32,
                                     CounterName:
                                         *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Delete a generic counter
**
** \par Description
**        This routine deletes a previously registered generic counter. 
**
** \par Assumptions, External Events, and Notes:
**        None.
**
** \param[in]  CounterId     The Counter Id of the newly created counter.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_ES_BAD_ARGUMENT      \retdesc \copydoc CFE_ES_BAD_ARGUMENT  \endcode
** \endreturns
**
** \sa #CFE_ES_IncrementGenCounter, #CFE_ES_RegisterGenCounter, #CFE_ES_SetGenCount, #CFE_ES_GetGenCount, #CFE_ES_GetGenCounterIDByName
**
******************************************************************************/
    pub fn CFE_ES_DeleteGenCounter(CounterId: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Increments the specified generic counter
**
** \par Description
**        This routine increments the specified generic counter. 
**
** \par Assumptions, External Events, and Notes:
**        None.
**
** \param[in]   CounterId    The Counter to be incremented.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_ES_BAD_ARGUMENT      \retdesc \copydoc CFE_ES_BAD_ARGUMENT  \endcode
** \endreturns
**
** \sa #CFE_ES_RegisterGenCounter, #CFE_ES_DeleteGenCounter, #CFE_ES_SetGenCount, #CFE_ES_GetGenCount, #CFE_ES_GetGenCounterIDByName
**
******************************************************************************/
    pub fn CFE_ES_IncrementGenCounter(CounterId: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Set the specified generic counter
**
** \par Description
**        This routine sets the specified generic counter to the specified value. 
**
** \par Assumptions, External Events, and Notes:
**        None.
**
** \param[in]   CounterId    The Counter to be set.
**
** \param[in]   Count        The new value of the Counter.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_ES_BAD_ARGUMENT      \retdesc \copydoc CFE_ES_BAD_ARGUMENT  \endcode
** \endreturns
**
** \sa #CFE_ES_RegisterGenCounter, #CFE_ES_DeleteGenCounter, #CFE_ES_IncrementGenCounter, #CFE_ES_GetGenCount, #CFE_ES_GetGenCounterIDByName
**
******************************************************************************/
    pub fn CFE_ES_SetGenCount(CounterId: uint32, Count: uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get the specified generic counter count
**
** \par Description
**        This routine gets the value of a generic counter. 
**
** \par Assumptions, External Events, and Notes:
**        None.
**
** \param[in]   CounterId    The Counter to get the value from.
**
** \param[in]   *Count     The value of the Counter.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_ES_BAD_ARGUMENT      \retdesc \copydoc CFE_ES_BAD_ARGUMENT  \endcode
** \endreturns
**
** \sa #CFE_ES_RegisterGenCounter, #CFE_ES_DeleteGenCounter, #CFE_ES_SetGenCount, #CFE_ES_IncrementGenCounter, #CFE_ES_GetGenCounterIDByName
**
******************************************************************************/
    pub fn CFE_ES_GetGenCount(CounterId: uint32, Count: *mut uint32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get the Id associated with a generic counter name
**
** \par Description
**        This routine gets the Counter Id for a generic counter specified by name.
**
** \par Assumptions, External Events, and Notes:
**        None.
**
** \param[in]   *CounterName     The name of the Counter.
**
** \param[out]  *CounterIdPtr    The Counter Id for the given name.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_ES_BAD_ARGUMENT      \retdesc \copydoc CFE_ES_BAD_ARGUMENT  \endcode
** \endreturns
**
** \sa #CFE_ES_RegisterGenCounter, #CFE_ES_DeleteGenCounter, #CFE_ES_SetGenCount, #CFE_ES_IncrementGenCounter, #CFE_ES_GetGenCount
******************************************************************************/
    pub fn CFE_ES_GetGenCounterIDByName(CounterIdPtr: *mut uint32,
                                        CounterName:
                                            *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Process an exception detected by the underlying OS/PSP
**
** \par Description
**        This hook routine is called from the PSP when an exception occurs
**
** \par Assumptions, External Events, and Notes:
**        None.
**
** \param[in]   HostTaskId       The OS (not OSAL) task ID
** \param[in]   ReasonString     Identifier from PSP
** \param[in]   ContextPointer   Context data from PSP
** \param[in]   ContextSize      Size of context data from PSP
**
******************************************************************************/
    pub fn CFE_ES_ProcessCoreException(HostTaskId: uint32,
                                       ReasonString:
                                           *const ::std::os::raw::c_char,
                                       ContextPointer: *const uint32,
                                       ContextSize: uint32);
}
/** 
**  \brief Data structure used to hold system time values
**
**  \par Description
**       The #CFE_TIME_SysTime_t data structure is used to hold time
**       values.  Time is referred to as the elapsed time (in seconds
**       and subseconds) since a specified epoch time.  The subseconds
**       field contains the number of 2^(-32) second intervals that have
**       elapsed since the epoch.
**
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_SysTime_t {
    /**< \brief Number of seconds since epoch */
    pub Seconds: uint32,
    /**< \brief Number of subseconds since epoch (LSB = 2^(-32) seconds) */
    pub Subseconds: uint32,
}
#[test]
fn bindgen_test_layout_CFE_TIME_SysTime_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_SysTime_t>() , 8usize , concat !
               ( "Size of: " , stringify ! ( CFE_TIME_SysTime_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_SysTime_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_TIME_SysTime_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_SysTime_t ) ) . Seconds as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_SysTime_t ) ,
                "::" , stringify ! ( Seconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_SysTime_t ) ) . Subseconds as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_SysTime_t ) ,
                "::" , stringify ! ( Subseconds ) ));
}
impl Clone for CFE_TIME_SysTime_t {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
/** 
**  \brief Enumerated types identifying the quality of the current time
**
**  \par Description
**       The #CFE_TIME_ClockState_t enumerations identify the three recognized states of the current time.
**       If the clock has never been successfully synchronized with the primary onboard clock source, the
**       time is conisdered to be #CFE_TIME_INVALID.  If the time is currently synchronized (i.e. - the
**       primary synchronization mechanism has not been dropped for any significant amount of time), then
**       the current time is considered to be #CFE_TIME_VALID.  If the time had, at some point in the past,
**       been synchronized, but the synchronization with the primary onboard clock has since been lost, then
**       the time is considered to be #CFE_TIME_FLYWHEEL.  Since different clocks drift at different rates
**       from one another, the accuracy of the time while in #CFE_TIME_FLYWHEEL is dependent upon the time
**       spent in that state.
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CFE_TIME_ClockState_t {
    CFE_TIME_INVALID = -1,
    CFE_TIME_VALID = 0,
    CFE_TIME_FLYWHEEL = 1,
}
#[repr(i32)]
/** 
**  \brief Enumerated types identifying the relative relationships of two times
**
**  \par Description
**       Since time fields contain numbers that are relative to an epoch time, then it is possible for a time value
**       to be "negative".  This can lead to some confusion about what relationship exists between two time values.
**       To resolve this confusion, the cFE provides the API #CFE_TIME_Compare which returns these enumerated values.
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CFE_TIME_Compare_t {
    CFE_TIME_A_LT_B = -1,
    CFE_TIME_EQUAL = 0,
    CFE_TIME_A_GT_B = 1,
}
/**
**  \brief Time related variables that are maintained through a Processor Reset
**
**  \par Description
**       The #CFE_TIME_ResetVars_t data structure contains those variables that are maintained
**       in an area of memory that is not cleared during a Processor Reset.  This allows the
**       cFE Time Service to maintain time to the best of its ability after a Processor Reset.
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_ResetVars_t {
    /**< \brief Data validation signature used to verify data structure contents*/
    pub Signature: uint32,
    /**< \brief Leap seconds value */
    pub LeapSeconds: int16,
    /**< \brief Current clock signal selection */
    pub ClockSignal: uint16,
    /**< \brief Current Mission Elapsed Time (MET) */
    pub CurrentMET: CFE_TIME_SysTime_t,
    /**< \brief Current Spacecraft Time Correlation Factor (STCF) */
    pub CurrentSTCF: CFE_TIME_SysTime_t,
    /**< \brief Current time client delay value */
    pub CurrentDelay: CFE_TIME_SysTime_t,
}
#[test]
fn bindgen_test_layout_CFE_TIME_ResetVars_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_ResetVars_t>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TIME_ResetVars_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_ResetVars_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_ResetVars_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ResetVars_t ) ) . Signature as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_ResetVars_t )
                , "::" , stringify ! ( Signature ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ResetVars_t ) ) . LeapSeconds as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_ResetVars_t )
                , "::" , stringify ! ( LeapSeconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ResetVars_t ) ) . ClockSignal as
                * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_ResetVars_t )
                , "::" , stringify ! ( ClockSignal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ResetVars_t ) ) . CurrentMET as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_ResetVars_t )
                , "::" , stringify ! ( CurrentMET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ResetVars_t ) ) . CurrentSTCF as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_ResetVars_t )
                , "::" , stringify ! ( CurrentSTCF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ResetVars_t ) ) . CurrentDelay
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_ResetVars_t )
                , "::" , stringify ! ( CurrentDelay ) ));
}
impl Clone for CFE_TIME_ResetVars_t {
    fn clone(&self) -> Self { *self }
}
/**
**   \brief Time Synchronization Callback Function Ptr Type
**
**   \par Description
**        Applications that wish to get direct notification of the receipt of the cFE Time Synchronization signal
**        (typically a 1 Hz signal), must register a callback function with the following prototype via the
**        #CFE_TIME_RegisterSynchCallback API.
*/
pub type CFE_TIME_SynchCallbackPtr_t =
    ::std::option::Option<unsafe extern "C" fn() -> int32>;
extern "C" {
    /*****************************************************************************/
/**
** \brief Get the current spacecraft time
**
** \par Description
**        This routine returns the current spacecraft time.  The time returned 
**        is either TAI (no leap seconds) or UTC (including leap seconds).  This choice
**        is made in the mission configuration file by defining either #CFE_TIME_CFG_DEFAULT_TAI
**        or #CFE_TIME_CFG_DEFAULT_UTC as TRUE at compile time.  To maintain re-usability 
**        across missions, most applications should be using this function 
**        (or #CFE_TIME_GetTime) rather than the specific routines for getting UTC/TAI directly.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retcode #CFE_TIME_SysTime_t  \retdesc  The current spacecraft time   \endcode
** \endreturns
**
** \sa #CFE_TIME_GetTAI, #CFE_TIME_GetUTC, #CFE_TIME_GetMET, 
**     #CFE_TIME_GetMETseconds, #CFE_TIME_GetMETsubsecs
**
******************************************************************************/
    pub fn CFE_TIME_GetTime() -> CFE_TIME_SysTime_t;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get the current TAI time
**
** \par Description
**        This routine returns the current TAI time to the caller.  TAI is an 
**        international time standard that does not include leap seconds.  
**        This routine should only be used in situations where TAI is absolutely 
**        required.  Applications that call #CFE_TIME_GetTAI() may not be portable 
**        to all missions.  Maintenance of correct TAI in flight is not guaranteed 
**        under all mission operations scenarios.  To maintain re-usability across 
**        missions, most applications should be using #CFE_TIME_GetTime(), rather 
**        than the specific routines for getting UTC/TAI directly.
**
** \par Assumptions, External Events, and Notes:
**          -# The "TAI" time returned is referenced to the mission-defined time epoch, 
**             which may or may not be the same as the standard TAI epoch.
**          -# Even though TAI does not include leap seconds, the time returned by this 
**             function can still jump forward or backward without warning when the 
**             spacecraft clock is set or adjusted by operators.  Applications using 
**             this function must be able to handle these time discontinuities gracefully.
**
** \returns
** \retcode #CFE_TIME_SysTime_t  \retdesc  The current TAI time   \endcode
** \endreturns
**
** \sa #CFE_TIME_GetTime, #CFE_TIME_GetUTC, #CFE_TIME_GetMET, 
**     #CFE_TIME_GetMETseconds, #CFE_TIME_GetMETsubsecs
**
******************************************************************************/
    pub fn CFE_TIME_GetTAI() -> CFE_TIME_SysTime_t;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get the current UTC time
**
** \par Description
**        This routine returns the current UTC time to the caller.  This routine 
**        should only be used in situations where UTC is absolutely required.  
**        Applications that call #CFE_TIME_GetUTC() may not be portable to all 
**        missions.  Maintenance of correct UTC in flight is not guaranteed under 
**        all mission operations scenarios.  If UTC is maintained in flight, it will 
**        jump backwards occasionally due to leap second adjustments.  To maintain 
**        re-usability across missions, most applications should be using 
**        #CFE_TIME_GetTime(), rather than the specific routines for getting 
**        UTC/TAI directly.
**
** \par Assumptions, External Events, and Notes:
**          Note: The "UTC" time returned is referenced to the mission-defined time epoch, 
**                which may or may not be the same as the standard UTC epoch.
**
** \returns
** \retcode #CFE_TIME_SysTime_t  \retdesc The current UTC time   \endcode            
** \endreturns
**
** \sa #CFE_TIME_GetTime, #CFE_TIME_GetTAI, #CFE_TIME_GetMET, 
**     #CFE_TIME_GetMETseconds, #CFE_TIME_GetMETsubsecs
**
******************************************************************************/
    pub fn CFE_TIME_GetUTC() -> CFE_TIME_SysTime_t;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Convert specified MET into Spacecraft Time
**
** \par Description
**        This function returns Spacecraft Time given MET.  Note that Spacecraft 
**        Time is returned as either UTC or TAI depeneding on whether the mission
**        configuration parameter #CFE_TIME_CFG_DEFAULT_UTC or #CFE_TIME_CFG_DEFAULT_TAI
**        was set to TRUE at compile time.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] METTime      The MET to be converted.
**
** \returns
** \retcode #CFE_TIME_SysTime_t  \retdesc  Spacecraft Time (UTC or TAI) corresponding to the specified MET   \endcode
** \endreturns
**
** \sa #CFE_TIME_GetMET, #CFE_TIME_GetMETseconds, #CFE_TIME_GetMETsubsecs,
**     #CFE_TIME_Sub2MicroSecs, #CFE_TIME_Micro2SubSecs, #CFE_TIME_CFE2FSSeconds, #CFE_TIME_FS2CFESeconds
**
******************************************************************************/
    pub fn CFE_TIME_MET2SCTime(METTime: CFE_TIME_SysTime_t)
     -> CFE_TIME_SysTime_t;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get the current value of the spacecraft time correction factor (STCF).
**
** \par Description
**        This routine returns the current value of the spacecraft time correction 
**        factor.  This is the delta time between the MET and the TAI time.  
**        Applications cannot set or adjust the STCF; that can only be done 
**        through ground commands.  However, science applications may want to 
**        include the STCF in their data products to aid in time correlation 
**        during downstream science data processing. 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retcode #CFE_TIME_SysTime_t  \retdesc  The current STCF    \endcode
** \endreturns
**
** \sa #CFE_TIME_GetLeapSeconds, #CFE_TIME_GetClockState, #CFE_TIME_GetClockInfo
**               
******************************************************************************/
    pub fn CFE_TIME_GetSTCF() -> CFE_TIME_SysTime_t;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get the current value of the Mission Elapsed Time (MET).
**
** \par Description
**        This routine returns the current mission-elapsed time (MET).  MET is 
**        usually derived from a hardware-based clock that is not adjusted 
**        during normal operations.  Callers of this routine should not assume 
**        that the MET return value has any specific relationship to any 
**        ground-based time standard. 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retcode #CFE_TIME_SysTime_t  \retdesc  The current MET    \endcode
** \endreturns
**
** \sa #CFE_TIME_GetTime, #CFE_TIME_GetTAI, #CFE_TIME_GetUTC, 
**     #CFE_TIME_GetMETseconds, #CFE_TIME_GetMETsubsecs, #CFE_TIME_MET2SCTime
**
******************************************************************************/
    pub fn CFE_TIME_GetMET() -> CFE_TIME_SysTime_t;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get the current seconds count of the mission-elapsed time.
**
** \par Description
**        This routine is the same as #CFE_TIME_GetMET(), except that it 
**        returns only the integer seconds portion of the MET time. 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retstmt The current MET seconds   \endstmt             
** \endreturns
**
** \sa #CFE_TIME_GetTime, #CFE_TIME_GetTAI, #CFE_TIME_GetUTC, #CFE_TIME_GetMET, 
**     #CFE_TIME_GetMETsubsecs, #CFE_TIME_MET2SCTime
**
******************************************************************************/
    pub fn CFE_TIME_GetMETseconds() -> uint32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get the current sub-seconds count of the mission-elapsed time.
**
** \par Description
**        This routine is the same as #CFE_TIME_GetMET(), except that it 
**        returns only the integer sub-seconds portion of the MET time.
**        Each count is equal to 2^(-32) seconds. 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retstmt The current MET sub-seconds  \endstmt              
** \endreturns
**
** \sa #CFE_TIME_GetTime, #CFE_TIME_GetTAI, #CFE_TIME_GetUTC, #CFE_TIME_GetMET, 
**     #CFE_TIME_GetMETseconds, #CFE_TIME_MET2SCTime
**
******************************************************************************/
    pub fn CFE_TIME_GetMETsubsecs() -> uint32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get the current value of the leap seconds counter.
**
** \par Description
**        This routine returns the current value of the leap seconds counter.  
**        This is the delta seconds between international atomic time (TAI) 
**        and universal coordinated time (UTC).  Applications cannot set or 
**        adjust the leap seconds; that can only be done through ground commands.  
**        However, science applications may want to include the leap seconds 
**        counter in their data products to aid in time correlation during 
**        downstream science data processing.  Note that some mission operations 
**        teams do not maintain the leap seconds count, preferring to adjust the 
**        STCF instead.  Users of this function should check with their mission 
**        ops team to see how they are planning to handle leap seconds. 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retstmt The current leap seconds.   \endstmt
** \endreturns
**
** \sa #CFE_TIME_GetSTCF, #CFE_TIME_GetClockState, #CFE_TIME_GetClockInfo
**               
******************************************************************************/
    pub fn CFE_TIME_GetLeapSeconds() -> int16;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Get the current state of the spacecraft clock.
**
** \par Description
**        This routine returns the spacecraft clock state.  Applications that 
**        are highly dependent on valid time may want to call this routine 
**        before taking actions based on the times returned by the various 
**        clock routines 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retcode #CFE_TIME_ClockState_t \retdesc The current spacecraft clock state    \endcode
** \endreturns
**
** \sa #CFE_TIME_GetSTCF, #CFE_TIME_GetLeapSeconds, #CFE_TIME_GetClockInfo
**               
******************************************************************************/
    pub fn CFE_TIME_GetClockState() -> CFE_TIME_ClockState_t;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Provides information about the spacecraft clock.
**
** \par Description
**        This routine returns information on the spacecraft clock in a bit mask. 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retstmt Spacecraft clock information.  To extract the information from the
**         returned value, the following masks can be used as in the following: <br>
**         <tt> if ((ReturnValue & CFE_TIME_FLAG_xxxxxx) == CFE_TIME_FLAG_xxxxxx)</tt> then 
**            the following definition of the \c CFE_TIME_FLAG_xxxxxx is true. <br>  \endstmt
** \retcode  #CFE_TIME_FLAG_CLKSET \retdesc \copydoc CFE_TIME_FLAG_CLKSET \endcode
** \retcode  #CFE_TIME_FLAG_FLYING \retdesc \copydoc CFE_TIME_FLAG_FLYING \endcode
** \retcode  #CFE_TIME_FLAG_SRCINT \retdesc \copydoc CFE_TIME_FLAG_SRCINT \endcode
** \retcode  #CFE_TIME_FLAG_SIGPRI \retdesc \copydoc CFE_TIME_FLAG_SIGPRI \endcode
** \retcode  #CFE_TIME_FLAG_SRVFLY \retdesc \copydoc CFE_TIME_FLAG_SRVFLY \endcode
** \retcode  #CFE_TIME_FLAG_CMDFLY \retdesc \copydoc CFE_TIME_FLAG_CMDFLY \endcode
** \retcode  #CFE_TIME_FLAG_ADDADJ \retdesc \copydoc CFE_TIME_FLAG_ADDADJ \endcode
** \retcode  #CFE_TIME_FLAG_ADD1HZ \retdesc \copydoc CFE_TIME_FLAG_ADD1HZ \endcode
** \retcode  #CFE_TIME_FLAG_ADDTCL \retdesc \copydoc CFE_TIME_FLAG_ADDTCL \endcode
** \retcode  #CFE_TIME_FLAG_SERVER \retdesc \copydoc CFE_TIME_FLAG_SERVER \endcode
** \retcode  #CFE_TIME_FLAG_GDTONE \retdesc \copydoc CFE_TIME_FLAG_GDTONE \endcode
** \retcode  #CFE_TIME_FLAG_UNUSED \retdesc \copydoc CFE_TIME_FLAG_UNUSED \endcode    
** \endreturns
**
** \sa #CFE_TIME_GetSTCF, #CFE_TIME_GetLeapSeconds, #CFE_TIME_GetClockState
**               
******************************************************************************/
    pub fn CFE_TIME_GetClockInfo() -> uint16;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Adds two time values
**
** \par Description
**        This routine adds the two specified times and returns the result.  
**        Normally, at least one of the input times should be a value representing 
**        a delta time.  Adding two absolute times together will not cause an error, 
**        but the result will probably be meaningless. 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] Time1   The first time to be added.
**
** \param[in] Time2   The second time to be added.
**
** \returns
** \retstmt The sum of the two times, in the #CFE_TIME_SysTime_t format described above.  
**         If the sum is greater than the maximum value that can be stored in a 
**         #CFE_TIME_SysTime_t, the result will roll over (this is not considered an error).  \endstmt
** \endreturns
**
** \sa #CFE_TIME_Subtract, #CFE_TIME_Compare
**                
******************************************************************************/
    pub fn CFE_TIME_Add(Time1: CFE_TIME_SysTime_t, Time2: CFE_TIME_SysTime_t)
     -> CFE_TIME_SysTime_t;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Subtracts two time values
**
** \par Description
**        This routine subtracts time2 from time1 and returns the result.  The 
**        time values can represent either absolute or delta times, but not all 
**        combinations make sense.
**           -  AbsTime - AbsTime = DeltaTime
**           -  AbsTime - DeltaTime = AbsTime
**           -  DeltaTime - DeltaTime = DeltaTime
**           -  DeltaTime - AbsTime = garbage
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] Time1   The base time.
**
** \param[in] Time2   The time to be subtracted from the base time.
**
** \returns
** \retstmt The result of subtracting the two times, in the #CFE_TIME_SysTime_t 
**         format.  If the subtraction results in an underflow, the result will 
**         roll over (this is not considered an error).    \endstmt            
** \endreturns
**
** \sa #CFE_TIME_Add, #CFE_TIME_Compare
**                
******************************************************************************/
    pub fn CFE_TIME_Subtract(Time1: CFE_TIME_SysTime_t,
                             Time2: CFE_TIME_SysTime_t) -> CFE_TIME_SysTime_t;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Compares two time values
**
** \par Description
**        This routine compares two time values to see which is "greater".  It 
**        is important that applications use this function rather than trying 
**        to directly compare the component pieces of times.  This function will 
**        handle roll-over cases seamlessly, which may not be intuitively obvious.
**        The cFE's internal representation of time "rolls over" when the 32 bit 
**        seconds count reaches 0xFFFFFFFF.  Also, subtracting a delta time from 
**        an absolute time close to the epoch could result in "roll under".  The 
**        strange cases that result from these situations can be handled by defining 
**        the comparison function for times as follows:
**        Plot the two times on the circumference of a circle where 0 is at the 
**        top and 0x80000000 is at the bottom.  If the shortest arc from time A 
**        to time B runs clockwise around the circle, then time A is less than 
**        time B.  If the shortest arc from A to B runs counter-clockwise, then 
**        time A is greater than time B.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] TimeA   The first time to compare.
**
** \param[in] TimeB   The second time to compare.
**
** \returns
** \retstmt The result of comparing the two times, one of: \endstmt
** \retcode #CFE_TIME_EQUAL  \retdesc \copydoc CFE_TIME_EQUAL  \endcode
** \retcode #CFE_TIME_A_GT_B \retdesc \copydoc CFE_TIME_A_GT_B \endcode
** \retcode #CFE_TIME_A_LT_B \retdesc \copydoc CFE_TIME_A_LT_B \endcode             
** \endreturns
**
** \sa #CFE_TIME_Add, #CFE_TIME_Subtract
**                
******************************************************************************/
    pub fn CFE_TIME_Compare(TimeA: CFE_TIME_SysTime_t,
                            TimeB: CFE_TIME_SysTime_t) -> CFE_TIME_Compare_t;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Converts a sub-seconds count to an equivalent number of microseconds
**
** \par Description
**        This routine converts from a sub-seconds count 
**        (each tick is 1 / 2^32 seconds) to microseconds (each tick is 1e-06 seconds).
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] SubSeconds   The sub-seconds count to convert.
**
** \returns
** \retstmt The equivalent number of microseconds.    \endstmt            
** \endreturns
**
** \sa #CFE_TIME_MET2SCTime, #CFE_TIME_Micro2SubSecs, 
**     #CFE_TIME_CFE2FSSeconds, #CFE_TIME_FS2CFESeconds
**
******************************************************************************/
    pub fn CFE_TIME_Sub2MicroSecs(SubSeconds: uint32) -> uint32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Converts a number of microseconds to an equivalent sub-seconds count.
**
** \par Description
**        This routine converts from microseconds (each tick is 1e-06 seconds) 
**        to a subseconds count (each tick is 1 / 2^32 seconds).
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] MicroSeconds   The sub-seconds count to convert.
**
** \returns
** \retstmt The equivalent number of subseconds.  If the number of microseconds 
**         passed in is greater than one second, (i.e. > 999,999), the return 
**         value is equal to \c 0xffffffff.     \endstmt           
** \endreturns
**
** \sa #CFE_TIME_MET2SCTime, #CFE_TIME_Sub2MicroSecs, 
**     #CFE_TIME_CFE2FSSeconds, #CFE_TIME_FS2CFESeconds
**
******************************************************************************/
    pub fn CFE_TIME_Micro2SubSecs(MicroSeconds: uint32) -> uint32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Converts cFE seconds into the File System's seconds
**
** \par Description
**        File systems use specific time epochs for their time tagging of files.
**        Since spacecraft systems rarely use an epoch that matches a particular
**        file system, this function provides a mechanism to translate a given
**        spacecraft time (in seconds) to the file system's time.  The conversion
**        is controlled by the configuration parameter #CFE_TIME_FS_FACTOR which
**        is set equal to the number of seconds between the spacecraft's epoch and
**        the file system's epoch.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] SecondsCFE   The spacecraft time, in seconds, to be converted.
**
** \returns
** \retstmt The equivalent time, in seconds, for the file system.    \endstmt            
** \endreturns
**
** \sa #CFE_TIME_MET2SCTime, #CFE_TIME_Sub2MicroSecs, #CFE_TIME_Micro2SubSecs, 
**     #CFE_TIME_FS2CFESeconds
**
******************************************************************************/
    pub fn CFE_TIME_CFE2FSSeconds(SecondsCFE: uint32) -> uint32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Converts a file system's seconds into cFE seconds
**
** \par Description
**        File systems use specific time epochs for their time tagging of files.
**        Since spacecraft systems rarely use an epoch that matches a particular
**        file system, this function provides a mechanism to translate a file
**        system time (in seconds) into the spacecraft time (in seconds).  The 
**        conversion is controlled by the configuration parameter #CFE_TIME_FS_FACTOR 
**        which is set equal to the number of seconds between the spacecraft's epoch and
**        the file system's epoch.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] SecondsFS   The file system time, in seconds, to be converted.
**
** \returns
** \retstmt The equivalent time, in seconds, for the spacecraft.    \endstmt
** \endreturns
**
** \sa #CFE_TIME_MET2SCTime, #CFE_TIME_Sub2MicroSecs, #CFE_TIME_Micro2SubSecs, 
**     #CFE_TIME_CFE2FSSeconds
**
******************************************************************************/
    pub fn CFE_TIME_FS2CFESeconds(SecondsFS: uint32) -> uint32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Print a time value as a string
**
** \par Description
**        This routine prints the specified time to the specified string buffer 
**        in the following format: <br> <br>
**           \c yyyy-ddd-hh:mm:ss.xxxxx\\0 <br> <br>
**        where:
**           - \c yyyy = year
**           - \c ddd = Julian day of the year
**           - \c hh = hour of the day (0 to 23)
**           - \c mm = minute (0 to 59)
**           - \c ss = second (0 to 59)
**           - \c xxxxx = subsecond formatted as a decimal fraction (1/4 second = 0.25000)
**           - \c \\0 = trailing null
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  PrintBuffer   Pointer to a character array of at least 
**                           #CFE_TIME_PRINTED_STRING_SIZE characters in length
**
** \param[in]  TimeToPrint   The time to print into the character array.
**
** \param[out] *PrintBuffer  The time as a character string as described above.
**
** \sa
**                
******************************************************************************/
    pub fn CFE_TIME_Print(PrintBuffer: *mut ::std::os::raw::c_char,
                          TimeToPrint: CFE_TIME_SysTime_t);
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Provides the 1 Hz signal from an external source
**
** \par Description
**        This routine provides a method for cFE TIME software to be notified 
**        of the occurance of the 1Hz tone signal without knowledge of the 
**        specific hardware design.  Regardless of the source of the tone, 
**        this routine should be called as soon as possible after detection 
**        to allow cFE TIME software the opportunity to latch the local clock 
**        as close as possible to the instant of the tone.
**
** \par Assumptions, External Events, and Notes:
**          - This routine may be called directly from within the context of an
**            interrupt handler.
**
** \sa #CFE_TIME_ExternalMET, #CFE_TIME_ExternalGPS, #CFE_TIME_ExternalTime
**                
******************************************************************************/
    pub fn CFE_TIME_ExternalTone();
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Provides the Mission Elapsed Time from an external source
**
** \par Description
**        This routine provides a method to provide cFE TIME with MET acquired 
**        from an external source.  There is a presumption that this function 
**        will be called at the appropriate time (relative to the tone) such 
**        that this call may be used by cFE TIME as the signal to generate the 
**        "time at the tone" data command.  The "time at the tone" data command 
**        must arrive within the configuration parameter specified window for 
**        tone signal and data packet verification. <br> <br>
**        The MET value at the tone "should" have zero subseconds.  Although the 
**        interface accepts non-zero values for sub-seconds, it may be harmful 
**        to other applications that expect zero subseconds at the moment of the 
**        tone.  Any decision to use non-zero subseconds should be carefully considered.
**
** \par Assumptions, External Events, and Notes:
**          - This routine is included in the API only when 3 specific configuration 
**            parameters are set to TRUE.  The first is #CFE_TIME_CFG_SERVER which defines 
**            this instantiation of cFE TIME as a time server (not a client).  The 
**            second required configuration parameter is #CFE_TIME_CFG_SOURCE which 
**            enables time source selection commands to the cFE TIME task, and further 
**            enables configuration definitions for the selected type of external time 
**            data.  The third configuration parameter required for this routine is 
**            #CFE_TIME_CFG_SRC_MET, which indicates that the external time data consists 
**            of MET.
**
** \param[in]  NewMET   The MET value at the next (or previous) 1 Hz tone signal.
**
** \sa #CFE_TIME_ExternalTone, #CFE_TIME_ExternalGPS, #CFE_TIME_ExternalTime
**                
******************************************************************************/
    pub fn CFE_TIME_ExternalMET(NewMET: CFE_TIME_SysTime_t);
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Provide the time from an external source that has data common to GPS receivers.
**
** \par Description
**        This routine provides a method to provide cFE TIME with current time 
**        data acquired from an external source.  There is a presumption that 
**        this function will be called at the appropriate time (relative to the 
**        tone) such that this call may be used by cFE TIME as the signal to 
**        generate the "time at the tone" data command.  The "time at the tone" 
**        data command must arrive within the configuration parameter specified 
**        window for tone signal and data packet verification. <br> <br>
**        Internally, cFE TIME will calculate a new STCF as the difference between 
**        this new time value and the spacecraft MET value at the tone.  This allows 
**        cFE TIME to always calculate time as the sum of MET and STCF.  The value 
**        of STCF will change only as much as the drift factor between spacecraft 
**        MET and the external time source.
**
** \par Assumptions, External Events, and Notes:
**          - This routine is included in the API only when 3 specific configuration 
**            parameters are set to TRUE.  The first is #CFE_TIME_CFG_SERVER which defines this 
**            instantiation of cFE TIME as a time server (not a client).  The second 
**            required configuration parameter is #CFE_TIME_CFG_SOURCE which enables 
**            time source selection commands to the cFE TIME task, and further enables 
**            configuration definitions for the selected type of external time data.  
**            The third configuration parameter required for this routine is 
**            #CFE_TIME_CFG_SRC_GPS, which indicates that the external time data consists 
**            of a time value relative to a known epoch, plus a leap seconds value.
**
** \param[in]  NewTime   The MET value at the next (or previous) 1 Hz tone signal.
**
** \param[in]  NewLeaps The Leap Seconds value used to calculate time as UTC.
**
** \sa #CFE_TIME_ExternalTone, #CFE_TIME_ExternalMET, #CFE_TIME_ExternalTime
**                
******************************************************************************/
    pub fn CFE_TIME_ExternalGPS(NewTime: CFE_TIME_SysTime_t, NewLeaps: int16);
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Provide the time from an external source that measures time relative to a known epoch.
**
** \par Description
**        This routine provides a method to provide cFE TIME with current time 
**        data acquired from an external source.  There is a presumption that 
**        this function will be called at the appropriate time (relative to the 
**        tone) such that this call may be used by cFE TIME as the signal to 
**        generate the "time at the tone" data command.  The "time at the tone" 
**        data command must arrive within the configuration specified window for 
**        tone signal and data packet verification. <br> <br>
**        Internally, cFE TIME will calculate a new STCF as the difference between 
**        this new time value and the spacecraft MET value at the tone.  This allows 
**        cFE TIME to always calculate time as the sum of MET and STCF.  The value 
**        of STCF will change only as much as the drift factor between spacecraft 
**        MET and the external time source.
**
** \par Assumptions, External Events, and Notes:
**          - This routine is included in the API only when 3 specific configuration 
**            parameters are set to TRUE.  The first is #CFE_TIME_CFG_SERVER which defines this 
**            instanciation of cFE TIME as a time server (not a client).  The second 
**            required configuration parameter is #CFE_TIME_CFG_SOURCE which enables 
**            time source selection commands to the cFE TIME task, and further enables 
**            configuration definitions for the selected type of external time data.  
**            The third configuration parameter required for this routine is 
**            #CFE_TIME_CFG_SRC_TIME, which indicates that the external time data consists 
**            of a time value relative to a known epoch.
**
** \param[in]  NewTime   The MET value at the next (or previous) 1 Hz tone signal.
**
** \sa #CFE_TIME_ExternalTone, #CFE_TIME_ExternalMET, #CFE_TIME_ExternalGPS
**                
******************************************************************************/
    pub fn CFE_TIME_ExternalTime(NewTime: CFE_TIME_SysTime_t);
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Registers a callback function that is called whenever time synchronization occurs
**
** \par Description
**        This routine passes a callback function pointer for an Application that wishes to
**        be notified whenever a legitimate time synchronization signal (typically a 1 Hz)
**        is received.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retcode #CFE_SUCCESS  \retdesc \copydoc CFE_SUCCESS  \endcode
** \retcode #CFE_TIME_TOO_MANY_SYNCH_CALLBACKS \retdesc \copydoc CFE_TIME_TOO_MANY_SYNCH_CALLBACKS \endcode
** \retcode #CFE_ES_ERR_APPID  \retdesc \copydoc CFE_ES_ERR_APPID   \endcode
** \endreturns
**
** \sa #CFE_TIME_UnregisterSynchCallback
**
******************************************************************************/
    pub fn CFE_TIME_RegisterSynchCallback(CallbackFuncPtr:
                                              CFE_TIME_SynchCallbackPtr_t)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Unregisters a callback function that is called whenever time synchronization occurs
**
** \par Description
**        This routine removes the specified callback function pointer from the list
**        of Callback functions that are called whenever a time synchronization (typically
**        the 1Hz signal) is received.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retcode #CFE_SUCCESS  \retdesc \copydoc CFE_SUCCESS  \endcode
** \retcode #CFE_TIME_CALLBACK_NOT_REGISTERED \retdesc \copydoc CFE_TIME_CALLBACK_NOT_REGISTERED \endcode
** \retcode #CFE_ES_ERR_APPID  \retdesc \copydoc CFE_ES_ERR_APPID   \endcode
** \endreturns
**
** \sa #CFE_TIME_RegisterSynchCallback
**
******************************************************************************/
    pub fn CFE_TIME_UnregisterSynchCallback(CallbackFuncPtr:
                                                CFE_TIME_SynchCallbackPtr_t)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief This function should be called from the system PSP layer once per second
**
** \par Description
**        Drives the time processing logic from the system PSP layer.  This must be called
**        once per second based on a hardware interrupt or OS kernel signal.
**
** \par Assumptions, External Events, and Notes:
**        This will update the global data structures accordingly, incrementing each
**        by the 1Hz amount.
**
**
******************************************************************************/
    pub fn CFE_TIME_Local1HzISR();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_PSP_ExceptionContext_t {
    pub regs: [uint32; 32usize],
}
#[test]
fn bindgen_test_layout_CFE_PSP_ExceptionContext_t() {
    assert_eq!(::std::mem::size_of::<CFE_PSP_ExceptionContext_t>() , 128usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_PSP_ExceptionContext_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_PSP_ExceptionContext_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_PSP_ExceptionContext_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_PSP_ExceptionContext_t ) ) . regs as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_PSP_ExceptionContext_t ) , "::" , stringify ! ( regs ) ));
}
impl Clone for CFE_PSP_ExceptionContext_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_PSP_MemTable_t {
    pub MemoryType: uint32,
    pub WordSize: uint32,
    pub StartAddr: cpuaddr,
    pub Size: uint32,
    pub Attributes: uint32,
}
#[test]
fn bindgen_test_layout_CFE_PSP_MemTable_t() {
    assert_eq!(::std::mem::size_of::<CFE_PSP_MemTable_t>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( CFE_PSP_MemTable_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_PSP_MemTable_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_PSP_MemTable_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_PSP_MemTable_t ) ) . MemoryType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_PSP_MemTable_t ) ,
                "::" , stringify ! ( MemoryType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_PSP_MemTable_t ) ) . WordSize as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_PSP_MemTable_t ) ,
                "::" , stringify ! ( WordSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_PSP_MemTable_t ) ) . StartAddr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_PSP_MemTable_t ) ,
                "::" , stringify ! ( StartAddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_PSP_MemTable_t ) ) . Size as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_PSP_MemTable_t ) ,
                "::" , stringify ! ( Size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_PSP_MemTable_t ) ) . Attributes as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_PSP_MemTable_t ) ,
                "::" , stringify ! ( Attributes ) ));
}
impl Clone for CFE_PSP_MemTable_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn CFE_PSP_Main(ModeId: uint32,
                        StartupFilePath: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn CFE_PSP_GetTime(LocalTime: *mut OS_time_t);
}
extern "C" {
    pub fn CFE_PSP_Restart(resetType: uint32);
}
extern "C" {
    pub fn CFE_PSP_GetRestartType(restartSubType: *mut uint32) -> uint32;
}
extern "C" {
    pub fn CFE_PSP_FlushCaches(type_: uint32, address: cpuaddr, size: uint32);
}
extern "C" {
    pub fn CFE_PSP_GetProcessorId() -> uint32;
}
extern "C" {
    pub fn CFE_PSP_GetSpacecraftId() -> uint32;
}
extern "C" {
    pub fn CFE_PSP_Get_Timer_Tick() -> uint32;
}
extern "C" {
    pub fn CFE_PSP_GetTimerTicksPerSecond() -> uint32;
}
extern "C" {
    pub fn CFE_PSP_GetTimerLow32Rollover() -> uint32;
}
extern "C" {
    pub fn CFE_PSP_Get_Timebase(Tbu: *mut uint32, Tbl: *mut uint32);
}
extern "C" {
    pub fn CFE_PSP_Get_Dec() -> uint32;
}
extern "C" {
    pub fn CFE_PSP_InitProcessorReservedMemory(RestartType: uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_GetCDSSize(SizeOfCDS: *mut uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_WriteToCDS(PtrToDataToWrite: *mut ::std::os::raw::c_void,
                              CDSOffset: uint32, NumBytes: uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_ReadFromCDS(PtrToDataToRead: *mut ::std::os::raw::c_void,
                               CDSOffset: uint32, NumBytes: uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_GetResetArea(PtrToResetArea: *mut cpuaddr,
                                SizeOfResetArea: *mut uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_GetUserReservedArea(PtrToUserArea: *mut cpuaddr,
                                       SizeOfUserArea: *mut uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_GetVolatileDiskMem(PtrToVolDisk: *mut cpuaddr,
                                      SizeOfVolDisk: *mut uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_GetKernelTextSegmentInfo(PtrToKernelSegment: *mut cpuaddr,
                                            SizeOfKernelSegment: *mut uint32)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_GetCFETextSegmentInfo(PtrToCFESegment: *mut cpuaddr,
                                         SizeOfCFESegment: *mut uint32)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_WatchdogInit();
}
extern "C" {
    pub fn CFE_PSP_WatchdogEnable();
}
extern "C" {
    pub fn CFE_PSP_WatchdogDisable();
}
extern "C" {
    pub fn CFE_PSP_WatchdogService();
}
extern "C" {
    pub fn CFE_PSP_WatchdogGet() -> uint32;
}
extern "C" {
    pub fn CFE_PSP_WatchdogSet(WatchdogValue: uint32);
}
extern "C" {
    pub fn CFE_PSP_Panic(ErrorCode: int32);
}
extern "C" {
    pub fn CFE_PSP_InitSSR(bus: uint32, device: uint32,
                           DeviceName: *mut ::std::os::raw::c_char) -> int32;
}
extern "C" {
    pub fn CFE_PSP_Decompress(srcFileName: *mut ::std::os::raw::c_char,
                              dstFileName: *mut ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_AttachExceptions();
}
extern "C" {
    pub fn CFE_PSP_SetDefaultExceptionEnvironment();
}
extern "C" {
    pub fn CFE_PSP_PortRead8(PortAddress: cpuaddr, ByteValue: *mut uint8)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_PortWrite8(PortAddress: cpuaddr, ByteValue: uint8)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_PortRead16(PortAddress: cpuaddr, uint16Value: *mut uint16)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_PortWrite16(PortAddress: cpuaddr, uint16Value: uint16)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_PortRead32(PortAddress: cpuaddr, uint32Value: *mut uint32)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_PortWrite32(PortAddress: cpuaddr, uint32Value: uint32)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_MemRead8(MemoryAddress: cpuaddr, ByteValue: *mut uint8)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_MemWrite8(MemoryAddress: cpuaddr, ByteValue: uint8)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_MemRead16(MemoryAddress: cpuaddr, uint16Value: *mut uint16)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_MemWrite16(MemoryAddress: cpuaddr, uint16Value: uint16)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_MemRead32(MemoryAddress: cpuaddr, uint32Value: *mut uint32)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_MemWrite32(MemoryAddress: cpuaddr, uint32Value: uint32)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_MemCpy(dest: *mut ::std::os::raw::c_void,
                          src: *mut ::std::os::raw::c_void, n: uint32)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_MemSet(dest: *mut ::std::os::raw::c_void, value: uint8,
                          n: uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_MemValidateRange(Address: cpuaddr, Size: uint32,
                                    MemoryType: uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_MemRanges() -> uint32;
}
extern "C" {
    pub fn CFE_PSP_MemRangeSet(RangeNum: uint32, MemoryType: uint32,
                               StartAddr: cpuaddr, Size: uint32,
                               WordSize: uint32, Attributes: uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_MemRangeGet(RangeNum: uint32, MemoryType: *mut uint32,
                               StartAddr: *mut cpuaddr, Size: *mut uint32,
                               WordSize: *mut uint32, Attributes: *mut uint32)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_EepromWrite8(MemoryAddress: cpuaddr, ByteValue: uint8)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_EepromWrite16(MemoryAddress: cpuaddr, uint16Value: uint16)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_EepromWrite32(MemoryAddress: cpuaddr, uint32Value: uint32)
     -> int32;
}
extern "C" {
    pub fn CFE_PSP_EepromWriteEnable(Bank: uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_EepromWriteDisable(Bank: uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_EepromPowerUp(Bank: uint32) -> int32;
}
extern "C" {
    pub fn CFE_PSP_EepromPowerDown(Bank: uint32) -> int32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_Msg_t {
    /**< \brief CCSDS Primary Header #CCSDS_PriHdr_t */
    pub Hdr: __BindgenUnionField<CCSDS_PriHdr_t>,
    /**< \brief Forces minimum of 32-bit alignment for this object */
    pub Dword: __BindgenUnionField<uint32>,
    /**< \brief Allows byte-level access */
    pub Byte: __BindgenUnionField<[uint8; 6usize]>,
    pub bindgen_union_field: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_CFE_SB_Msg_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_Msg_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( CFE_SB_Msg_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_Msg_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CFE_SB_Msg_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_Msg_t ) ) . Hdr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_Msg_t ) , "::" ,
                stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_Msg_t ) ) . Dword as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_Msg_t ) , "::" ,
                stringify ! ( Dword ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_Msg_t ) ) . Byte as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_Msg_t ) , "::" ,
                stringify ! ( Byte ) ));
}
impl Clone for CFE_SB_Msg_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_CmdHdr_t {
    /**< \brief CCSDS Primary Header #CCSDS_PriHdr_t */
    pub Pri: CCSDS_PriHdr_t,
    /**< \brief CCSDS Command Secondary Header #CCSDS_CmdSecHdr_t */
    pub Sec: CCSDS_CmdSecHdr_t,
}
#[test]
fn bindgen_test_layout_CFE_SB_CmdHdr_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_CmdHdr_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( CFE_SB_CmdHdr_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_CmdHdr_t>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( CFE_SB_CmdHdr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_CmdHdr_t ) ) . Pri as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_CmdHdr_t ) ,
                "::" , stringify ! ( Pri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_CmdHdr_t ) ) . Sec as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_CmdHdr_t ) ,
                "::" , stringify ! ( Sec ) ));
}
impl Clone for CFE_SB_CmdHdr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_TlmHdr_t {
    /**< \brief CCSDS Primary Header #CCSDS_PriHdr_t */
    pub Pri: CCSDS_PriHdr_t,
    /**< \brief CCSDS Telemetry Secondary Header #CCSDS_TlmSecHdr_t */
    pub Sec: CCSDS_TlmSecHdr_t,
}
#[test]
fn bindgen_test_layout_CFE_SB_TlmHdr_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_TlmHdr_t>() , 12usize , concat ! (
               "Size of: " , stringify ! ( CFE_SB_TlmHdr_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_TlmHdr_t>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( CFE_SB_TlmHdr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_TlmHdr_t ) ) . Pri as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_TlmHdr_t ) ,
                "::" , stringify ! ( Pri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_TlmHdr_t ) ) . Sec as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_TlmHdr_t ) ,
                "::" , stringify ! ( Sec ) ));
}
impl Clone for CFE_SB_TlmHdr_t {
    fn clone(&self) -> Self { *self }
}
pub type CFE_SB_TimeOut_t = uint32;
pub type CFE_SB_PipeId_t = uint8;
pub type CFE_SB_MsgId_t = uint16;
pub type CFE_SB_MsgPtr_t = *mut CFE_SB_Msg_t;
pub type CFE_SB_MsgPayloadPtr_t = *mut uint8;
pub type CFE_SB_ZeroCopyHandle_t = cpuaddr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_Qos_t {
    /**< \brief  Specify high(1) or low(0) message priority for off-board routing, currently unused */
    pub Priority: uint8,
    /**< \brief  Specify high(1) or low(0) message transfer reliability for off-board routing, currently unused */
    pub Reliability: uint8,
}
#[test]
fn bindgen_test_layout_CFE_SB_Qos_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_Qos_t>() , 2usize , concat ! (
               "Size of: " , stringify ! ( CFE_SB_Qos_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_Qos_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_SB_Qos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_Qos_t ) ) . Priority as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_Qos_t ) , "::" ,
                stringify ! ( Priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_Qos_t ) ) . Reliability as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_Qos_t ) , "::" ,
                stringify ! ( Reliability ) ));
}
impl Clone for CFE_SB_Qos_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "CFE_SB_Default_Qos"]
    pub static mut CFE_SB_Default_Qos: CFE_SB_Qos_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_SenderId_t {
    /**< \brief Processor Id from which the message was sent */
    pub ProcessorId: uint32,
    /**< \brief Application that sent the message */
    pub AppName: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout_CFE_SB_SenderId_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_SenderId_t>() , 24usize , concat !
               ( "Size of: " , stringify ! ( CFE_SB_SenderId_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_SenderId_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_SB_SenderId_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_SenderId_t ) ) . ProcessorId as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_SenderId_t ) ,
                "::" , stringify ! ( ProcessorId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_SenderId_t ) ) . AppName as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_SenderId_t ) ,
                "::" , stringify ! ( AppName ) ));
}
impl Clone for CFE_SB_SenderId_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Creates a new software bus pipe.
**
** \par Description
**          This routine creates and initializes an input pipe that the calling 
**          application can use to receive software bus messages.  By default, no 
**          messages are routed to the new pipe.  So, the application must use 
**          #CFE_SB_Subscribe() to specify which messages it wants to receive on 
**          this pipe.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  PipeIdPtr    A pointer to a variable of type #CFE_SB_PipeId_t, 
**                          which will be filled in with the pipe ID information 
**                          by the #CFE_SB_CreatePipe routine. 
**
** \param[in]  Depth        The maximum number of messages that will be allowed on 
**                          this pipe at one time. 
**
** \param[in]  PipeName     A string to be used to identify this pipe in error messages 
**                          and routing information telemetry.  The string must be no 
**                          longer than #OS_MAX_API_NAME.  Longer strings will be truncated. 
**
** \param[out] *PipeIdPtr   The identifier for the created pipe. 
**
** \returns
** \retcode #CFE_SUCCESS           \retdesc \copydoc CFE_SUCCESS          \endcode
** \retcode #CFE_SB_BAD_ARGUMENT   \retdesc \copydoc CFE_SB_BAD_ARGUMENT  \endcode
** \retcode #CFE_SB_MAX_PIPES_MET  \retdesc \copydoc CFE_SB_MAX_PIPES_MET \endcode
** \retcode #CFE_SB_PIPE_CR_ERR    \retdesc \copydoc CFE_SB_PIPE_CR_ERR   \endcode
** \endreturns
**
** \sa #CFE_SB_DeletePipe
**/
    pub fn CFE_SB_CreatePipe(PipeIdPtr: *mut CFE_SB_PipeId_t, Depth: uint16,
                             PipeName: *const ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Delete a software bus pipe.
**
** \par Description
**          This routine deletes an input pipe and cleans up all data structures 
**          associated with the pipe.  All subscriptions made for this pipe by 
**          calls to #CFE_SB_Subscribe will be automatically removed from the 
**          SB routing tables.  Any messages in the pipe will be discarded.  
**          Applications must call this routine for all of their SB pipes as part 
**          of their orderly shutdown process.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  PipeId       The pipe ID (obtained previously from #CFE_SB_CreatePipe)
**                          of the pipe to be deleted. 
**
** \returns
** \retcode #CFE_SUCCESS           \retdesc  \copydoc CFE_SUCCESS         \endcode
** \retcode #CFE_SB_BAD_ARGUMENT   \retdesc  \copydoc CFE_SB_BAD_ARGUMENT \endcode
** \endreturns
**
** \sa #CFE_SB_CreatePipe
**/
    pub fn CFE_SB_DeletePipe(PipeId: CFE_SB_PipeId_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Subscribe to a message on the software bus
**
** \par Description
**          This routine adds the specified pipe to the destination list associated
**          with the specified message ID.
**
** \par Assumptions, External Events, and Notes:
**          Note:   As subscriptions are received, the destinations are added to
**          the head of a linked list. During the sending of a message, the list
**          is traversed beginning at the head of the list. Therefore the
**          message will first be sent to the last subscriber. If an application
**          has timing constraints and needs to receive a message in the
**          shortest possible time, the developer may consider holding off its
**          subscription until other applications have subscribed to the message.
**
** \param[in]  MsgId        The message ID of the message to be subscribed to. 
**
** \param[in]  PipeId       The pipe ID of the pipe the subscribed message 
**                          should be sent to. 
**
** \param[in]  Quality      The requested Quality of Service (QoS) required of 
**                          the messages. Most callers will use #CFE_SB_Default_Qos
**                          for this parameter.
**
** \param[in]  MsgLim       The maximum number of messages with this Message ID to
**                          allow in this pipe at the same time. 
**
** \returns
** \retcode #CFE_SUCCESS            \retdesc  \copydoc CFE_SUCCESS           \endcode
** \retcode #CFE_SB_MAX_MSGS_MET    \retdesc  \copydoc CFE_SB_MAX_MSGS_MET   \endcode
** \retcode #CFE_SB_MAX_DESTS_MET   \retdesc  \copydoc CFE_SB_MAX_DESTS_MET  \endcode
** \retcode #CFE_SB_BAD_ARGUMENT    \retdesc  \copydoc CFE_SB_BAD_ARGUMENT   \endcode
** \retcode #CFE_SB_BUF_ALOC_ERR    \retdesc  \copydoc CFE_SB_BUF_ALOC_ERR   \endcode
** \endreturns
**
** \sa #CFE_SB_Subscribe, #CFE_SB_SubscribeLocal, #CFE_SB_Unsubscribe, #CFE_SB_UnsubscribeLocal
**/
    pub fn CFE_SB_SubscribeEx(MsgId: CFE_SB_MsgId_t, PipeId: CFE_SB_PipeId_t,
                              Quality: CFE_SB_Qos_t, MsgLim: uint16) -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Subscribe to a message on the software bus with default parameters
**
** \par Description
**          This routine adds the specified pipe to the destination list for 
**          the specified message ID.  This is the same as #CFE_SB_SubscribeEx 
**          with the Quality field set to #CFE_SB_Default_Qos and MsgLim set 
**          to #CFE_SB_DEFAULT_MSG_LIMIT (4).
**
** \par Assumptions, External Events, and Notes:
**          Note:   As subscriptions are received, the destinations are added to
**          the head of a linked list. During the sending of a message, the list
**          is traversed beginning at the head of the list. Therefore the
**          message will first be sent to the last subscriber. If an application
**          has timing constraints and needs to receive a message in the
**          shortest possible time, the developer may consider holding off its
**          subscription until other applications have subscribed to the message.
**
** \param[in]  MsgId        The message ID of the message to be subscribed to. 
**
** \param[in]  PipeId       The pipe ID of the pipe the subscribed message 
**                          should be sent to. 
**
** \returns
** \retcode #CFE_SUCCESS            \retdesc  \copydoc CFE_SUCCESS           \endcode
** \retcode #CFE_SB_MAX_MSGS_MET    \retdesc  \copydoc CFE_SB_MAX_MSGS_MET   \endcode
** \retcode #CFE_SB_MAX_DESTS_MET   \retdesc  \copydoc CFE_SB_MAX_DESTS_MET  \endcode
** \retcode #CFE_SB_BAD_ARGUMENT    \retdesc  \copydoc CFE_SB_BAD_ARGUMENT   \endcode
** \retcode #CFE_SB_BUF_ALOC_ERR    \retdesc  \copydoc CFE_SB_BUF_ALOC_ERR   \endcode
** \endreturns
**
** \sa #CFE_SB_SubscribeEx, #CFE_SB_SubscribeLocal, #CFE_SB_Unsubscribe, #CFE_SB_UnsubscribeLocal
**/
    pub fn CFE_SB_Subscribe(MsgId: CFE_SB_MsgId_t, PipeId: CFE_SB_PipeId_t)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Subscribe to a message while keeping the request local to a cpu
**
** \par Description
**          This routine adds the specified pipe to the destination list for 
**          the specified message ID.  This is similar to #CFE_SB_SubscribeEx 
**          with the Quality field set to #CFE_SB_Default_Qos and MsgLim set 
**          to #CFE_SB_DEFAULT_MSG_LIMIT, but will not report the subscription.
**          Subscription Reporting is enabled for interprocessor communication
**          by way of the Software Bus Network (SBN) Application. 
**
** \par Assumptions, External Events, and Notes:
**          - This API is typically only used by Software Bus Network (SBN) Application
**
** \param[in]  MsgId        The message ID of the message to be subscribed to. 
**
** \param[in]  PipeId       The pipe ID of the pipe the subscribed message 
**                          should be sent to. 
**
** \param[in]  MsgLim       The maximum number of messages with this Message ID to
**                          allow in this pipe at the same time. 
**
** \returns
** \retcode #CFE_SUCCESS            \retdesc  \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_SB_MAX_MSGS_MET    \retdesc  \copydoc CFE_SB_MAX_MSGS_MET    \endcode
** \retcode #CFE_SB_MAX_DESTS_MET   \retdesc  \copydoc CFE_SB_MAX_DESTS_MET   \endcode
** \retcode #CFE_SB_BAD_ARGUMENT    \retdesc  \copydoc CFE_SB_BAD_ARGUMENT    \endcode
** \retcode #CFE_SB_BUF_ALOC_ERR    \retdesc  \copydoc CFE_SB_BUF_ALOC_ERR   \endcode
** \endreturns
**
** \sa #CFE_SB_Subscribe, #CFE_SB_SubscribeEx, #CFE_SB_Unsubscribe, #CFE_SB_UnsubscribeLocal
**/
    pub fn CFE_SB_SubscribeLocal(MsgId: CFE_SB_MsgId_t,
                                 PipeId: CFE_SB_PipeId_t, MsgLim: uint16)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Remove a subscription to a message on the software bus
**
** \par Description
**          This routine removes the specified pipe from the destination 
**          list for the specified message ID.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  MsgId        The message ID of the message to be unsubscribed. 
**
** \param[in]  PipeId       The pipe ID of the pipe the subscribed message 
**                          should no longer be sent to. 
**
** \returns
** \retcode #CFE_SUCCESS            \retdesc  \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_SB_NO_SUBSCRIBERS  \retdesc  \copydoc CFE_SB_NO_SUBSCRIBERS  \endcode
** \retcode #CFE_SB_INTERNAL_ERR    \retdesc  \copydoc CFE_SB_INTERNAL_ERR    \endcode
** \endreturns
**
** \sa #CFE_SB_Subscribe, #CFE_SB_SubscribeEx, #CFE_SB_SubscribeLocal, #CFE_SB_UnsubscribeLocal
**/
    pub fn CFE_SB_Unsubscribe(MsgId: CFE_SB_MsgId_t, PipeId: CFE_SB_PipeId_t)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Remove a subscription to a message on the software bus on the current CPU
**
** \par Description
**          This routine removes the specified pipe from the destination 
**          list for the specified message ID on the current CPU.
**
** \par Assumptions, External Events, and Notes:
**          - This API is typically only used by Software Bus Network (SBN) Application
**
** \param[in]  MsgId        The message ID of the message to be unsubscribed. 
**
** \param[in]  PipeId       The pipe ID of the pipe the subscribed message 
**                          should no longer be sent to. 
**
** \returns
** \retcode #CFE_SUCCESS             \retdesc \copydoc CFE_SUCCESS             \endcode
** \retcode #CFE_SB_NO_SUBSCRIBERS   \retdesc \copydoc CFE_SB_NO_SUBSCRIBERS   \endcode
** \retcode #CFE_SB_INTERNAL_ERR     \retdesc \copydoc CFE_SB_INTERNAL_ERR     \endcode
** \endreturns
**
** \sa #CFE_SB_Subscribe, #CFE_SB_SubscribeEx, #CFE_SB_SubscribeLocal, #CFE_SB_Unsubscribe
**/
    pub fn CFE_SB_UnsubscribeLocal(MsgId: CFE_SB_MsgId_t,
                                   PipeId: CFE_SB_PipeId_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Send a software bus message
**
** \par Description
**          This routine sends the specified message to all subscribers.  The 
**          software bus will read the message ID from the message header to 
**          determine which pipes should receive the message.
**
** \par Assumptions, External Events, and Notes:
**          - This routine will not normally wait for the receiver tasks to 
**            process the message before returning control to the caller's task.
**          - However, if a higher priority task is pending and subscribed to 
**            this message, that task may get to run before #CFE_SB_SendMsg 
**            returns control to the caller.
**          - This function tracks and increments the source sequence counter 
**            of a telemetry message.
**
** \param[in]  MsgPtr       A pointer to the message to be sent.  This must point
**                          to the first byte of the software bus message header
**                          (#CFE_SB_Msg_t). 
**
** \returns
** \retcode #CFE_SUCCESS            \retdesc   \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_SB_BAD_ARGUMENT    \retdesc   \copydoc CFE_SB_BAD_ARGUMENT    \endcode
** \retcode #CFE_SB_MSG_TOO_BIG     \retdesc   \copydoc CFE_SB_MSG_TOO_BIG     \endcode
** \retcode #CFE_SB_BUF_ALOC_ERR    \retdesc   \copydoc CFE_SB_BUF_ALOC_ERR    \endcode
** \endreturns
**
** \sa #CFE_SB_RcvMsg, #CFE_SB_ZeroCopySend, #CFE_SB_PassMsg
**/
    pub fn CFE_SB_SendMsg(MsgPtr: *mut CFE_SB_Msg_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Passes a software bus message
**
** \par Description
**          This routine sends the specified message to all subscribers.  The 
**          software bus will read the message ID from the message header to 
**          determine which pipes should receive the message. This routine is
**          intended to pass messages not generated by the sending application.
**
** \par Assumptions, External Events, and Notes:
**          - This routine will not normally wait for the receiver tasks to 
**            process the message before returning control to the caller's task.
**          - However, if a higher priority task is pending and subscribed to 
**            this message, that task may get to run before #CFE_SB_PassMsg 
**            returns control to the caller.
**          - Unlike #CFE_SB_SendMsg this routine will preserve the source
**            sequence counter in a telemetry message.
**
** \param[in]  MsgPtr       A pointer to the message to be sent.  This must point
**                          to the first byte of the software bus message header
**                          (#CFE_SB_Msg_t). 
**
** \returns
** \retcode #CFE_SUCCESS            \retdesc   \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_SB_BAD_ARGUMENT    \retdesc   \copydoc CFE_SB_BAD_ARGUMENT    \endcode
** \retcode #CFE_SB_MSG_TOO_BIG     \retdesc   \copydoc CFE_SB_MSG_TOO_BIG     \endcode
** \retcode #CFE_SB_BUF_ALOC_ERR    \retdesc   \copydoc CFE_SB_BUF_ALOC_ERR    \endcode
** \endreturns
**
** \sa #CFE_SB_RcvMsg, #CFE_SB_ZeroCopySend, #CFE_SB_SendMsg
**/
    pub fn CFE_SB_PassMsg(MsgPtr: *mut CFE_SB_Msg_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Receive a message from a software bus pipe
**
** \par Description
**          This routine retrieves the next message from the specified pipe.  
**          If the pipe is empty, this routine will block until either a new 
**          message comes in or the timeout value is reached.
**
** \par Assumptions, External Events, and Notes:
**          Note - If an error occurs in this API, the *BufPtr value may be NULL or
**          random. Therefore, it is recommended that the return code be tested 
**          for CFE_SUCCESS before processing the message.
**
** \param[in]  BufPtr       A pointer to a local variable of type #CFE_SB_MsgPtr_t.  
**                          Typically a caller declares a ptr of type CFE_SB_Msg_t 
**                          (i.e. CFE_SB_Msg_t *Ptr) then gives the address of that 
**                          pointer (&Ptr) as this parmeter. After a successful 
**                          receipt of a message, *BufPtr will point to the first 
**                          byte of the software bus message header. This should be 
**                          used as a read-only pointer (in systems with an MMU, 
**                          writes to this pointer may cause a memory protection fault).
**                          The *BufPtr is valid only until the next call to 
**                          CFE_SB_RcvMsg for the same pipe.                            
**                          
** \param[in]  PipeId       The pipe ID of the pipe containing the message to be obtained. 
**
** \param[in]  TimeOut      The number of milliseconds to wait for a new message if the
**                          pipe is empty at the time of the call.  This can also be set
**                          to #CFE_SB_POLL for a non-blocking receive or 
**                          #CFE_SB_PEND_FOREVER to wait forever for a message to arrive.
**
** \param[out] *BufPtr      A pointer to the message obtained from the pipe. Valid 
**                          only until the next call to CFE_SB_RcvMsg for the same pipe.
**
** \returns
** \retcode #CFE_SUCCESS            \retdesc  \copydoc CFE_SUCCESS          \endcode
** \retcode #CFE_SB_BAD_ARGUMENT    \retdesc  \copydoc CFE_SB_BAD_ARGUMENT  \endcode
** \retcode #CFE_SB_TIME_OUT        \retdesc  \copydoc CFE_SB_TIME_OUT      \endcode
** \retcode #CFE_SB_PIPE_RD_ERR     \retdesc  \copydoc CFE_SB_PIPE_RD_ERR   \endcode
** \retcode #CFE_SB_NO_MESSAGE      \retdesc  \copydoc CFE_SB_NO_MESSAGE    \endcode
** \endreturns
**
** \sa #CFE_SB_SendMsg, #CFE_SB_ZeroCopySend
**/
    pub fn CFE_SB_RcvMsg(BufPtr: *mut CFE_SB_MsgPtr_t,
                         PipeId: CFE_SB_PipeId_t, TimeOut: int32) -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Retrieve the application Info of the sender for the last message.
**
** \par Description
**          This routine can be used after a successful #CFE_SB_RcvMsg call 
**          to find out which application sent the message that was received.
**
** \par Assumptions, External Events, and Notes:
**          Note - If an error occurs in this API, the *Ptr value may be NULL or
**          random. Therefore, it is recommended that the return code be tested 
**          for CFE_SUCCESS before reading the sender information.
**
** \param[in]  Ptr       A pointer to a local variable of type #CFE_SB_SenderId_t.  
**                       Typically a caller declares a ptr of type CFE_SB_SenderId_t 
**                       (i.e. CFE_SB_SenderId_t *Ptr) then gives the address of that 
**                       pointer (&Ptr) for this parameter. After a successful call   
**                       to this API, *Ptr will point to the first byte of the 
**                       CFE_SB_SenderId_t structure containing the sender information  
**                       for the last message received on the given pipe. This should 
**                       be used as a read-only pointer (in systems with an MMU, writes  
**                       to this pointer may cause a memory protection fault).  The *Ptr  
**                       is valid only until the next call to CFE_SB_RcvMsg for the 
**                       same pipe.
**
** \param[in]  PipeId    The pipe ID of the pipe the message was taken from. 
**
** \returns
** \retcode The sender's application ID  \retdesc \endcode
** \endreturns
**
** \sa 
**/
    pub fn CFE_SB_GetLastSenderId(Ptr: *mut *mut CFE_SB_SenderId_t,
                                  PipeId: CFE_SB_PipeId_t) -> uint32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Get a buffer pointer to use for "zero copy" SB sends.
**
** \par Description
**          This routine can be used to get a pointer to one of the software bus' 
**          internal memory buffers that are used for sending messages.  The caller 
**          can use this memory buffer to build an SB message, then send it using 
**          the #CFE_SB_ZeroCopySend function.  This interface is more complicated 
**          than the normal #CFE_SB_ZeroCopySend interface, but it avoids an extra 
**          copy of the message from the user's memory buffer to the software bus 
**          internal buffer.  The "zero copy" interface can be used to improve 
**          performance in high-rate, high-volume software bus traffic.
**
** \par Assumptions, External Events, and Notes:
**          -# The pointer returned by #CFE_SB_ZeroCopyGetPtr is only good for one 
**             call to #CFE_SB_ZeroCopySend.  
**          -# Applications should be written as if #CFE_SB_ZeroCopyGetPtr is 
**             equivalent to a \c malloc() and #CFE_SB_ZeroCopySend is equivalent to 
**             a \c free().
**          -# Applications must not de-reference the message pointer (for reading 
**             or writing) after the call to #CFE_SB_ZeroCopySend. 
**
** \param[in]  MsgSize  The size of the SB message buffer the caller wants 
**                      (including the SB message header). 
**
** \param[out] BufferHandle  A handle that must be supplied when sending or releasing
**                           in zero copy mode. 
**
** \returns
** \retstmt A pointer to a memory buffer that can be used to build one SB message 
**         for use with #CFE_SB_ZeroCopySend.  \endstmt
** \endreturns
**
** \sa #CFE_SB_ZeroCopyReleasePtr, #CFE_SB_ZeroCopySend
**/
    pub fn CFE_SB_ZeroCopyGetPtr(MsgSize: uint16,
                                 BufferHandle: *mut CFE_SB_ZeroCopyHandle_t)
     -> *mut CFE_SB_Msg_t;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Release an unused "zero copy" buffer pointer.
**
** \par Description
**          This routine can be used to release a pointer to one of the software 
**          bus' internal memory buffers.
**
** \par Assumptions, External Events, and Notes:
**          -# This function is not needed for normal "zero copy" transfers.  It 
**             is needed only for cleanup when an application gets a pointer using 
**             #CFE_SB_ZeroCopyGetPtr, but (due to some error condition) never uses 
**             that pointer for a #CFE_SB_ZeroCopySend  
**
** \param[in]  Ptr2Release  A pointer to the SB internal buffer.  This must be a 
**                          pointer returned by a call to #CFE_SB_ZeroCopyGetPtr, 
**                          but never used in a call to #CFE_SB_ZeroCopySend. 
**
** \param[in]  BufferHandle  This must be the handle supplied with the pointer 
**                           when #CFE_SB_ZeroCopyGetPtr was called. 
**
** \returns
** \retcode #CFE_SUCCESS            \retdesc   \copydoc CFE_SUCCESS  \endcode
** \retcode #CFE_SB_BUFFER_INVALID  \retdesc   \copydoc CFE_SB_BUFFER_INVALID  \endcode
** \endreturns
**
** \sa #CFE_SB_ZeroCopyGetPtr, #CFE_SB_ZeroCopySend
**/
    pub fn CFE_SB_ZeroCopyReleasePtr(Ptr2Release: *mut CFE_SB_Msg_t,
                                     BufferHandle: CFE_SB_ZeroCopyHandle_t)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Send an SB message in "zero copy" mode.
**
** \par Description
**          This routine sends a message that has been created directly in an 
**          internal SB message buffer by an application (after a call to 
**          #CFE_SB_ZeroCopyGetPtr).  This interface is more complicated than 
**          the normal #CFE_SB_SendMsg interface, but it avoids an extra copy of 
**          the message from the user's memory buffer to the software bus 
**          internal buffer.  The "zero copy" interface can be used to improve 
**          performance in high-rate, high-volume software bus traffic.
**
** \par Assumptions, External Events, and Notes:
**          -# The pointer returned by #CFE_SB_ZeroCopyGetPtr is only good for 
**             one call to #CFE_SB_ZeroCopySend.  
**          -# Callers must not use the same SB message buffer for multiple sends.  
**          -# Applications should be written as if #CFE_SB_ZeroCopyGetPtr is 
**             equivalent to a \c malloc() and #CFE_SB_ZeroCopySend is equivalent 
**             to a \c free().  
**          -# Applications must not de-reference the message pointer (for reading 
**             or writing) after the call to #CFE_SB_ZeroCopySend.  
**          -# This function tracks and increments the source sequence counter 
**             of a telemetry message.
**
** \param[in]  MsgPtr  A pointer to the SB message to be sent. 
**
** \param[in]  BufferHandle  The handle supplied with the #CFE_SB_ZeroCopyGetPtr call. 
**
** \returns
** \retcode #CFE_SUCCESS            \retdesc   \copydoc CFE_SUCCESS  \endcode
** \retcode #CFE_SB_BAD_ARGUMENT    \retdesc   \copydoc CFE_SB_BAD_ARGUMENT    \endcode
** \retcode #CFE_SB_MSG_TOO_BIG     \retdesc   \copydoc CFE_SB_MSG_TOO_BIG     \endcode
** \retcode #CFE_SB_BUF_ALOC_ERR    \retdesc   \copydoc CFE_SB_BUF_ALOC_ERR    \endcode
** \retcode #CFE_SB_BUFFER_INVALID  \retdesc   \copydoc CFE_SB_BUFFER_INVALID  \endcode
** \endreturns
**
** \sa #CFE_SB_SendMsg, #CFE_SB_RcvMsg, #CFE_SB_ZeroCopyReleasePtr, #CFE_SB_ZeroCopyGetPtr  
**/
    pub fn CFE_SB_ZeroCopySend(MsgPtr: *mut CFE_SB_Msg_t,
                               BufferHandle: CFE_SB_ZeroCopyHandle_t)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Pass an SB message in "zero copy" mode.
**
** \par Description
**          This routine sends a message that has been created directly in an 
**          internal SB message buffer by an application (after a call to 
**          #CFE_SB_ZeroCopyGetPtr).  This interface is more complicated than 
**          the normal #CFE_SB_SendMsg interface, but it avoids an extra copy of 
**          the message from the user's memory buffer to the software bus 
**          internal buffer.  The "zero copy" interface can be used to improve 
**          performance in high-rate, high-volume software bus traffic. This 
**          version is intended to pass messages not generated by the caller
**          (to preserve the source sequence count).
**
** \par Assumptions, External Events, and Notes:
**          -# The pointer returned by #CFE_SB_ZeroCopyGetPtr is only good for 
**             one call to #CFE_SB_ZeroCopySend or #CFE_SB_ZeroCopyPass.  
**          -# Callers must not use the same SB message buffer for multiple sends.  
**          -# Applications should be written as if #CFE_SB_ZeroCopyGetPtr is 
**             equivalent to a \c malloc() and #CFE_SB_ZeroCopyPass is equivalent 
**             to a \c free().  
**          -# Applications must not de-reference the message pointer (for reading 
**             or writing) after the call to #CFE_SB_ZeroCopyPass.  
**          -# Unlike #CFE_SB_ZeroCopySend this routine will preserve the source
**             sequence counter in a telemetry message.
**
** \param[in]  MsgPtr  A pointer to the SB message to be sent. 
**
** \param[in]  BufferHandle  The handle supplied with the #CFE_SB_ZeroCopyGetPtr call. 
**
** \returns
** \retcode #CFE_SUCCESS            \retdesc   \copydoc CFE_SUCCESS  \endcode
** \retcode #CFE_SB_BAD_ARGUMENT    \retdesc   \copydoc CFE_SB_BAD_ARGUMENT    \endcode
** \retcode #CFE_SB_MSG_TOO_BIG     \retdesc   \copydoc CFE_SB_MSG_TOO_BIG     \endcode
** \retcode #CFE_SB_BUF_ALOC_ERR    \retdesc   \copydoc CFE_SB_BUF_ALOC_ERR    \endcode
** \retcode #CFE_SB_BUFFER_INVALID  \retdesc   \copydoc CFE_SB_BUFFER_INVALID  \endcode
** \endreturns
**
** \sa #CFE_SB_PassMsg, #CFE_SB_ZeroCopySend, #CFE_SB_ZeroCopyReleasePtr, #CFE_SB_ZeroCopyGetPtr  
**/
    pub fn CFE_SB_ZeroCopyPass(MsgPtr: *mut CFE_SB_Msg_t,
                               BufferHandle: CFE_SB_ZeroCopyHandle_t)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Initialize a buffer for a software bus message.
**
** \par Description
**          This routine fills in the header information needed to create a 
**          valid software bus message.
**
** \par Assumptions, External Events, and Notes:
**          None  
**
** \param[in]  MsgPtr  A pointer to the buffer that will contain the message.  
**                     This will point to the first byte of the message header.  
**                     The \c void* data type allows the calling routine to use
**                     any data type when declaring its message buffer. 
**
** \param[in]  MsgId   The message ID to put in the message header.
**
** \param[in]  Length  The total number of bytes of message data, including the SB 
**                     message header  .
**
** \param[in]  Clear   A flag indicating whether to clear the rest of the message:
**                     \arg TRUE - fill sequence count and packet data with zeroes.
**                     \arg FALSE - leave sequence count and packet data unchanged.
**
** \sa #CFE_SB_SetMsgId, #CFE_SB_SetUserDataLength, #CFE_SB_SetTotalMsgLength,
**     #CFE_SB_SetMsgTime, #CFE_SB_TimeStampMsg, #CFE_SB_SetCmdCode 
**/
    pub fn CFE_SB_InitMsg(MsgPtr: *mut ::std::os::raw::c_void,
                          MsgId: CFE_SB_MsgId_t, Length: uint16,
                          Clear: boolean);
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Get the size of a software bus message header.
**
** \par Description
**          This routine returns the number of bytes in a software bus message header.  
**          This can be used for sizing buffers that need to store SB messages.  SB 
**          message header formats can be different for each deployment of the cFE.  
**          So, applications should use this function and avoid hard coding their buffer 
**          sizes.
**
** \par Assumptions, External Events, and Notes:
**          - For statically defined messages, a function call will not work.  The 
**            macros #CFE_SB_CMD_HDR_SIZE and #CFE_SB_TLM_HDR_SIZE are available for use 
**            in static message buffer sizing or structure definitions.  
**
** \param[in]  MsgId   The message ID to calculate header size for.  The size of the message 
**                     header may depend on the MsgId in some implementations.  For example, 
**                     if SB messages are implemented as CCSDS packets, the size of the header 
**                     is different for command vs. telemetry packets.
**
** \returns
** \retstmt The number of bytes in the software bus message header for 
**          messages with the given \c MsgId. endstmt
** \endreturns
**
** \sa #CFE_SB_GetUserData, #CFE_SB_GetMsgId, #CFE_SB_GetUserDataLength, #CFE_SB_GetTotalMsgLength,
**     #CFE_SB_GetMsgTime, #CFE_SB_GetCmdCode, #CFE_SB_GetChecksum 
**/
    pub fn CFE_SB_MsgHdrSize(MsgId: CFE_SB_MsgId_t) -> uint16;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Get a pointer to the user data portion of a software bus message.
**
** \par Description
**          This routine returns a pointer to the user data portion of a software 
**          bus message.  SB message header formats can be different for each 
**          deployment of the cFE.  So, applications should use this function and 
**          avoid hard coding offsets into their SB message buffers.
**
** \par Assumptions, External Events, and Notes:
**          None  
**
** \param[in]  MsgPtr  A pointer to the buffer that contains the software bus message.
**
** \returns
** \retstmt A pointer to the first byte of user data within the software bus message. \endstmt
** \endreturns
**
** \sa #CFE_SB_GetMsgId, #CFE_SB_GetUserDataLength, #CFE_SB_GetTotalMsgLength,
**     #CFE_SB_GetMsgTime, #CFE_SB_GetCmdCode, #CFE_SB_GetChecksum, #CFE_SB_MsgHdrSize 
**/
    pub fn CFE_SB_GetUserData(MsgPtr: CFE_SB_MsgPtr_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Get the message ID of a software bus message.
**
** \par Description
**          This routine returns the message ID from a software bus message.
**
** \par Assumptions, External Events, and Notes:
**          None  
**
** \param[in]  MsgPtr  A pointer to the buffer that contains the software bus message.
**
** \returns
** \retstmt The software bus Message ID from the message header. \endstmt
** \endreturns
**
** \sa #CFE_SB_GetUserData, #CFE_SB_SetMsgId, #CFE_SB_GetUserDataLength, #CFE_SB_GetTotalMsgLength,
**     #CFE_SB_GetMsgTime, #CFE_SB_GetCmdCode, #CFE_SB_GetChecksum, #CFE_SB_MsgHdrSize 
**/
    pub fn CFE_SB_GetMsgId(MsgPtr: CFE_SB_MsgPtr_t) -> CFE_SB_MsgId_t;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Sets the message ID of a software bus message.
**
** \par Description
**          This routine sets the Message ID in a software bus message header.
**
** \par Assumptions, External Events, and Notes:
**          None  
**
** \param[in]  MsgPtr  A pointer to the buffer that contains the software bus message.
**                     This must point to the first byte of the message header.
**
** \param[in]  MsgId   The message ID to put into the message header. 
**
** \returns
** \retstmt The software bus Message ID from the message header. \endstmt
** \endreturns
**
** \sa #CFE_SB_GetMsgId, #CFE_SB_SetUserDataLength, #CFE_SB_SetTotalMsgLength,
**     #CFE_SB_SetMsgTime, #CFE_SB_TimeStampMsg, #CFE_SB_SetCmdCode, #CFE_SB_InitMsg 
**/
    pub fn CFE_SB_SetMsgId(MsgPtr: CFE_SB_MsgPtr_t, MsgId: CFE_SB_MsgId_t);
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Gets the length of user data in a software bus message.
**
** \par Description
**          This routine returns the size of the user data in a software bus message.
**
** \par Assumptions, External Events, and Notes:
**          None  
**
** \param[in]  MsgPtr  A pointer to the buffer that contains the software bus message.
**                     This must point to the first byte of the message header. 
**
** \returns
** \retstmt The size (in bytes) of the user data in the software bus message. \endstmt
** \endreturns
**
** \sa #CFE_SB_GetUserData, #CFE_SB_GetMsgId, #CFE_SB_SetUserDataLength, #CFE_SB_GetTotalMsgLength,
**     #CFE_SB_GetMsgTime, #CFE_SB_GetCmdCode, #CFE_SB_GetChecksum, #CFE_SB_MsgHdrSize 
**/
    pub fn CFE_SB_GetUserDataLength(MsgPtr: CFE_SB_MsgPtr_t) -> uint16;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Sets the length of user data in a software bus message.
**
** \par Description
**          This routine sets the field in the SB message header that determines 
**          the size of the user data in a software bus message.  SB message header 
**          formats can be different for each deployment of the cFE.  So, applications 
**          should use this function rather than trying to poke a length value directly 
**          into their SB message buffers. 
**
** \par Assumptions, External Events, and Notes:
**          - You must set a valid message ID in the SB message header before 
**            calling this function.  
**
** \param[in]  MsgPtr      A pointer to the buffer that contains the software bus message.
**                         This must point to the first byte of the message header.
**
** \param[in]  DataLength  The length to set (size of the user data, in bytes).
**
**
** \sa #CFE_SB_SetMsgId, #CFE_SB_GetUserDataLength, #CFE_SB_SetTotalMsgLength,
**     #CFE_SB_SetMsgTime, #CFE_SB_TimeStampMsg, #CFE_SB_SetCmdCode, #CFE_SB_InitMsg 
**/
    pub fn CFE_SB_SetUserDataLength(MsgPtr: CFE_SB_MsgPtr_t,
                                    DataLength: uint16);
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Gets the total length of a software bus message.
**
** \par Description
**          This routine returns the total size of the software bus message.   
**
** \par Assumptions, External Events, and Notes:
**          - For the CCSDS implementation of this API, the size is derived from
**            the message header.  
**
** \param[in]  MsgPtr      A pointer to the buffer that contains the software bus message.
**                         This must point to the first byte of the message header.
**
** \returns
** \retstmt The total size (in bytes) of the software bus message, including headers.  \endstmt
** \endreturns
**
** \sa #CFE_SB_GetUserData, #CFE_SB_GetMsgId, #CFE_SB_GetUserDataLength, #CFE_SB_SetTotalMsgLength,
**     #CFE_SB_GetMsgTime, #CFE_SB_GetCmdCode, #CFE_SB_GetChecksum, #CFE_SB_MsgHdrSize 
**/
    pub fn CFE_SB_GetTotalMsgLength(MsgPtr: CFE_SB_MsgPtr_t) -> uint16;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Sets the total length of a software bus message.
**
** \par Description
**          This routine sets the field in the SB message header that determines 
**          the total length of the message.  SB message header formats can be 
**          different for each deployment of the cFE.  So, applications should 
**          use this function rather than trying to poke a length value directly 
**          into their SB message buffers.    
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  MsgPtr      A pointer to the buffer that contains the software bus message.
**                         This must point to the first byte of the message header.
**
** \param[in]  TotalLength The length to set (total size of the message, in bytes, 
**                         including headers).
**
** \sa #CFE_SB_SetMsgId, #CFE_SB_SetUserDataLength, #CFE_SB_GetTotalMsgLength,
**     #CFE_SB_SetMsgTime, #CFE_SB_TimeStampMsg, #CFE_SB_SetCmdCode, #CFE_SB_InitMsg 
**/
    pub fn CFE_SB_SetTotalMsgLength(MsgPtr: CFE_SB_MsgPtr_t,
                                    TotalLength: uint16);
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Gets the time field from a software bus message.
**
** \par Description
**          This routine gets the time from a software bus message.    
**
** \par Assumptions, External Events, and Notes:
**          - If the underlying implementation of software bus messages does not 
**            include a time field, then this routine will return a zero time.  
**
** \param[in]  MsgPtr      A pointer to the buffer that contains the software bus message.
**                         This must point to the first byte of the message header. 
** \returns
** \retstmt The system time included in the software bus message header (if present), 
**         otherwise, returns a time value of zero.  \endstmt
** \endreturns
**
** \sa #CFE_SB_GetUserData, #CFE_SB_GetMsgId, #CFE_SB_GetUserDataLength, #CFE_SB_GetTotalMsgLength,
**     #CFE_SB_SetMsgTime, #CFE_SB_GetCmdCode, #CFE_SB_GetChecksum, #CFE_SB_MsgHdrSize 
**/
    pub fn CFE_SB_GetMsgTime(MsgPtr: CFE_SB_MsgPtr_t) -> CFE_TIME_SysTime_t;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Sets the time field in a software bus message.
**
** \par Description
**          This routine sets the time of a software bus message.  Most applications 
**          will want to use #CFE_SB_TimeStampMsg instead of this function.  But, 
**          when needed, #CFE_SB_SetMsgTime can be used to send a group of SB messages 
**          with identical time stamps.    
**
** \par Assumptions, External Events, and Notes:
**          - If the underlying implementation of software bus messages does not include 
**            a time field, then this routine will do nothing to the message contents 
**            and will return #CFE_SB_WRONG_MSG_TYPE.  
**
** \param[in]  MsgPtr      A pointer to the buffer that contains the software bus message.
**                         This must point to the first byte of the message header.
**
** \param[in]  Time        The time to include in the message.  This will usually be a time 
**                         returned by the function #CFE_TIME_GetTime().
**
** \returns
** \retcode #CFE_SUCCESS            \retdesc \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_SB_WRONG_MSG_TYPE  \retdesc \copydoc CFE_SB_WRONG_MSG_TYPE  \endcode
** \endreturns
**
** \sa #CFE_SB_SetMsgId, #CFE_SB_SetUserDataLength, #CFE_SB_SetTotalMsgLength,
**     #CFE_SB_GetMsgTime, #CFE_SB_TimeStampMsg, #CFE_SB_SetCmdCode, #CFE_SB_InitMsg 
**/
    pub fn CFE_SB_SetMsgTime(MsgPtr: CFE_SB_MsgPtr_t,
                             Time: CFE_TIME_SysTime_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Sets the time field in a software bus message with the current spacecraft time.
**
** \par Description
**          This routine sets the time of a software bus message with the current 
**          spacecraft time.  This will be the same time that is returned by the 
**          function #CFE_TIME_GetTime.      
**
** \par Assumptions, External Events, and Notes:
**          - If the underlying implementation of software bus messages does not 
**            include a time field, then this routine will do nothing.  
**
** \param[in]  MsgPtr      A pointer to the buffer that contains the software bus message.
**                         This must point to the first byte of the message header. 
**
** \sa #CFE_SB_SetMsgId, #CFE_SB_SetUserDataLength, #CFE_SB_SetTotalMsgLength,
**     #CFE_SB_SetMsgTime, #CFE_SB_SetCmdCode, #CFE_SB_InitMsg 
**/
    pub fn CFE_SB_TimeStampMsg(MsgPtr: CFE_SB_MsgPtr_t);
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Gets the command code field from a software bus message.
**
** \par Description
**          This routine gets the command code from a software bus message (if 
**          SB messages are implemented as CCSDS packets, this will be the function 
**          code).      
**
** \par Assumptions, External Events, and Notes:
**          - If the underlying implementation of software bus messages does not 
**            include a command code field, then this routine will return a zero.  
**
** \param[in]  MsgPtr      A pointer to the buffer that contains the software bus message.
**                         This must point to the first byte of the message header.
**
** \returns
** \retstmt The command code included in the software bus message header (if present).
**         Otherwise, returns a command code value of zero.  \endstmt
** \endreturns
**
** \sa #CFE_SB_GetUserData, #CFE_SB_GetMsgId, #CFE_SB_GetUserDataLength, #CFE_SB_GetTotalMsgLength,
**     #CFE_SB_GetMsgTime, #CFE_SB_SetCmdCode, #CFE_SB_GetChecksum, #CFE_SB_MsgHdrSize 
**/
    pub fn CFE_SB_GetCmdCode(MsgPtr: CFE_SB_MsgPtr_t) -> uint16;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Sets the command code field in a software bus message.
**
** \par Description
**          This routine sets the command code of a software bus message (if SB 
**          messages are implemented as CCSDS packets, this will be the function code).      
**
** \par Assumptions, External Events, and Notes:
**          - If the underlying implementation of software bus messages does not 
**            include a command code field, then this routine will do nothing to 
**            the message contents and will return #CFE_SB_WRONG_MSG_TYPE.  
**
** \param[in]  MsgPtr      A pointer to the buffer that contains the software bus message.
**                         This must point to the first byte of the message header.
**
** \param[in]  CmdCode     The command code to include in the message.
**
** \returns
** \retcode #CFE_SUCCESS           \retdesc \copydoc CFE_SUCCESS            \endcode
** \retcode #CFE_SB_WRONG_MSG_TYPE \retdesc \copydoc CFE_SB_WRONG_MSG_TYPE  \endcode
** \endreturns
**
** \sa #CFE_SB_SetMsgId, #CFE_SB_SetUserDataLength, #CFE_SB_SetTotalMsgLength,
**     #CFE_SB_SetMsgTime, #CFE_SB_TimeStampMsg, #CFE_SB_GetCmdCode, #CFE_SB_InitMsg 
**/
    pub fn CFE_SB_SetCmdCode(MsgPtr: CFE_SB_MsgPtr_t, CmdCode: uint16)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Gets the checksum field from a software bus message.
**
** \par Description
**          This routine gets the checksum (or other message integrity check 
**          value) from a software bus message.  The contents and location of 
**          this field will depend on the underlying implementation of software 
**          bus messages.  It may be a checksum, a CRC, or some other algorithm.  
**          Users should not call this function as part of a message integrity 
**          check (call #CFE_SB_ValidateChecksum instead).      
**
** \par Assumptions, External Events, and Notes:
**          - If the underlying implementation of software bus messages does not 
**            include a checksum field, then this routine will return a zero.  
**
** \param[in]  MsgPtr      A pointer to the buffer that contains the software bus message.
**                         This must point to the first byte of the message header.
**
** \returns
** \retstmt The checksum included in the software bus message header (if present), otherwise,
**         returns a checksum value of zero.  \endstmt
** \endreturns
**
** \sa #CFE_SB_GetUserData, #CFE_SB_GetMsgId, #CFE_SB_GetUserDataLength, #CFE_SB_GetTotalMsgLength,
**     #CFE_SB_GetMsgTime, #CFE_SB_GetCmdCode, #CFE_SB_GetChecksum, #CFE_SB_MsgHdrSize,
**     #CFE_SB_ValidateChecksum, #CFE_SB_GenerateChecksum 
**/
    pub fn CFE_SB_GetChecksum(MsgPtr: CFE_SB_MsgPtr_t) -> uint16;
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Calculates and sets the checksum of a software bus message
**
** \par Description
**          This routine calculates the checksum of a software bus message according 
**          to an implementation-defined algorithm.  Then, it sets the checksum field 
**          in the message with the calculated value.  The contents and location of 
**          this field will depend on the underlying implementation of software bus 
**          messages.  It may be a checksum, a CRC, or some other algorithm.        
**
** \par Assumptions, External Events, and Notes:
**          - If the underlying implementation of software bus messages does not 
**            include a checksum field, then this routine will do nothing.  
**
** \param[in]  MsgPtr      A pointer to the buffer that contains the software bus message.
**                         This must point to the first byte of the message header.
**
** \sa #CFE_SB_ValidateChecksum, #CFE_SB_GetChecksum
**/
    pub fn CFE_SB_GenerateChecksum(MsgPtr: CFE_SB_MsgPtr_t);
}
extern "C" {
    /*****************************************************************************/
/** 
** \brief Validates the checksum of a software bus message.
**
** \par Description
**          This routine calculates the expected checksum of a software bus message 
**          according to an implementation-defined algorithm.  Then, it checks the 
**          calculated value against the value in the message's checksum.  If the 
**          checksums do not match, this routine will generate an event message 
**          reporting the error.        
**
** \par Assumptions, External Events, and Notes:
**          - If the underlying implementation of software bus messages does not 
**            include a checksum field, then this routine will always return \c TRUE.  
**
** \param[in]  MsgPtr      A pointer to the buffer that contains the software bus message.
**                         This must point to the first byte of the message header.
**
** \returns
** \retcode TRUE  \retdesc The checksum field in the packet is valid.   \endcode
** \retcode FALSE \retdesc The checksum field in the packet is not valid or the message type is wrong. \endcode
** \endreturns
**
** \sa #CFE_SB_GenerateChecksum, #CFE_SB_GetChecksum
**/
    pub fn CFE_SB_ValidateChecksum(MsgPtr: CFE_SB_MsgPtr_t) -> boolean;
}
extern "C" {
    /******************************************************************************
**  Function:  CFE_SB_MessageStringGet()
**
**  Purpose:
**    Copies a string out of a software bus message
**
**    Strings within software bus messages have a defined/fixed maximum length, and
**    may not necessarily be null terminated within the message.  This presents a possible
**    issue when using the C library functions to copy strings out of a message.
**
**    This function should replace use of C library functions such as strcpy/strncpy
**    when copying strings out of software bus messages to local storage buffers.
**
**    Up to [SourceMaxSize] or [DestMaxSize-1] (whichever is smaller) characters will be
**    coped from the source buffer to the destination buffer, and a NUL termination
**    character will be written to the destination buffer as the last character.
**
**    If the DefaultString pointer is non-NULL, it will be used in place of the source
**    string if the source is an empty string.  This is typically a string constant that
**    comes from the platform configuration, allowing default values to be assumed for
**    fields that are unspecified.
**
**    IMPORTANT - the default string, if specified, must be null terminated.  This will
**    be the case if a string literal is passed in (the typical/expected use case).
**
**    If the default is NULL, then only the source string will be copied, and the result
**    will be an empty string if the source was empty.
**
**    If the destination buffer is too small to store the entire string, it will be
**    truncated, but it will still be null terminated.
**
**  Arguments:
**    DestStringPtr - pointer to destination buffer
**    SourceStringPtr - pointer to source buffer (component of SB message definition)
**    DefaultString - alternative string to use if the source is an empty string
**    DestMaxSize - size of the destination storage buffer (must be at least 2)
**    SourceMaxSize - size of the source buffer as defined by the message definition
**
**  Returns:
**    Length of result - number of characters copied, not including the terminating NUL.
**       This should match the value that would be returned by "strlen(DestStringPtr)"
**
*/
    pub fn CFE_SB_MessageStringGet(DestStringPtr: *mut ::std::os::raw::c_char,
                                   SourceStringPtr:
                                       *const ::std::os::raw::c_char,
                                   DefaultString:
                                       *const ::std::os::raw::c_char,
                                   DestMaxSize: uint32, SourceMaxSize: uint32)
     -> int32;
}
extern "C" {
    /******************************************************************************
**  Function:  CFE_SB_MessageStringSet()
**
**  Purpose:
**    Copies a string into a software bus message
**
**    Strings within software bus messages have a defined/fixed maximum length, and
**    may not necessarily be null terminated within the message.  This presents a possible
**    issue when using the C library functions to copy strings out of a message.
**
**    This performs a very similar function to "strncpy()" except that the sizes
**    of _both_ buffers are passed in.  Neither buffer is required to be null-terminated,
**    but copying will stop after the first termination character is encountered.
**
**    If the destination buffer is not completely filled by the source data (such as if
**    the supplied string was shorter than the allotted length) the destination buffer
**    will be padded with NUL characters up to the size of the buffer, similar to what
**    strncpy() does.  This ensures that the entire destination buffer is set.
**
**    NOTE - if the source string buffer is already guaranteed to be null terminated,
**    then there is no difference between the C library "strncpy()" function and this
**    implementation.  It is only necessary to use this when termination of the source
**    buffer is not guaranteed.
**
**  Arguments:
**    DestStringPtr - pointer to destination buffer
**    SourceStringPtr - pointer to source buffer (component of SB message definition)
**    DestMaxSize - size of the destination storage buffer (must be at least 2)
**    SourceMaxSize - size of the source buffer as defined by the message definition
**
**  Returns:
**    Length of result - number of actual data characters copied
**       This should match the value that would be returned by "strlen(DestStringPtr)"
**
*/
    pub fn CFE_SB_MessageStringSet(DestStringPtr: *mut ::std::os::raw::c_char,
                                   SourceStringPtr:
                                       *const ::std::os::raw::c_char,
                                   DestMaxSize: uint32, SourceMaxSize: uint32)
     -> int32;
}
/**
** \brief Write Event Log to File Command
**
** For command details, see #CFE_EVS_FILE_WRITE_LOG_DATA_CC
**
**/
#[repr(C)]
pub struct CFE_EVS_LogFileCmd_Payload_t {
    /**< \brief Filename where log data is to be written */
    pub LogFilename: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_EVS_LogFileCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_LogFileCmd_Payload_t>() , 64usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_EVS_LogFileCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_LogFileCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_LogFileCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_LogFileCmd_Payload_t ) ) .
                LogFilename as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_LogFileCmd_Payload_t ) , "::" , stringify ! (
                LogFilename ) ));
}
#[repr(C)]
pub struct CFE_EVS_LogFileCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_EVS_LogFileCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_EVS_LogFileCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_LogFileCmd_t>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_EVS_LogFileCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_LogFileCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_LogFileCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_LogFileCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_LogFileCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_LogFileCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_LogFileCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Write Event Services Application Information to File Command
**
** For command details, see #CFE_EVS_FILE_WRITE_APP_DATA_CC
**
**/
#[repr(C)]
pub struct CFE_EVS_AppDataCmd_Payload_t {
    /**< \brief Filename where applicaton data is to be written */
    pub AppDataFilename: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_EVS_AppDataCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_AppDataCmd_Payload_t>() , 64usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_EVS_AppDataCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_AppDataCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_AppDataCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppDataCmd_Payload_t ) ) .
                AppDataFilename as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppDataCmd_Payload_t ) , "::" , stringify ! (
                AppDataFilename ) ));
}
#[repr(C)]
pub struct CFE_EVS_AppDataCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_EVS_AppDataCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_EVS_AppDataCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_AppDataCmd_t>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_EVS_AppDataCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_AppDataCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_AppDataCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppDataCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_AppDataCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppDataCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_AppDataCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Set Event Format Mode or Set Log Mode Commands
**
** For command details, see #CFE_EVS_SET_EVENT_FORMAT_MODE_CC and/or #CFE_EVS_SET_LOG_MODE_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_ModeCmd_Payload_t {
    /**< \brief Mode to use in the command*/
    pub Mode: uint8,
    /**< \brief Pad to even byte*/
    pub Spare: uint8,
}
#[test]
fn bindgen_test_layout_CFE_EVS_ModeCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_ModeCmd_Payload_t>() , 2usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_EVS_ModeCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_ModeCmd_Payload_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_ModeCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_ModeCmd_Payload_t ) ) . Mode as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_ModeCmd_Payload_t ) , "::" , stringify ! ( Mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_ModeCmd_Payload_t ) ) . Spare as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_ModeCmd_Payload_t ) , "::" , stringify ! ( Spare ) ));
}
impl Clone for CFE_EVS_ModeCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_ModeCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_EVS_ModeCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_EVS_ModeCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_ModeCmd_t>() , 10usize , concat !
               ( "Size of: " , stringify ! ( CFE_EVS_ModeCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_ModeCmd_t>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_EVS_ModeCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_ModeCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_ModeCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_ModeCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_ModeCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_EVS_ModeCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Enable/Disable Events or Ports Commands
**
** For command details, see #CFE_EVS_ENABLE_EVENT_TYPE_CC, #CFE_EVS_DISABLE_EVENT_TYPE_CC,
**                          #CFE_EVS_ENABLE_PORTS_CC and/or #CFE_EVS_DISABLE_PORTS_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_BitMaskCmd_Payload_t {
    /**< \brief BitMask to use in the command */
    pub BitMask: uint8,
    /**< \brief Pad to even byte*/
    pub Spare: uint8,
}
#[test]
fn bindgen_test_layout_CFE_EVS_BitMaskCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_BitMaskCmd_Payload_t>() , 2usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_EVS_BitMaskCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_BitMaskCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_BitMaskCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_BitMaskCmd_Payload_t ) ) .
                BitMask as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_BitMaskCmd_Payload_t ) , "::" , stringify ! ( BitMask
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_BitMaskCmd_Payload_t ) ) . Spare
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_BitMaskCmd_Payload_t ) , "::" , stringify ! ( Spare )
                ));
}
impl Clone for CFE_EVS_BitMaskCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_BitMaskCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_EVS_BitMaskCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_EVS_BitMaskCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_BitMaskCmd_t>() , 10usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_EVS_BitMaskCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_BitMaskCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_BitMaskCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_BitMaskCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_BitMaskCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_BitMaskCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_BitMaskCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_EVS_BitMaskCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Enable/Disable Application Events or Reset One or All Filter Counters
**
** For command details, see #CFE_EVS_ENABLE_APP_EVENTS_CC, #CFE_EVS_DISABLE_APP_EVENTS_CC,
**                          #CFE_EVS_RESET_APP_COUNTER_CC and/or #CFE_EVS_RESET_ALL_FILTERS_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_AppNameCmd_Payload_t {
    /**< \brief Application name to use in the command*/
    pub AppName: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout_CFE_EVS_AppNameCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_AppNameCmd_Payload_t>() , 20usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_EVS_AppNameCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_AppNameCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_AppNameCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameCmd_Payload_t ) ) .
                AppName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameCmd_Payload_t ) , "::" , stringify ! ( AppName
                ) ));
}
impl Clone for CFE_EVS_AppNameCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_AppNameCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_EVS_AppNameCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_EVS_AppNameCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_AppNameCmd_t>() , 28usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_EVS_AppNameCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_AppNameCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_AppNameCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_AppNameCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_AppNameCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_EVS_AppNameCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Reset an Event Filter for an Application
**
** For command details, see #CFE_EVS_RESET_FILTER_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_AppNameEventIDCmd_Payload_t {
    /**< \brief Application name to use in the command*/
    pub AppName: [::std::os::raw::c_char; 20usize],
    /**< \brief Event ID  to use in the command*/
    pub EventID: uint16,
}
#[test]
fn bindgen_test_layout_CFE_EVS_AppNameEventIDCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_AppNameEventIDCmd_Payload_t>() ,
               22usize , concat ! (
               "Size of: " , stringify ! ( CFE_EVS_AppNameEventIDCmd_Payload_t
               ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_AppNameEventIDCmd_Payload_t>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_EVS_AppNameEventIDCmd_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameEventIDCmd_Payload_t ) ) .
                AppName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameEventIDCmd_Payload_t ) , "::" , stringify ! (
                AppName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameEventIDCmd_Payload_t ) ) .
                EventID as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameEventIDCmd_Payload_t ) , "::" , stringify ! (
                EventID ) ));
}
impl Clone for CFE_EVS_AppNameEventIDCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_AppNameEventIDCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_EVS_AppNameEventIDCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_EVS_AppNameEventIDCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_AppNameEventIDCmd_t>() , 30usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_EVS_AppNameEventIDCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_AppNameEventIDCmd_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_AppNameEventIDCmd_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameEventIDCmd_t ) ) .
                CmdHeader as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameEventIDCmd_t ) , "::" , stringify ! ( CmdHeader
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameEventIDCmd_t ) ) . Payload
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameEventIDCmd_t ) , "::" , stringify ! ( Payload )
                ));
}
impl Clone for CFE_EVS_AppNameEventIDCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Enable/Disable an Event Type for an Application
**
** For command details, see #CFE_EVS_ENABLE_APP_EVENT_TYPE_CC and/or #CFE_EVS_DISABLE_APP_EVENT_TYPE_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_AppNameBitMaskCmd_Payload_t {
    /**< \brief Application name to use in the command*/
    pub AppName: [::std::os::raw::c_char; 20usize],
    /**< \brief BitMask to use in the command*/
    pub BitMask: uint8,
    /**< \brief Pad to even byte*/
    pub Spare: uint8,
}
#[test]
fn bindgen_test_layout_CFE_EVS_AppNameBitMaskCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_AppNameBitMaskCmd_Payload_t>() ,
               22usize , concat ! (
               "Size of: " , stringify ! ( CFE_EVS_AppNameBitMaskCmd_Payload_t
               ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_AppNameBitMaskCmd_Payload_t>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_EVS_AppNameBitMaskCmd_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameBitMaskCmd_Payload_t ) ) .
                AppName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameBitMaskCmd_Payload_t ) , "::" , stringify ! (
                AppName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameBitMaskCmd_Payload_t ) ) .
                BitMask as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameBitMaskCmd_Payload_t ) , "::" , stringify ! (
                BitMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameBitMaskCmd_Payload_t ) ) .
                Spare as * const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameBitMaskCmd_Payload_t ) , "::" , stringify ! (
                Spare ) ));
}
impl Clone for CFE_EVS_AppNameBitMaskCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_AppNameBitMaskCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_EVS_AppNameBitMaskCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_EVS_AppNameBitMaskCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_AppNameBitMaskCmd_t>() , 30usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_EVS_AppNameBitMaskCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_AppNameBitMaskCmd_t>() , 1usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_AppNameBitMaskCmd_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameBitMaskCmd_t ) ) .
                CmdHeader as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameBitMaskCmd_t ) , "::" , stringify ! ( CmdHeader
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameBitMaskCmd_t ) ) . Payload
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameBitMaskCmd_t ) , "::" , stringify ! ( Payload )
                ));
}
impl Clone for CFE_EVS_AppNameBitMaskCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Set, Add or Delete an Event Filter for an Application
**
** For command details, see #CFE_EVS_SET_FILTER_CC, #CFE_EVS_ADD_EVENT_FILTER_CC 
**                      and/or #CFE_EVS_DELETE_EVENT_FILTER_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_AppNameEventIDMaskCmd_Payload_t {
    /**< \brief Application name to use in the command*/
    pub AppName: [::std::os::raw::c_char; 20usize],
    /**< \brief Event ID  to use in the command*/
    pub EventID: uint16,
    /**< \brief Mask to use in the command */
    pub Mask: uint16,
}
#[test]
fn bindgen_test_layout_CFE_EVS_AppNameEventIDMaskCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_AppNameEventIDMaskCmd_Payload_t>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               CFE_EVS_AppNameEventIDMaskCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_AppNameEventIDMaskCmd_Payload_t>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_EVS_AppNameEventIDMaskCmd_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameEventIDMaskCmd_Payload_t )
                ) . AppName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameEventIDMaskCmd_Payload_t ) , "::" , stringify !
                ( AppName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameEventIDMaskCmd_Payload_t )
                ) . EventID as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameEventIDMaskCmd_Payload_t ) , "::" , stringify !
                ( EventID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameEventIDMaskCmd_Payload_t )
                ) . Mask as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameEventIDMaskCmd_Payload_t ) , "::" , stringify !
                ( Mask ) ));
}
impl Clone for CFE_EVS_AppNameEventIDMaskCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_AppNameEventIDMaskCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_EVS_AppNameEventIDMaskCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_EVS_AppNameEventIDMaskCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_AppNameEventIDMaskCmd_t>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( CFE_EVS_AppNameEventIDMaskCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_AppNameEventIDMaskCmd_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_EVS_AppNameEventIDMaskCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameEventIDMaskCmd_t ) ) .
                CmdHeader as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameEventIDMaskCmd_t ) , "::" , stringify ! (
                CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppNameEventIDMaskCmd_t ) ) .
                Payload as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_AppNameEventIDMaskCmd_t ) , "::" , stringify ! (
                Payload ) ));
}
impl Clone for CFE_EVS_AppNameEventIDMaskCmd_t {
    fn clone(&self) -> Self { *self }
}
/**********************************/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_AppTlmData_t {
    /**< \cfetlmmnemonic \EVS_APPID
                                                     \brief Numerical application identifier */
    pub AppID: uint32,
    /**< \cfetlmmnemonic \EVS_APPMSGSENTC
                                                     \brief Application message sent counter */
    pub AppMessageSentCounter: uint16,
    /**< \cfetlmmnemonic \EVS_APPENASTAT
                                                     \brief Application event service enable status */
    pub AppEnableStatus: uint8,
    /**< \cfetlmmnemonic \EVS_SPARE2ALIGN3
                                                     \brief Padding for 32 bit boundary */
    pub Padding: uint8,
}
#[test]
fn bindgen_test_layout_CFE_EVS_AppTlmData_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_AppTlmData_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( CFE_EVS_AppTlmData_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_AppTlmData_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_AppTlmData_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppTlmData_t ) ) . AppID as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_AppTlmData_t )
                , "::" , stringify ! ( AppID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppTlmData_t ) ) .
                AppMessageSentCounter as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_AppTlmData_t )
                , "::" , stringify ! ( AppMessageSentCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppTlmData_t ) ) .
                AppEnableStatus as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_AppTlmData_t )
                , "::" , stringify ! ( AppEnableStatus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_AppTlmData_t ) ) . Padding as *
                const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_AppTlmData_t )
                , "::" , stringify ! ( Padding ) ));
}
impl Clone for CFE_EVS_AppTlmData_t {
    fn clone(&self) -> Self { *self }
}
/** 
**  \cfeevstlm Event Services Housekeeping Telemetry Packet
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_TlmPkt_Payload_t {
    /**< \cfetlmmnemonic \EVS_CMDPC
                                                                 \brief EVS Command Counter */
    pub CommandCounter: uint8,
    /**< \cfetlmmnemonic \EVS_CMDEC
                                                                 \brief EVS Command Error Counter */
    pub CommandErrCounter: uint8,
    /**< \cfetlmmnemonic \EVS_MSGFMTMODE
                                                                 \brief Event message format mode (short/long) */
    pub MessageFormatMode: uint8,
    /**< \cfetlmmnemonic \EVS_MSGTRUNC
                                                                 \brief Event message truncation counter */
    pub MessageTruncCounter: uint8,
    /**< \cfetlmmnemonic \EVS_UNREGAPPC
                                                                 \brief Unregistered application message send counter */
    pub UnregisteredAppCounter: uint8,
    /**< \cfetlmmnemonic \EVS_OUTPUTPORT
                                                                 \brief Output port mask */
    pub OutputPort: uint8,
    /**< \cfetlmmnemonic \EVS_LOGFULL
                                                                 \brief Local event log full flag */
    pub LogFullFlag: uint8,
    /**< \cfetlmmnemonic \EVS_LOGMODE
                                                                 \brief Local event logging mode (overwrite/discard) */
    pub LogMode: uint8,
    /**< \cfetlmmnemonic \EVS_MSGSENTC
                                                                 \brief Event message send counter */
    pub MessageSendCounter: uint16,
    /**< \cfetlmmnemonic \EVS_LOGOVERFLOWC
                                                                 \brief Local event log overflow counter */
    pub LogOverflowCounter: uint16,
    /**< \cfetlmmnemonic \EVS_LOGENABLED
                                                                 \brief Current event log enable/disable state */
    pub LogEnabled: uint8,
    /**< \cfetlmmnemonic \EVS_HK_SPARE1
                                                                 \brief Padding for 32 bit boundary */
    pub Spare1: uint8,
    /**< \cfetlmmnemonic \EVS_HK_SPARE2
                                                                 \brief Padding for 32 bit boundary */
    pub Spare2: uint8,
    /**< \cfetlmmnemonic \EVS_HK_SPARE3
                                                                 \brief Padding for 32 bit boundary */
    pub Spare3: uint8,
    /**< \cfetlmmnemonic \EVS_APP
                                                                 \brief Array of registered application table data */
    pub AppData: [CFE_EVS_AppTlmData_t; 32usize],
}
#[test]
fn bindgen_test_layout_CFE_EVS_TlmPkt_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_TlmPkt_Payload_t>() , 272usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_EVS_TlmPkt_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_TlmPkt_Payload_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_TlmPkt_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) .
                CommandCounter as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! (
                CommandCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) .
                CommandErrCounter as * const _ as usize } , 1usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! (
                CommandErrCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) .
                MessageFormatMode as * const _ as usize } , 2usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! (
                MessageFormatMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) .
                MessageTruncCounter as * const _ as usize } , 3usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! (
                MessageTruncCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) .
                UnregisteredAppCounter as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! (
                UnregisteredAppCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) . OutputPort
                as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! ( OutputPort )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) .
                LogFullFlag as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! ( LogFullFlag
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) . LogMode as
                * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! ( LogMode )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) .
                MessageSendCounter as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! (
                MessageSendCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) .
                LogOverflowCounter as * const _ as usize } , 10usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! (
                LogOverflowCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) . LogEnabled
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! ( LogEnabled )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) . Spare1 as
                * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! ( Spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) . Spare2 as
                * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! ( Spare2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) . Spare3 as
                * const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! ( Spare3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_Payload_t ) ) . AppData as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_TlmPkt_Payload_t ) , "::" , stringify ! ( AppData )
                ));
}
impl Clone for CFE_EVS_TlmPkt_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_TlmPkt_t {
    pub TlmHeader: [uint8; 12usize],
    pub Payload: CFE_EVS_TlmPkt_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_EVS_TlmPkt_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_TlmPkt_t>() , 284usize , concat !
               ( "Size of: " , stringify ! ( CFE_EVS_TlmPkt_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_TlmPkt_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( CFE_EVS_TlmPkt_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_t ) ) . TlmHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_TlmPkt_t ) ,
                "::" , stringify ! ( TlmHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_TlmPkt_t ) ) . Payload as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_TlmPkt_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_EVS_TlmPkt_t {
    fn clone(&self) -> Self { *self }
}
/** Telemetry packet structures */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_PacketID_t {
    /**< \cfetlmmnemonic \EVS_APPNAME
                                           \brief Application name */
    pub AppName: [::std::os::raw::c_char; 20usize],
    /**< \cfetlmmnemonic \EVS_EVENTID
                                           \brief Numerical event identifier */
    pub EventID: uint16,
    /**< \cfetlmmnemonic \EVS_EVENTTYPE
                                           \brief Numerical event type identifier */
    pub EventType: uint16,
    /**< \cfetlmmnemonic \EVS_SCID
                                           \brief Spacecraft identifier */
    pub SpacecraftID: uint32,
    /**< \cfetlmmnemonic \EVS_PROCESSORID
                                           \brief Numerical processor identifier */
    pub ProcessorID: uint32,
}
#[test]
fn bindgen_test_layout_CFE_EVS_PacketID_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_PacketID_t>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( CFE_EVS_PacketID_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_PacketID_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_EVS_PacketID_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_PacketID_t ) ) . AppName as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_PacketID_t ) ,
                "::" , stringify ! ( AppName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_PacketID_t ) ) . EventID as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_PacketID_t ) ,
                "::" , stringify ! ( EventID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_PacketID_t ) ) . EventType as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_PacketID_t ) ,
                "::" , stringify ! ( EventType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_PacketID_t ) ) . SpacecraftID as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_PacketID_t ) ,
                "::" , stringify ! ( SpacecraftID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_PacketID_t ) ) . ProcessorID as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_PacketID_t ) ,
                "::" , stringify ! ( ProcessorID ) ));
}
impl Clone for CFE_EVS_PacketID_t {
    fn clone(&self) -> Self { *self }
}
/** 
**  \cfeevstlm Event Message Telemetry Packet
**/
#[repr(C)]
pub struct CFE_EVS_Packet_Payload_t {
    /**< \brief Event packet information */
    pub PacketID: CFE_EVS_PacketID_t,
    /**< \cfetlmmnemonic \EVS_EVENT
                                                                         \brief Event message string */
    pub Message: [::std::os::raw::c_char; 122usize],
    /**< \cfetlmmnemonic \EVS_SPARE1
                                                                         \brief Structure padding */
    pub Spare1: uint8,
    /**< \cfetlmmnemonic \EVS_SPARE2
                                                                         \brief Structure padding */
    pub Spare2: uint8,
}
#[test]
fn bindgen_test_layout_CFE_EVS_Packet_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_Packet_Payload_t>() , 156usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_EVS_Packet_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_Packet_Payload_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_Packet_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_Packet_Payload_t ) ) . PacketID
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_Packet_Payload_t ) , "::" , stringify ! ( PacketID )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_Packet_Payload_t ) ) . Message as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_Packet_Payload_t ) , "::" , stringify ! ( Message )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_Packet_Payload_t ) ) . Spare1 as
                * const _ as usize } , 154usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_Packet_Payload_t ) , "::" , stringify ! ( Spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_Packet_Payload_t ) ) . Spare2 as
                * const _ as usize } , 155usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_EVS_Packet_Payload_t ) , "::" , stringify ! ( Spare2 ) ));
}
#[repr(C)]
pub struct CFE_EVS_Packet_t {
    pub TlmHeader: [uint8; 12usize],
    pub Payload: CFE_EVS_Packet_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_EVS_Packet_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_Packet_t>() , 168usize , concat !
               ( "Size of: " , stringify ! ( CFE_EVS_Packet_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_Packet_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( CFE_EVS_Packet_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_Packet_t ) ) . TlmHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_Packet_t ) ,
                "::" , stringify ! ( TlmHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_Packet_t ) ) . Payload as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_Packet_t ) ,
                "::" , stringify ! ( Payload ) ));
}
/** Event message filter defintion structure */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_EVS_BinFilter_t {
    /**< \brief Numerical event identifier */
    pub EventID: uint16,
    /**< \brief Binary filter mask value */
    pub Mask: uint16,
}
#[test]
fn bindgen_test_layout_CFE_EVS_BinFilter_t() {
    assert_eq!(::std::mem::size_of::<CFE_EVS_BinFilter_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( CFE_EVS_BinFilter_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_EVS_BinFilter_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_EVS_BinFilter_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_BinFilter_t ) ) . EventID as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_BinFilter_t ) ,
                "::" , stringify ! ( EventID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_EVS_BinFilter_t ) ) . Mask as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_EVS_BinFilter_t ) ,
                "::" , stringify ! ( Mask ) ));
}
impl Clone for CFE_EVS_BinFilter_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /** 
** \brief Register an application for receiving event services
**
** \par Description
**          This routine registers an application with event services and allocates/initializes
**          the internal data structures used to support this application's events.  An application
**          may not send events unless it has called this routine.  The routine also accepts a filter
**          array structure for applications requiring event filtering.  In the current implementation
**          of the EVS, only the binary filtering scheme is supported.  See section TBD of the cFE
**          Application Programmer's Guide for a description of the behavior of binary filters.
**          Applications may call #CFE_EVS_Register more than once, but each call will wipe out all
**          filters registered by previous calls (filter registration is NOT cumulative).
**
** \par Assumptions, External Events, and Notes:
**          Note: Event filters can be added, deleted or modified by ground commands.  All filtering 
**                schemes include a default setting that results in no filtering (such as #CFE_EVS_NO_FILTER 
**                for binary filters).
**
**          <b> Filter Scheme: </b> Binary <BR>
**          <b> Code: </b> CFE_EVS_BINARY_FILTER <BR>
**          <b> Filter Structure: </b> 
**          \code
**                     typedef struct {
**                           uint16  EventID,
**                           uint16  Mask ;
**                     } CFE_EVS_BinFilter_t;
**          \endcode
**
** \param[in] Filters            Pointer to an array of event message filters, or NULL if no filtering is desired.  
**                               The structure of an event message filter depends on the FilterScheme selected. 
**                               (see Filter Schemes mentioned above) 
**
** \param[in] NumFilteredEvents  The number of event message filters included in this call.  This must be less than
**                               or equal to the maximum number of events allowed per application (#CFE_EVS_MAX_EVENT_FILTERS).
**
** \param[in] FilterScheme       The event filtering scheme that this application will use.  For the first implementation of 
**                               the event services, only filter type #CFE_EVS_BINARY_FILTER will be supported.
**
** \returns
** \retcode #CFE_SUCCESS                    \retdesc  \copydoc CFE_SUCCESS                   \endcode
** \retcode #CFE_EVS_APP_FILTER_OVERLOAD    \retdesc  \copydoc CFE_EVS_APP_FILTER_OVERLOAD   \endcode
** \retcode #CFE_EVS_UNKNOWN_FILTER         \retdesc  \copydoc CFE_EVS_UNKNOWN_FILTER        \endcode
** \retcode #CFE_EVS_APP_ILLEGAL_APP_ID     \retdesc  \copydoc CFE_EVS_APP_ILLEGAL_APP_ID    \endcode
** \retstmt Any of the error codes from #CFE_ES_GetAppID    \endstmt
** \endreturns
**
** \sa #CFE_EVS_Unregister
**
**/
    pub fn CFE_EVS_Register(Filters: *mut ::std::os::raw::c_void,
                            NumFilteredEvents: uint16, FilterScheme: uint16)
     -> int32;
}
extern "C" {
    /** 
** \brief Cleanup internal structures used by the event manager for the calling Application.
**
** \par Description
**          This routine un-registers the calling application from receiving event services 
**          and removes and deletes the calling applications filters and counters from the 
**          internal event service filter and counter tables if registered.  Applications 
**          must call this routine as part of their orderly shutdown process.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retcode #CFE_SUCCESS                  \retdesc    \copydoc CFE_SUCCESS                 \endcode
** \retcode #CFE_EVS_APP_NOT_REGISTERED   \retdesc    \copydoc CFE_EVS_APP_NOT_REGISTERED  \endcode
** \retcode #CFE_EVS_APP_ILLEGAL_APP_ID   \retdesc    \copydoc CFE_EVS_APP_ILLEGAL_APP_ID  \endcode
** \retstmt Any of the error codes from #CFE_ES_GetAppID          \endstmt
** \retstmt Any of the error codes from #CFE_ES_PutPoolBuf        \endstmt
** \endreturns
**
** \sa #CFE_EVS_Register
**
**/
    pub fn CFE_EVS_Unregister() -> int32;
}
extern "C" {
    /** 
** \brief Generate a software event.
**
** \par Description
**          This routine generates a software event message.  If the EventID is not filtered, 
**          the event will be sent as a software bus message, optionally logged in the local 
**          event log, and optionally sent as an ASCII text string out the enabled output port(s). 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] EventID            A numeric literal used to uniquely identify an application event.  
**                               The \c EventID is defined and supplied by the application sending the event.   
**
** \param[in] EventType          A numeric literal used to classify an event, one of:
**                                   \arg #CFE_EVS_DEBUG          
**                                   \arg #CFE_EVS_INFORMATION    
**                                   \arg #CFE_EVS_ERROR          
**                                   \arg #CFE_EVS_CRITICAL       
**  
** \param[in] Spec               A pointer to a null terminated text string describing the output format 
**                               for the event.  This is the same type of format string used for the ANSI 
**                               \c printf function.  Nominally the post-conversion string is limited to 80 
**                               characters, but this limit is configurable through the parameter 
**                               #CFE_EVS_MAX_MESSAGE_LENGTH.  Characters beyond the limit will be truncated.  
**                               Do not use floating point conversions (%f, %e, %E, %g, and %G) in the format 
**                               string unless your application will be running in a system that supports 
**                               floating point arithmetic.  Do not use non-printable characters (\\t, \\n, etc.) 
**                               in the format string; they will mess up the formatting when the events are 
**                               displayed on the ground system.
**
** \returns
** \retcode #CFE_SUCCESS                   \retdesc   \copydoc CFE_SUCCESS                    \endcode
** \retcode #CFE_EVS_APP_NOT_REGISTERED    \retdesc   \copydoc CFE_EVS_APP_NOT_REGISTERED     \endcode
** \retcode #CFE_EVS_APP_ILLEGAL_APP_ID    \retdesc   \copydoc CFE_EVS_APP_ILLEGAL_APP_ID     \endcode
** \retstmt Any of the error codes from #CFE_ES_GetAppID        \endstmt
** \retstmt Any of the error codes from #CFE_SB_SendMsg         \endstmt
** \endreturns
**
** \sa #CFE_EVS_SendEventWithAppID, #CFE_EVS_SendTimedEvent
**
**/
    pub fn CFE_EVS_SendEvent(EventID: uint16, EventType: uint16,
                             Spec: *const ::std::os::raw::c_char, ...)
     -> int32;
}
extern "C" {
    /** 
** \brief Generate a software event given the specified Application ID.
**
** \par Description
**          This routine generates a software event message.  If the EventID is not filtered, 
**          the event will be sent as a software bus message, optionally logged in the local 
**          event log, and optionally sent as an ASCII text string out the enabled output port(s).   
**          Note that this function should really only be used from within an API in order to 
**          preserve the context of an Application's event.  In general, #CFE_EVS_SendEvent should be used. 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] EventID            A numeric literal used to uniquely identify an application event.  
**                               The \c EventID is defined and supplied by the application sending the event.   
**
** \param[in] EventType          A numeric literal used to classify an event, one of:
**                                   \arg #CFE_EVS_DEBUG
**                                   \arg #CFE_EVS_INFORMATION
**                                   \arg #CFE_EVS_ERROR
**                                   \arg #CFE_EVS_CRITICAL
**  
** \param[in] AppID              The Application ID from which the event message should appear.   
**
** \param[in] Spec               A pointer to a null terminated text string describing the output format 
**                               for the event.  This is the same type of format string used for the ANSI 
**                               \c printf function.  Nominally the post-conversion string is limited to 80 
**                               characters, but this limit is configurable through the parameter 
**                               #CFE_EVS_MAX_MESSAGE_LENGTH.  Characters beyond the limit will be truncated.  
**                               Do not use floating point conversions (%f, %e, %E, %g, and %G) in the format 
**                               string unless your application will be running in a system that supports 
**                               floating point arithmetic.  Do not use non-printable characters (\\t, \\n, etc.) 
**                               in the format string; they will mess up the formatting when the events are 
**                               displayed on the ground system.
**
** \returns
** \retcode #CFE_SUCCESS                  \retdesc  \copydoc CFE_SUCCESS                 \endcode
** \retcode #CFE_EVS_APP_NOT_REGISTERED   \retdesc  \copydoc CFE_EVS_APP_NOT_REGISTERED  \endcode
** \retcode #CFE_EVS_APP_ILLEGAL_APP_ID   \retdesc  \copydoc CFE_EVS_APP_ILLEGAL_APP_ID  \endcode
** \retstmt Any of the error codes from #CFE_ES_GetAppID     \endstmt
** \retstmt Any of the error codes from #CFE_SB_SendMsg      \endstmt
** \endreturns
**
** \sa #CFE_EVS_SendEvent, #CFE_EVS_SendTimedEvent
**
**/
    pub fn CFE_EVS_SendEventWithAppID(EventID: uint16, EventType: uint16,
                                      AppID: uint32,
                                      Spec:
                                          *const ::std::os::raw::c_char, ...)
     -> int32;
}
extern "C" {
    /** 
** \brief Generate a software event with a specific time tag.
**
** \par Description
**          This routine is the same as CFE_EVS_SendEvent except that the caller specifies the event time 
**          instead of having the EVS use the current spacecraft time.  This routine should be used in 
**          situations where an error condition is detected at one time, but the event message is reported 
**          at a later time. 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] Time               The time to include in the event.  This will usually be a time returned 
**                               by the function #CFE_TIME_GetTime().   
**
** \param[in] EventID            A numeric literal used to uniquely identify an application event.  
**                               The \c EventID is defined and supplied by the application sending the event.   
**
** \param[in] EventType          A numeric literal used to classify an event, one of:
**                                   \arg #CFE_EVS_DEBUG          
**                                   \arg #CFE_EVS_INFORMATION    
**                                   \arg #CFE_EVS_ERROR          
**                                   \arg #CFE_EVS_CRITICAL       
**  
** \param[in] Spec               A pointer to a null terminated text string describing the output format 
**                               for the event.  This is the same type of format string used for the ANSI 
**                               \c printf function.  Nominally the post-conversion string is limited to 80 
**                               characters, but this limit is configurable through the parameter 
**                               #CFE_EVS_MAX_MESSAGE_LENGTH.  Characters beyond the limit will be truncated.  
**                               Do not use floating point conversions (%f, %e, %E, %g, and %G) in the format 
**                               string unless your application will be running in a system that supports 
**                               floating point arithmetic.  Do not use non-printable characters (\\t, \\n, etc.) 
**                               in the format string; they will mess up the formatting when the events are 
**                               displayed on the ground system.
**
** \returns
** \retcode #CFE_SUCCESS                   \retdesc   \copydoc CFE_SUCCESS                 \endcode
** \retcode #CFE_EVS_APP_NOT_REGISTERED    \retdesc   \copydoc CFE_EVS_APP_NOT_REGISTERED  \endcode
** \retcode #CFE_EVS_APP_ILLEGAL_APP_ID    \retdesc   \copydoc CFE_EVS_APP_ILLEGAL_APP_ID  \endcode
** \retstmt Any of the error codes from #CFE_ES_GetAppID       \endstmt
** \retstmt Any of the error codes from #CFE_SB_SendMsg        \endstmt
** \endreturns
**
** \sa #CFE_EVS_SendEvent, #CFE_EVS_SendEventWithAppID
**
**/
    pub fn CFE_EVS_SendTimedEvent(Time: CFE_TIME_SysTime_t, EventID: uint16,
                                  EventType: uint16,
                                  Spec: *const ::std::os::raw::c_char, ...)
     -> int32;
}
extern "C" {
    /** 
** \brief Resets the calling application's event filter for a single event ID.
**
** \par Description
**          The effect of resetting an event filter depends on the filter scheme.  
**          The #CFE_EVS_BINARY_FILTER scheme resets the filter counter for the specified Event ID. 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] EventID            A numeric literal used to uniquely identify an application event.  
**                               The \c EventID is defined and supplied by the application sending the event.   
**
** \returns
** \retcode #CFE_SUCCESS                  \retdesc  \copydoc CFE_SUCCESS                     \endcode
** \retcode #CFE_EVS_APP_NOT_REGISTERED   \retdesc  \copydoc CFE_EVS_APP_NOT_REGISTERED      \endcode
** \retcode #CFE_EVS_APP_ILLEGAL_APP_ID   \retdesc  \copydoc CFE_EVS_APP_ILLEGAL_APP_ID      \endcode
** \retstmt Any of the error codes from #CFE_ES_GetAppID       \endstmt
** \endreturns
**
** \sa #CFE_EVS_ResetAllFilters
**
**/
    pub fn CFE_EVS_ResetFilter(EventID: int16) -> int32;
}
extern "C" {
    /** 
** \brief Resets all of the calling application's event filters.
**
** \par Description
**          This routine resets all the calling application's event filter counters to zero, providing a 
**          quick and convenient method for resetting event filters. 
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \returns
** \retcode #CFE_SUCCESS                  \retdesc  \copydoc CFE_SUCCESS                  \endcode
** \retcode #CFE_EVS_APP_NOT_REGISTERED   \retdesc  \copydoc CFE_EVS_APP_NOT_REGISTERED   \endcode
** \retcode #CFE_EVS_APP_ILLEGAL_APP_ID   \retdesc  \copydoc CFE_EVS_APP_ILLEGAL_APP_ID   \endcode
** \retstmt Any of the error codes from #CFE_ES_GetAppID \endstmt
** \endreturns
**
** \sa #CFE_EVS_ResetFilter
**
**/
    pub fn CFE_EVS_ResetAllFilters() -> int32;
}
/**
** \brief Standard cFE File header structure definition
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_FS_Header_t {
    /**< \brief Identifies the content type (='cFE1'=0x63464531)*/
    pub ContentType: uint32,
    /**< \brief Type of \c ContentType, if necessary */
                                   /**< Standard SubType definitions can be found
                                        \link #CFE_FS_ES_ERLOG_SUBTYPE here \endlink */
    pub SubType: uint32,
    /**< \brief Length of primary header */
    pub Length: uint32,
    /**< \brief Spacecraft that generated the file */
    pub SpacecraftID: uint32,
    /**< \brief Processor that generated the file */
    pub ProcessorID: uint32,
    /**< \brief Application that generated the file */
    pub ApplicationID: uint32,
    /**< \brief File creation timestamp (seconds) */
    pub TimeSeconds: uint32,
    /**< \brief File creation timestamp (sub-seconds) */
    pub TimeSubSeconds: uint32,
    /**< \brief File description */
    pub Description: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_CFE_FS_Header_t() {
    assert_eq!(::std::mem::size_of::<CFE_FS_Header_t>() , 64usize , concat ! (
               "Size of: " , stringify ! ( CFE_FS_Header_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_FS_Header_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( CFE_FS_Header_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_FS_Header_t ) ) . ContentType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_FS_Header_t ) ,
                "::" , stringify ! ( ContentType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_FS_Header_t ) ) . SubType as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_FS_Header_t ) ,
                "::" , stringify ! ( SubType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_FS_Header_t ) ) . Length as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_FS_Header_t ) ,
                "::" , stringify ! ( Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_FS_Header_t ) ) . SpacecraftID as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_FS_Header_t ) ,
                "::" , stringify ! ( SpacecraftID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_FS_Header_t ) ) . ProcessorID as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_FS_Header_t ) ,
                "::" , stringify ! ( ProcessorID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_FS_Header_t ) ) . ApplicationID as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_FS_Header_t ) ,
                "::" , stringify ! ( ApplicationID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_FS_Header_t ) ) . TimeSeconds as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_FS_Header_t ) ,
                "::" , stringify ! ( TimeSeconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_FS_Header_t ) ) . TimeSubSeconds as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_FS_Header_t ) ,
                "::" , stringify ! ( TimeSubSeconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_FS_Header_t ) ) . Description as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_FS_Header_t ) ,
                "::" , stringify ! ( Description ) ));
}
impl Clone for CFE_FS_Header_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Read the contents of the Standard cFE File Header
**
** \par Description
**        This API will fill the specified #CFE_FS_Header_t variable with the
**        contents of the Standard cFE File Header of the file identified by
**        the given File Descriptor.
**
** \par Assumptions, External Events, and Notes:
**        -# The File has already been successfully opened using #OS_open and
**           the caller has a legitimate File Descriptor.
**
** \param[in] FileDes File Descriptor obtained from a previous call to #OS_open
**                    that is associated with the file whose header is to be read.
**
** \param[in] Hdr     Pointer to a variable of type #CFE_FS_Header_t that will be
**                    filled with the contents of the Standard cFE File Header.
**
** \param[out] *Hdr   Contents of the Standard cFE File Header for the specified file.
**
** \returns
** \retstmt Any of the return codes specified for #OS_lseek or #OS_read  \endstmt
** \endreturns
**
** \sa #CFE_FS_WriteHeader
**
******************************************************************************/
    pub fn CFE_FS_ReadHeader(Hdr: *mut CFE_FS_Header_t, FileDes: int32)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Initializes the contents of the Standard cFE File Header
**
** \par Description
**        This API will clear the specified #CFE_FS_Header_t variable and
**        initialize the description field with the specified value
**
** \param[in] Hdr     Pointer to a variable of type #CFE_FS_Header_t that will be
**                    cleared and initialized
**
** \sa #CFE_FS_WriteHeader
**
******************************************************************************/
    pub fn CFE_FS_InitHeader(Hdr: *mut CFE_FS_Header_t,
                             Description: *const ::std::os::raw::c_char,
                             SubType: uint32);
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Write the specified Standard cFE File Header to the specified file
**
** \par Description
**        This API will output the specified #CFE_FS_Header_t variable, with some
**        fields automatically updated, to the specified file as the Standard cFE
**        File Header. This API will automatically populate the following fields
**        in the specified #CFE_FS_Header_t:
**
**      -# \link #CFE_FS_Header_t::ContentType \c ContentType \endlink - Filled with 0x63464531 ('cFE1')
**      -# \link #CFE_FS_Header_t::Length \c Length \endlink - Filled with the sizeof(CFE_FS_Header_t)
**      -# \link #CFE_FS_Header_t::SpacecraftID \c SpacecraftID \endlink - Filled with the Spacecraft ID
**      -# \link #CFE_FS_Header_t::ProcessorID \c ProcessorID \endlink - Filled with the Processor ID
**      -# \link #CFE_FS_Header_t::ApplicationID \c ApplicationID \endlink -  Filled with the Application ID
**      -# \link #CFE_FS_Header_t::TimeSeconds \c TimeSeconds \endlink - Filled with the Time, in seconds, as obtained by #CFE_TIME_GetTime
**      -# \link #CFE_FS_Header_t::TimeSubSeconds \c TimeSubSeconds \endlink - Filled with the Time, subseconds, as obtained by #CFE_TIME_GetTime
**        
**        
** \par Assumptions, External Events, and Notes:
**        -# The File has already been successfully opened using #OS_open and
**           the caller has a legitimate File Descriptor.
**        -# The \c SubType field has been filled appropriately by the Application.
**        -# The \c Description field has been filled appropriately by the Application.
**
** \param[in] FileDes File Descriptor obtained from a previous call to #OS_open
**                    that is associated with the file whose header is to be read.
**
** \param[in] Hdr     Pointer to a variable of type #CFE_FS_Header_t that will be
**                    filled with the contents of the Standard cFE File Header.
**
** \param[out] *Hdr   Contents of the Standard cFE File Header for the specified file.
**
** \returns
** \retstmt Any of the return codes specified for #OS_lseek or #OS_write       \endstmt
** \endreturns
**
** \sa #CFE_FS_ReadHeader
**
******************************************************************************/
    pub fn CFE_FS_WriteHeader(FileDes: int32, Hdr: *mut CFE_FS_Header_t)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Modifies the Time Stamp field in the Standard cFE File Header for the specified file
**
** \par Description
**        This API will modify the \link #CFE_FS_Header_t::TimeSeconds timestamp \endlink found
**        in the Standard cFE File Header of the specified file.  The timestamp will be replaced
**        with the time specified by the caller.
**
** \par Assumptions, External Events, and Notes:
**        -# The File has already been successfully opened using #OS_open and
**           the caller has a legitimate File Descriptor.
**        -# The \c NewTimestamp field has been filled appropriately by the Application.
**
** \param[in] FileDes File Descriptor obtained from a previous call to #OS_open
**                    that is associated with the file whose header is to be read.
**
** \param[in] NewTimestamp A #CFE_TIME_SysTime_t data structure containing the desired time
**                         to be put into the file's Standard cFE File Header.
**
** \returns
** \retstmt Any of the return codes specified for #OS_lseek or #OS_write   \endstmt
** \endreturns
**
** \sa
**               
******************************************************************************/
    pub fn CFE_FS_SetTimestamp(FileDes: int32,
                               NewTimestamp: CFE_TIME_SysTime_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Determines if a file is a Gzip/compressed file.
**
** \par Description
**        This API will check the filename and return TRUE if the file is 
**        a gzip file. The check is currently based on the filename, so the 
**        zipped files should use the ".gz" extention. 
**
** \par Assumptions, External Events, and Notes:
**        -# A gzipped file will use the ".gz" filename extention.
**
** \param[in] FileName The name of the file.
**
** \returns
** \retstmt TRUE if the file has the ".gz" extention and FALSE otherwise.   \endstmt
** \endreturns
**
** \sa
**               
******************************************************************************/
    pub fn CFE_FS_IsGzFile(FileName: *const ::std::os::raw::c_char)
     -> boolean;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Extracts the filename from a unix style path and filename string.
**
** \par Description
**        This API will take the original unix path/filename combination and 
**        extract the base filename. Example: Given the path/filename : "/cf/apps/myapp.o.gz"
**        this function will return the filename: "myapp.o.gz".
**
** \par Assumptions, External Events, and Notes:
**        -# The paths and filenames used here are the standard unix style 
**            filenames separated by "/" characters.
**        -# The extracted filename is no longer than #OS_MAX_PATH_LEN 
**
** \param[in] OriginalPath The original path.
** \param[out] FileNameOnly The filename that is extracted from the path.
**
** \returns
** \retstmt CFE_SUCCESS if the filename was extracted from the path  \endstmt
** \endreturns
**
** \sa
**               
******************************************************************************/
    pub fn CFE_FS_ExtractFilenameFromPath(OriginalPath:
                                              *const ::std::os::raw::c_char,
                                          FileNameOnly:
                                              *mut ::std::os::raw::c_char)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Decompresses the source file to the destination file.
**
** \par Description
**        This API will decompress the source file to the file specified by
**        the destination file. The file must be compressed using the "gzip"
**        utility. This utility is available on most unix workstations, Mac OS X, 
**        Cygwin, and MinGW for Windows. More information can be found at
**         http://www.gzip.org/
**
** \par Assumptions, External Events, and Notes:
**        -# The paths and filenames used here are cfe compliant file names.
**        -# The source file is compressed with the "gzip" utility.
**        -# The destination file does not exist, or can be overwritten. 
**
** \param[in] SourceFile The "gzipped" file to decompress.
** \param[out] DestinationFile The path/filename to write the decompressed or
**             "gunzipped" file to.
**
** \returns
** \retstmt CFE_SUCCESS if the file was decompressed sucessfully.  \endstmt
** \endreturns
**
** \sa
**               
******************************************************************************/
    pub fn CFE_FS_Decompress(SourceFile: *const ::std::os::raw::c_char,
                             DestinationFile: *const ::std::os::raw::c_char)
     -> int32;
}
/******************  Data Type Definitions *********************/
pub type CFE_TBL_CallbackFuncPtr_t =
    ::std::option::Option<unsafe extern "C" fn(TblPtr:
                                                   *mut ::std::os::raw::c_void)
                              -> int32>;
pub type CFE_TBL_Handle_t = int16;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CFE_TBL_SrcEnum_t { CFE_TBL_SRC_FILE = 0, CFE_TBL_SRC_ADDRESS = 1, }
#[repr(C)]
pub struct CFE_TBL_Info_t {
    /**< \brief Size, in bytes, of Table */
    pub Size: uint32,
    /**< \brief Number of Apps with access to the table */
    pub NumUsers: uint32,
    /**< \brief File creation time from last file loaded into table */
    pub FileCreateTimeSecs: uint32,
    /**< \brief File creation time from last file loaded into table */
    pub FileCreateTimeSubSecs: uint32,
    /**< \brief Most recently calculated CRC by TBL services on table contents */
    pub Crc: uint32,
    /**< \brief Time when Table was last updated */
    pub TimeOfLastUpdate: CFE_TIME_SysTime_t,
    /**< \brief Flag indicating whether table has been loaded once or not */
    pub TableLoadedOnce: boolean,
    /**< \brief Flag indicating Table is NOT to be loaded */
    pub DumpOnly: boolean,
    /**< \brief Flag indicating Table has a dedicated inactive buffer */
    pub DblBuffered: boolean,
    /**< \brief Flag indicating Table address was defined by Owner Application */
    pub UserDefAddr: boolean,
    /**< \brief Flag indicating Table contents are maintained in a CDS */
    pub Critical: boolean,
    /**< \brief Filename of last file loaded into table */
    pub LastFileLoaded: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_Info_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_Info_t>() , 100usize , concat ! (
               "Size of: " , stringify ! ( CFE_TBL_Info_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_Info_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_Info_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) . Size as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( Size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) . NumUsers as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( NumUsers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) . FileCreateTimeSecs
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( FileCreateTimeSecs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) .
                FileCreateTimeSubSecs as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( FileCreateTimeSubSecs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) . Crc as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( Crc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) . TimeOfLastUpdate as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( TimeOfLastUpdate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) . TableLoadedOnce as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( TableLoadedOnce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) . DumpOnly as * const
                _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( DumpOnly ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) . DblBuffered as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( DblBuffered ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) . UserDefAddr as *
                const _ as usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( UserDefAddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) . Critical as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( Critical ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_Info_t ) ) . LastFileLoaded as *
                const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_Info_t ) , "::"
                , stringify ! ( LastFileLoaded ) ));
}
extern "C" {
    /*************************** Function Prototypes ******************************/
/**
** \brief Register a table with cFE to obtain Table Management Services
**
** \par Description
**          When an application is created and initialized, it is responsible for creating its table images via 
**          the TBL API.  The application must inform the Table Service of the table name, table size and selection 
**          of optional table features.
**
** \par Assumptions, External Events, and Notes:
**          Note: This function call can block.  Therefore, interrupt service routines should NOT create 
**                their own tables.  An application should create any table(s) and provide the handle(s) 
**                to the interrupt service routine.
**
** \param[in] TblHandlePtr         a pointer to a #CFE_TBL_Handle_t type variable that will be assigned the 
**                                 table's handle.  The table handle is required for other API calls when 
**                                 accessing the data contained in the table.
**
** \param[in] Name                 The application-specific name.  This name will be combined with the name of the 
**                                 application to produce a processor specific name of the form 
**                                 "ApplicationName.TableName".  The processor specific name will be used in commands 
**                                 for modifying or viewing the contents of the table.
**
** \param[in] Size                 The size, in bytes, of the table to be created.  This is the size that will be 
**                                 allocated as a shared memory resource between the Table Management Service and 
**                                 the calling application.
**
** \param[in] TblOptionFlags       Flag bits indicating selected options for table.  A bitwise OR of the following 
**                                 option flags:
**                                 \arg #CFE_TBL_OPT_DEFAULT     - The default setting for table options is a 
**                                                                 combination of #CFE_TBL_OPT_SNGL_BUFFER and 
**                                                                 #CFE_TBL_OPT_LOAD_DUMP.  See below for a 
**                                                                 description of these two options.  This option 
**                                                                 is mutually exclusive with the 
**                                                                 #CFE_TBL_OPT_DBL_BUFFER, #CFE_TBL_OPT_DUMP_ONLY 
**                                                                 and #CFE_TBL_OPT_USR_DEF_ADDR options.
**                                 \arg #CFE_TBL_OPT_SNGL_BUFFER - When this option is selected, the table will use 
**                                                                 a shared session table for performing table 
**                                                                 modifications and a memory copy from the session 
**                                                                 table to the "active" table buffer will occur 
**                                                                 when the table is updated.  This is the preferred 
**                                                                 option since it will minimize memory usage.  
**                                                                 This option is mutually exclusive with the 
**                                                                 #CFE_TBL_OPT_DBL_BUFFER option
**                                 \arg #CFE_TBL_OPT_DBL_BUFFER  - When this option is selected, two instances of 
**                                                                 the table are created.   One is considered the 
**                                                                 "active" table and the other the "inactive" table.
**                                                                 Whenever table modifications occur, they do not 
**                                                                 require the use of a common session table.  
**                                                                 Modifications occur in the "inactive" buffer.  
**                                                                 Then, when it is time to update the table, 
**                                                                 the pointer to the "active" table is changed to 
**                                                                 point to the "inactive" buffer thus making it 
**                                                                 the new "active" buffer.  This feature is most 
**                                                                 useful for time critical applications (ie - 
**                                                                 interrupt service routines, etc).  This option is 
**                                                                 mutually exclusive with the 
**                                                                 #CFE_TBL_OPT_SNGL_BUFFER and #CFE_TBL_OPT_DEFAULT 
**                                                                 option.
**                                 \arg #CFE_TBL_OPT_LOAD_DUMP   - When this option is selected, the Table Service 
**                                                                 is allowed to perform all operations on the 
**                                                                 specified table.  This option is mutually 
**                                                                 exclusive with the #CFE_TBL_OPT_DUMP_ONLY option.
**                                 \arg #CFE_TBL_OPT_DUMP_ONLY   - When this option is selected, the Table Service 
**                                                                 will not perform table loads to this table.  This 
**                                                                 does not prevent, however, a task from writing 
**                                                                 to the table via an address obtained with the 
**                                                                 #CFE_TBL_GetAddress API function.  This option is 
**                                                                 mutually exclusive with the #CFE_TBL_OPT_LOAD_DUMP
**                                                                 and #CFE_TBL_OPT_DEFAULT options. If the Application wishes
**                                                                 to specify their own block of memory as the Dump Only table,
**                                                                 they need to also include the #CFE_TBL_OPT_USR_DEF_ADDR option
**                                                                 explained below.
**                                 \arg #CFE_TBL_OPT_NOT_USR_DEF - When this option is selected, Table Services allocates
**                                                                 memory for the table and, in the case of a double buffered
**                                                                 table, it allocates the same amount of memory again for the
**                                                                 second buffer.  This option is mutually exclusive with
**                                                                 the #CFE_TBL_OPT_USR_DEF_ADDR option.
**                                 \arg #CFE_TBL_OPT_USR_DEF_ADDR- When this option is selected, the Table Service 
**                                                                 will not allocate memory for the table.  Table Services
**                                                                 will require the Application to identify the location of the
**                                                                 active table buffer via the #CFE_TBL_Load function. This 
**                                                                 option implies the #CFE_TBL_OPT_DUMP_ONLY and the 
**                                                                 #CFE_TBL_OPT_SNGL_BUFFER options and is mutually 
**                                                                 exclusive of the #CFE_TBL_OPT_DBL_BUFFER option.
**                                 \arg #CFE_TBL_OPT_CRITICAL-     When this option is selected, the Table Service 
**                                                                 will automatically allocate space in the Critical Data Store (CDS)
**                                                                 for the table and insure that the contents in the CDS are the same
**                                                                 as the contents of the currently active buffer for the table.
**                                                                 This option is mutually exclusive of the #CFE_TBL_OPT_USR_DEF_ADDR
**                                                                 and #CFE_TBL_OPT_DUMP_ONLY options.  It should also be noted that
**                                                                 the use of this option with double buffered tables will prevent
**                                                                 the update of the double buffered table from being quick and
**                                                                 it could be blocked.  Therefore, critical tables should not be
**                                                                 updated by Interrupt Service Routines.
**
** \param[in] TblValidationFuncPtr is a pointer to a function that will be executed in the context of the Table 
**                                 Management Service when the contents of a table need to be validated.  If set 
**                                 to NULL, then the Table Management Service will assume any data is valid.  If 
**                                 the value is not NULL, it must be a pointer to a function with the following 
**                                 prototype: <BR>
**                                 <B> int32 CallbackFunc(void *TblPtr);</B> <BR>
**                                 where  <BR>
**                                 <B>TblPtr </B> will be a pointer to the table data that is to be verified.  When the 
**                                 function returns #CFE_SUCCESS, the data is considered valid and ready for a commit.  
**                                 When the function returns a negative value, the data is considered invalid and an 
**                                 Event Message will be issued containing the returned value.  If the function should
**                                 return a positive number, the table is considered invalid and the return code is
**                                 considered invalid.  Validation functions \b must return either #CFE_SUCCESS or a negative
**                                 number (whose value is at the developer's discretion).  The validation function 
**                                 will be executed in the Application's context so that Event Messages describing the 
**                                 validation failure are possible from within the function.
**
** \param[out]  *TblHandlePtr      Handle used to identify table to cFE when performing Table operations.
**                                 This value is returned at the address specified by TblHandlePtr.
**
** \returns
** \retcode #CFE_SUCCESS                      \retdesc \copydoc CFE_SUCCESS                        \endcode
** \retcode #CFE_TBL_INFO_RECOVERED_TBL       \retdesc \copydoc CFE_TBL_INFO_RECOVERED_TBL         \endcode
** \retcode                                   \retdesc <BR><BR>                                    \endcode
** \retcode #CFE_TBL_ERR_DUPLICATE_DIFF_SIZE  \retdesc \copydoc CFE_TBL_ERR_DUPLICATE_DIFF_SIZE    \endcode
** \retcode #CFE_TBL_ERR_DUPLICATE_NOT_OWNED  \retdesc \copydoc CFE_TBL_ERR_DUPLICATE_NOT_OWNED    \endcode
** \retcode #CFE_TBL_ERR_REGISTRY_FULL        \retdesc \copydoc CFE_TBL_ERR_REGISTRY_FULL          \endcode
** \retcode #CFE_TBL_ERR_HANDLES_FULL         \retdesc \copydoc CFE_TBL_ERR_HANDLES_FULL           \endcode
** \retcode #CFE_TBL_ERR_INVALID_SIZE         \retdesc \copydoc CFE_TBL_ERR_INVALID_SIZE           \endcode
** \retcode #CFE_TBL_ERR_INVALID_NAME         \retdesc \copydoc CFE_TBL_ERR_INVALID_NAME           \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID           \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID             \endcode
** \retcode #CFE_ES_ERR_APPNAME               \retdesc \copydoc CFE_ES_ERR_APPNAME                 \endcode
** \retcode #CFE_ES_ERR_BUFFER                \retdesc \copydoc CFE_ES_ERR_BUFFER                  \endcode
** \endreturns
**
** \sa #CFE_TBL_Unregister, #CFE_TBL_Share
**/
    pub fn CFE_TBL_Register(TblHandlePtr: *mut CFE_TBL_Handle_t,
                            Name: *const ::std::os::raw::c_char, Size: uint32,
                            TblOptionFlags: uint16,
                            TblValidationFuncPtr: CFE_TBL_CallbackFuncPtr_t)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Obtain handle of table registered by another application
**
** \par Description
**        After a table has been created, other applications can gain access 
**        to that table via the table handle.  In order for two or more 
**        applications to share a table, the applications that do not create 
**        the table must obtain the handle using this function.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  TblHandlePtr  A pointer to a #CFE_TBL_Handle_t type variable 
**                           that will be assigned the table's handle.  The 
**                           table handle is required for other API calls 
**                           when accessing the data contained in the table.
**
** \param[in]  TblName       The processor specific name of the table.  It is important to note 
**                           that the processor specific table name is different from the table 
**                           name specified in the #CFE_TBL_Register API call.  The processor 
**                           specific table name includes the name of the application that created 
**                           the table.  The name would be of the form "ApplicationName.TableName".  
**                           An example of this would be "ACS.TamParams" for a table called "TamParams" 
**                           that was registered by the application called "ACS".
**
** \param[out] *TblHandlePtr Handle used to identify table to cFE when performing Table operations.
**                           This value is returned at the address specified by TblHandlePtr.
**
** \returns
** \retcode #CFE_SUCCESS              \retdesc \copydoc CFE_SUCCESS               \endcode
** \retcode                           \retdesc <BR><BR>                           \endcode
** \retcode #CFE_TBL_ERR_HANDLES_FULL \retdesc \copydoc CFE_TBL_ERR_HANDLES_FULL  \endcode
** \retcode #CFE_TBL_ERR_INVALID_NAME \retdesc \copydoc CFE_TBL_ERR_INVALID_NAME  \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID   \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID    \endcode
** \retcode #CFE_ES_ERR_APPNAME       \retdesc \copydoc CFE_ES_ERR_APPNAME        \endcode
** \retcode #CFE_ES_ERR_BUFFER        \retdesc \copydoc CFE_ES_ERR_BUFFER         \endcode
** \endreturns
**
** \sa #CFE_TBL_Unregister, #CFE_TBL_Register
**
******************************************************************************/
    pub fn CFE_TBL_Share(TblHandlePtr: *mut CFE_TBL_Handle_t,
                         TblName: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Unregister a previously registered table and free associated resources
**
** \par Description
**        When an application is being removed from the system, it should 
**        unregister those tables that it created.  The application should 
**        call this function as a part of its cleanup process.  The table 
**        will be removed from memory once all table addresses referencing 
**        it have been released.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] TblHandle Handle, previously obtained from #CFE_TBL_Register or #CFE_TBL_Share,
**                      that identifies the Table to be unregistered.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS                 \endcode
** \retcode                             \retdesc <BR><BR>                             \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID     \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID      \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS      \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS       \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE  \endcode
** \retcode #CFE_ES_ERR_APPNAME         \retdesc \copydoc CFE_ES_ERR_APPNAME          \endcode
** \retcode #CFE_ES_ERR_BUFFER          \retdesc \copydoc CFE_ES_ERR_BUFFER           \endcode
** \endreturns
**
** \sa #CFE_TBL_Share, #CFE_TBL_Register
** 
******************************************************************************/
    pub fn CFE_TBL_Unregister(TblHandle: CFE_TBL_Handle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Load a specified table with data from specified source
**
** \par Description
**        Once an application has created a table (#CFE_TBL_Register), it must 
**        provide the values that initialize the contents of that table.  The 
**        application accomplishes this with one of two different TBL API calls.  
**        This function call initializes the table with values that are held 
**        in a data structure.  
**
** \par Assumptions, External Events, and Notes:
**        This function call can block.  Therefore, interrupt service routines 
**        should NOT initialize their own tables.  An application should initialize 
**        any table(s) prior to providing the handle(s) to the interrupt service routine.
**
** \param[in] TblHandle  Handle, previously obtained from #CFE_TBL_Register or #CFE_TBL_Share, that
**                       identifies the Table to be loaded.
**
** \param[in] SrcType    Flag indicating the nature of the given \c SrcDataPtr below.
**                       This value can be any one of the following:
**                          \arg #CFE_TBL_SRC_FILE    - \copydoc CFE_TBL_SRC_FILE
**                          \arg #CFE_TBL_SRC_ADDRESS - \copydoc CFE_TBL_SRC_ADDRESS 
**                                                      
** \param[in] SrcDataPtr Pointer to either a character string specifying a filename or
**                       a memory address of a block of binary data to be loaded into a table or,
**                       if the table was registered with the #CFE_TBL_OPT_USR_DEF_ADDR option,
**                       the address of the active table buffer.
**
** \returns
** \retcode #CFE_SUCCESS                   \retdesc \copydoc CFE_SUCCESS                   \endcode
** \retcode #CFE_TBL_WARN_SHORT_FILE       \retdesc \copydoc CFE_TBL_WARN_SHORT_FILE       \endcode
** \retcode #CFE_TBL_WARN_PARTIAL_LOAD     \retdesc \copydoc CFE_TBL_WARN_PARTIAL_LOAD     \endcode
** \retcode                                \retdesc <BR><BR>                               \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID        \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID        \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS         \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS         \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE    \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE    \endcode
** \retcode #CFE_ES_ERR_APPNAME            \retdesc \copydoc CFE_ES_ERR_APPNAME            \endcode
** \retcode #CFE_ES_ERR_BUFFER             \retdesc \copydoc CFE_ES_ERR_BUFFER             \endcode
** \retcode #CFE_TBL_ERR_DUMP_ONLY         \retdesc \copydoc CFE_TBL_ERR_DUMP_ONLY         \endcode
** \retcode #CFE_TBL_ERR_ILLEGAL_SRC_TYPE  \retdesc \copydoc CFE_TBL_ERR_ILLEGAL_SRC_TYPE  \endcode
** \retcode #CFE_TBL_ERR_LOAD_IN_PROGRESS  \retdesc \copydoc CFE_TBL_ERR_LOAD_IN_PROGRESS  \endcode
** \retcode #CFE_TBL_ERR_NO_BUFFER_AVAIL   \retdesc \copydoc CFE_TBL_ERR_NO_BUFFER_AVAIL   \endcode
** \retcode #CFE_TBL_ERR_FILE_NOT_FOUND    \retdesc \copydoc CFE_TBL_ERR_FILE_NOT_FOUND    \endcode
** \retcode #CFE_TBL_ERR_FILE_TOO_LARGE    \retdesc \copydoc CFE_TBL_ERR_FILE_TOO_LARGE    \endcode
** \retcode #CFE_TBL_ERR_BAD_CONTENT_ID    \retdesc \copydoc CFE_TBL_ERR_BAD_CONTENT_ID    \endcode
** \retcode #CFE_TBL_ERR_PARTIAL_LOAD      \retdesc \copydoc CFE_TBL_ERR_PARTIAL_LOAD      \endcode
** \endreturns
**
** \sa #CFE_TBL_Update, #CFE_TBL_Validate, #CFE_TBL_Manage 
**
******************************************************************************/
    pub fn CFE_TBL_Load(TblHandle: CFE_TBL_Handle_t,
                        SrcType: CFE_TBL_SrcEnum_t,
                        SrcDataPtr: *const ::std::os::raw::c_void) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Update contents of a specified table, if an update is pending
**
** \par Description
**        An application is \b required to perform a periodic check for an update 
**        for all the tables that it creates.  Typically, the application that 
**        created the table would call this function at the start or conclusion 
**        of any routine processing cycle or at regular intervals.  To determine 
**        whether an update is pending prior to making this call, the Application 
**        can use the #CFE_TBL_GetStatus API first.  If a table update is pending, 
**        it will take place during this function call.
** 
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] TblHandle  Handle, previously obtained from #CFE_TBL_Register or #CFE_TBL_Share, that
**                       identifies the Table to be updated.
**                                      
** \returns
** \retcode #CFE_SUCCESS                    \retdesc \copydoc CFE_SUCCESS                     \endcode
** \retcode #CFE_TBL_INFO_NO_UPDATE_PENDING \retdesc \copydoc CFE_TBL_INFO_NO_UPDATE_PENDING  \endcode
** \retcode                                 \retdesc <BR><BR>                                 \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID         \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID          \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS          \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS           \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE     \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE      \endcode
** \retcode #CFE_ES_ERR_APPNAME             \retdesc \copydoc CFE_ES_ERR_APPNAME              \endcode
** \retcode #CFE_ES_ERR_BUFFER              \retdesc \copydoc CFE_ES_ERR_BUFFER               \endcode
** \endreturns
**
** \sa #CFE_TBL_Load, #CFE_TBL_Validate, #CFE_TBL_Manage
**
******************************************************************************/
    pub fn CFE_TBL_Update(TblHandle: CFE_TBL_Handle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Obtain the current address of the contents of the specified table
**
** \par Description
**        When a table has been created and initialized, it is available to 
**        any application that can identify it with its unique handle.  In 
**        order to view the data contained in the table, an application must 
**        call this function or #CFE_TBL_GetAddresses.
**
** \par Assumptions, External Events, and Notes:
**        -# This call can be a blocking call when the table is not double buffered 
**           and is shared with another application of lower priority that just happens 
**           to be in the middle of a table update of the specific table.  If this occurs, 
**           the application performing the table update will automatically have its 
**           priority elevated in order to release the resource as soon as possible.
**        -# An application must always release the returned table address using the 
**           #CFE_TBL_ReleaseAddress or #CFE_TBL_ReleaseAddresses function prior to 
**           either a #CFE_TBL_Update call or any blocking call (e.g. - pending on software 
**           bus message, etc).  Table updates cannot occur while table addresses have not 
**           been released.
**
** \param[in]  TblPtr     The address of a pointer that will be loaded with the address of 
**                        the first byte of the table.  This pointer can then be typecast 
**                        by the calling application to the appropriate table data structure.
**
** \param[in]  TblHandle  Handle, previously obtained from #CFE_TBL_Register or #CFE_TBL_Share, that
**                        identifies the Table whose address is to be returned.
**
** \param[out] *TblPtr    Address of the first byte of data associated with the specified table.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS                 \endcode
** \retcode #CFE_TBL_INFO_UPDATED       \retdesc \copydoc CFE_TBL_INFO_UPDATED        \endcode
** \retcode                             \retdesc <BR><BR>                             \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID     \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID      \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS      \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS       \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE  \endcode
** \retcode #CFE_ES_ERR_APPNAME         \retdesc \copydoc CFE_ES_ERR_APPNAME          \endcode
** \retcode #CFE_ES_ERR_BUFFER          \retdesc \copydoc CFE_ES_ERR_BUFFER           \endcode
** \retcode #CFE_TBL_ERR_UNREGISTERED   \retdesc \copydoc CFE_TBL_ERR_UNREGISTERED    \endcode
** \retcode #CFE_TBL_ERR_NEVER_LOADED   \retdesc \copydoc CFE_TBL_ERR_NEVER_LOADED    \endcode
** \endreturns
**
** \sa #CFE_TBL_ReleaseAddress, #CFE_TBL_GetAddresses, #CFE_TBL_ReleaseAddresses
**
******************************************************************************/
    pub fn CFE_TBL_GetAddress(TblPtr: *mut *mut ::std::os::raw::c_void,
                              TblHandle: CFE_TBL_Handle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Release previously obtained pointer to the contents of the specified table
**
** \par Description
**        Each application is \b required to release a table address obtained through 
**        the #CFE_TBL_GetAddress function.
**
** \par Assumptions, External Events, and Notes:
**        An application must always release the returned table address using the 
**        #CFE_TBL_ReleaseAddress function prior to either a #CFE_TBL_Update call 
**        or any blocking call (e.g. - pending on software bus message, etc).  
**        Table updates cannot occur while table addresses have not been released.
**
** \param[in] TblHandle  Handle, previously obtained from #CFE_TBL_Register or #CFE_TBL_Share, that
**                       identifies the Table whose address is to be released.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS                 \endcode
** \retcode #CFE_TBL_INFO_UPDATED       \retdesc \copydoc CFE_TBL_INFO_UPDATED        \endcode
** \retcode                             \retdesc <BR><BR>                             \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID     \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID      \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS      \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS       \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE  \endcode
** \retcode #CFE_ES_ERR_APPNAME         \retdesc \copydoc CFE_ES_ERR_APPNAME          \endcode
** \retcode #CFE_ES_ERR_BUFFER          \retdesc \copydoc CFE_ES_ERR_BUFFER           \endcode
** \retcode #CFE_TBL_ERR_NEVER_LOADED   \retdesc \copydoc CFE_TBL_ERR_NEVER_LOADED    \endcode
** \endreturns
**
** \sa #CFE_TBL_GetAddress, #CFE_TBL_GetAddresses, #CFE_TBL_ReleaseAddresses
**
******************************************************************************/
    pub fn CFE_TBL_ReleaseAddress(TblHandle: CFE_TBL_Handle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Obtain the current addresses of an array of specified tables
**
** \par Description
**        When a table has been created and initialized, it is available to 
**        any application that can identify it with its unique handle.  In 
**        order to view the data contained in the table, an application must 
**        call this function or #CFE_TBL_GetAddresses.
**
** \par Assumptions, External Events, and Notes:
**        -# This call can be a blocking call when the table is not double buffered 
**           and is shared with another application of lower priority that just happens 
**           to be in the middle of a table update of the specific table.  If this occurs, 
**           the application performing the table update will automatically have its 
**           priority elevated in order to release the resource as soon as possible.
**        -# An application must always release the returned table address using the 
**           #CFE_TBL_ReleaseAddress or #CFE_TBL_ReleaseAddresses function prior to 
**           either a #CFE_TBL_Update call or any blocking call (e.g. - pending on software 
**           bus message, etc).  Table updates cannot occur while table addresses have not 
**           been released.
**
** \param[in] TblPtrs    Array of Pointers to variables that calling Application
**                       wishes to hold the start addresses of the Tables.
**
** \param[in] NumTables  Size of TblPtrs and TblHandles arrays.
**
** \param[in] TblHandles Array of Table Handles, previously obtained from #CFE_TBL_Register or #CFE_TBL_Share,
**                       of those tables whose start addresses are to be obtained.
**
** \param[out] *TblPtrs  Array of addresses of the first byte of data associated with the
**                       specified tables.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS                \endcode
** \retcode #CFE_TBL_INFO_UPDATED       \retdesc \copydoc CFE_TBL_INFO_UPDATED       \endcode
** \retcode                             \retdesc <BR><BR>                            \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID     \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID     \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS      \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS      \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE \endcode
** \retcode #CFE_ES_ERR_APPNAME         \retdesc \copydoc CFE_ES_ERR_APPNAME         \endcode
** \retcode #CFE_ES_ERR_BUFFER          \retdesc \copydoc CFE_ES_ERR_BUFFER          \endcode
** \retcode #CFE_TBL_ERR_UNREGISTERED   \retdesc \copydoc CFE_TBL_ERR_UNREGISTERED   \endcode
** \retcode #CFE_TBL_ERR_NEVER_LOADED   \retdesc \copydoc CFE_TBL_ERR_NEVER_LOADED   \endcode
** \endreturns
**
** \sa #CFE_TBL_GetAddress, #CFE_TBL_ReleaseAddress, #CFE_TBL_ReleaseAddresses
**
******************************************************************************/
    pub fn CFE_TBL_GetAddresses(TblPtrs:
                                    *mut *mut *mut ::std::os::raw::c_void,
                                NumTables: uint16,
                                TblHandles: *const CFE_TBL_Handle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Release the addresses of an array of specified tables
**
** \par Description
**        Each application is \b required to release a table address obtained through 
**        the #CFE_TBL_GetAddress function.
**
** \par Assumptions, External Events, and Notes:
**        An application must always release the returned table address using the 
**        #CFE_TBL_ReleaseAddress function prior to either a #CFE_TBL_Update call 
**        or any blocking call (e.g. - pending on software bus message, etc).  
**        Table updates cannot occur while table addresses have not been released.
**
** \param[in] NumTables  Size of TblHandles array.
**
** \param[in] TblHandles Array of Table Handles, previously obtained from #CFE_TBL_Register or #CFE_TBL_Share,
**                       of those tables whose start addresses are to be released.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS                 \endcode
** \retcode #CFE_TBL_INFO_UPDATED       \retdesc \copydoc CFE_TBL_INFO_UPDATED        \endcode
** \retcode                             \retdesc <BR><BR>                             \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID     \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID      \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS      \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS       \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE  \endcode
** \retcode #CFE_ES_ERR_APPNAME         \retdesc \copydoc CFE_ES_ERR_APPNAME          \endcode
** \retcode #CFE_ES_ERR_BUFFER          \retdesc \copydoc CFE_ES_ERR_BUFFER           \endcode
** \retcode #CFE_TBL_ERR_NEVER_LOADED   \retdesc \copydoc CFE_TBL_ERR_NEVER_LOADED    \endcode
** \endreturns
**
** \sa #CFE_TBL_GetAddress, #CFE_TBL_ReleaseAddress, #CFE_TBL_GetAddresses
**
******************************************************************************/
    pub fn CFE_TBL_ReleaseAddresses(NumTables: uint16,
                                    TblHandles: *const CFE_TBL_Handle_t)
     -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Perform steps to validate the contents of a table image.
**
** \par Description
**        An application is \b required to perform a periodic check for an update 
**        or a validation request for all the tables that it creates.  Typically, 
**        the application that created the table would call this function at the 
**        start or conclusion of any routine processing cycle.  To determine whether 
**        a validation request is pending prior to making this call, the Application 
**        can use the #CFE_TBL_GetStatus API first.  If a table validation is pending, 
**        the Application would call this function to perform the necessary actions.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] TblHandle  Handle, previously obtained from #CFE_TBL_Register or #CFE_TBL_Share, that
**                       identifies the Table to be managed.
**
** \returns
** \retcode #CFE_SUCCESS                        \retdesc \copydoc CFE_SUCCESS                        \endcode
** \retcode #CFE_TBL_INFO_NO_VALIDATION_PENDING \retdesc \copydoc CFE_TBL_INFO_NO_VALIDATION_PENDING \endcode
** \retcode                                     \retdesc <BR><BR>                                    \endcode
** \retcode #CFE_ES_ERR_APPNAME                 \retdesc \copydoc CFE_ES_ERR_APPNAME                 \endcode
** \retcode #CFE_ES_ERR_BUFFER                  \retdesc \copydoc CFE_ES_ERR_BUFFER                  \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID             \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID             \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS              \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS              \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE         \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE         \endcode
** \endreturns
**
** \sa #CFE_TBL_Update, #CFE_TBL_Manage, #CFE_TBL_Load
**
******************************************************************************/
    pub fn CFE_TBL_Validate(TblHandle: CFE_TBL_Handle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Perform standard operations to maintain a table.
**
** \par Description
**        An application is \b required to perform a periodic check for an update 
**        or a validation request for all the tables that it creates.  Typically, 
**        the application that created the table would call this function at the 
**        start or conclusion of any routine processing cycle.  If a table update 
**        or validation request is pending, this function would perform either or 
**        both before returning.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] TblHandle  Handle, previously obtained from #CFE_TBL_Register or #CFE_TBL_Share, that
**                       identifies the Table to be managed.
**
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS                 \endcode
** \retcode #CFE_TBL_INFO_UPDATED       \retdesc \copydoc CFE_TBL_INFO_UPDATED        \endcode
** \retcode                             \retdesc <BR><BR>                             \endcode
** \retcode #CFE_ES_ERR_APPNAME         \retdesc \copydoc CFE_ES_ERR_APPNAME          \endcode
** \retcode #CFE_ES_ERR_BUFFER          \retdesc \copydoc CFE_ES_ERR_BUFFER           \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID     \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID      \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS      \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS       \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE  \endcode
** \endreturns
**
** \sa #CFE_TBL_Update, #CFE_TBL_Validate, #CFE_TBL_Load, #CFE_TBL_DumpToBuffer
**
******************************************************************************/
    pub fn CFE_TBL_Manage(TblHandle: CFE_TBL_Handle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Obtain current status of pending actions for a table.
**
** \par Description
**        An application is \b required to perform a periodic check for an update 
**        or a validation request for all the tables that it creates.  Typically, 
**        the application that created the table would call this function at the 
**        start or conclusion of any routine processing cycle.  If a table update 
**        or validation request is pending, the Application should follow up with 
**        a call to #CFE_TBL_Update or #CFE_TBL_Validate respectively.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in] TblHandle  Handle, previously obtained from #CFE_TBL_Register or #CFE_TBL_Share, that
**                       identifies the Table to be managed.
**
** \returns
** \retcode #CFE_SUCCESS                     \retdesc \copydoc CFE_SUCCESS                      \endcode
** \retcode #CFE_TBL_INFO_UPDATE_PENDING     \retdesc \copydoc CFE_TBL_INFO_UPDATE_PENDING      \endcode
** \retcode #CFE_TBL_INFO_VALIDATION_PENDING \retdesc \copydoc CFE_TBL_INFO_VALIDATION_PENDING  \endcode
** \retcode #CFE_TBL_INFO_DUMP_PENDING       \retdesc \copydoc CFE_TBL_INFO_DUMP_PENDING        \endcode
** \retcode                                  \retdesc <BR><BR>                                  \endcode
** \retcode #CFE_ES_ERR_APPNAME              \retdesc \copydoc CFE_ES_ERR_APPNAME               \endcode
** \retcode #CFE_ES_ERR_BUFFER               \retdesc \copydoc CFE_ES_ERR_BUFFER                \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID          \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID           \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS           \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS            \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE      \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE       \endcode
** \endreturns
**
** \sa #CFE_TBL_Manage, #CFE_TBL_Update, #CFE_TBL_Validate, #CFE_TBL_GetInfo
**
******************************************************************************/
    pub fn CFE_TBL_GetStatus(TblHandle: CFE_TBL_Handle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Obtain characteristics/information of/about a specified table.
**
** \par Description
**        This API provides the registry information associated with the specified
**        table.  The function fills the given data structure with the data found
**        in the Table Registry.
**
** \par Assumptions, External Events, and Notes:
**          None
**
** \param[in]  TblInfoPtr    A pointer to a CFE_TBL_Info_t data structure that is to be populated
**                           with table characteristics and information.
** 
** \param[in]  TblName       The processor specific name of the table.  It is important to note 
**                           that the processor specific table name is different from the table 
**                           name specified in the #CFE_TBL_Register API call.  The processor 
**                           specific table name includes the name of the application that created 
**                           the table.  The name would be of the form "ApplicationName.TableName".  
**                           An example of this would be "ACS.TamParams" for a table called "TamParams" 
**                           that was registered by the application called "ACS".
**
** \param[out] *TblInfoPtr   Description of the tables characteristics and registry information stored in
**                           the #CFE_TBL_Info_t data structure format.
**
** \returns
** \retcode #CFE_SUCCESS                     \retdesc \copydoc CFE_SUCCESS               \endcode      
** \retcode                                  \retdesc <BR><BR>                           \endcode
** \retcode #CFE_TBL_ERR_INVALID_NAME        \retdesc \copydoc CFE_TBL_ERR_INVALID_NAME  \endcode
** \endreturns
**
** \sa #CFE_TBL_GetStatus
**
******************************************************************************/
    pub fn CFE_TBL_GetInfo(TblInfoPtr: *mut CFE_TBL_Info_t,
                           TblName: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Copies the contents of a Dump Only Table to a shared buffer
**
** \par Description
**        Copies contents of a Dump Only table to a shared buffer so that it
**        can be written to a file by the Table Services routine.  This function
**        is called by the Application that owns the table in response to a #CFE_TBL_INFO_DUMP_PENDING
**        status obtained via #CFE_TBL_GetStatus.
**
** \par Assumptions, External Events, and Notes:
**        -# If the table does not have a dump pending status, nothing will occur (no error, no dump)
**        -# Applications may wish to use this function in lieu of #CFE_TBL_Manage for their Dump Only tables
**
** \param[in]  TblHandle      Handle of Table to be dumped.
** 
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS                 \endcode
** \retcode                             \retdesc <BR><BR>                             \endcode
** \retcode #CFE_ES_ERR_APPNAME         \retdesc \copydoc CFE_ES_ERR_APPNAME          \endcode
** \retcode #CFE_ES_ERR_BUFFER          \retdesc \copydoc CFE_ES_ERR_BUFFER           \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID     \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID      \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS      \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS       \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE  \endcode
** \endreturns
**
** \sa #CFE_TBL_Manage
**
******************************************************************************/
    pub fn CFE_TBL_DumpToBuffer(TblHandle: CFE_TBL_Handle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Notify cFE Table Services that table contents have been modified by the Application
**
** \par Description
**        This API notifies Table Services that the contents of the specified table has been
**        modified by the Application.  This notification is important when a table has been
**        registered as "Critical" because Table Services can then update the contents of the
**        table kept in the Critical Data Store.
**
** \par Assumptions, External Events, and Notes:
**        None
**
** \param[in]  TblHandle      Handle of Table that was modified.
** 
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS                 \endcode
** \retcode                             \retdesc <BR><BR>                             \endcode
** \retcode #CFE_ES_ERR_APPNAME         \retdesc \copydoc CFE_ES_ERR_APPNAME          \endcode
** \retcode #CFE_ES_ERR_BUFFER          \retdesc \copydoc CFE_ES_ERR_BUFFER           \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID     \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID      \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS      \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS       \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE  \endcode
** \endreturns
**
** \sa #CFE_TBL_Manage
**
******************************************************************************/
    pub fn CFE_TBL_Modified(TblHandle: CFE_TBL_Handle_t) -> int32;
}
extern "C" {
    /*****************************************************************************/
/**
** \brief Instruct cFE Table Services to notify Application via message when table requires management
**
** \par Description
**        This API instructs Table Services to send a message to the calling Application
**        whenever the specified table requires management by the application.  This feature
**        allows applications to avoid polling table services via the #CFE_TBL_Manage call
**        to determine whether a table requires updates, validation, etc.  This API should
**        be called following the #CFE_TBL_Register API whenever the owning application requires
**        this feature.
**
** \par Assumptions, External Events, and Notes:
**        - Only the application that owns the table is allowed to register a notification message
**
** \param[in]  TblHandle      Handle of Table with which the message should be associated.
** 
** \param[in]  MsgId          Message ID to be used in notification message sent by Table Services.
** 
** \param[in]  CommandCode    Command Code value to be placed in secondary header of message 
**                            sent by Table Services.
** 
** \param[in]  Parameter      Application defined value to be passed as a parameter in the 
**                            message sent by Table Services.  Suggested use includes an application's
**                            table index that allows the same MsgId and Command Code to be used for
**                            all table management notifications.
** 
** \returns
** \retcode #CFE_SUCCESS                \retdesc \copydoc CFE_SUCCESS                 \endcode
** \retcode                             \retdesc <BR><BR>                             \endcode
** \retcode #CFE_ES_ERR_APPNAME         \retdesc \copydoc CFE_ES_ERR_APPNAME          \endcode
** \retcode #CFE_ES_ERR_BUFFER          \retdesc \copydoc CFE_ES_ERR_BUFFER           \endcode
** \retcode #CFE_TBL_ERR_BAD_APP_ID     \retdesc \copydoc CFE_TBL_ERR_BAD_APP_ID      \endcode
** \retcode #CFE_TBL_ERR_NO_ACCESS      \retdesc \copydoc CFE_TBL_ERR_NO_ACCESS       \endcode
** \retcode #CFE_TBL_ERR_INVALID_HANDLE \retdesc \copydoc CFE_TBL_ERR_INVALID_HANDLE  \endcode
** \endreturns
**
** \sa #CFE_TBL_Register
**
******************************************************************************/
    pub fn CFE_TBL_NotifyByMessage(TblHandle: CFE_TBL_Handle_t, MsgId: uint32,
                                   CommandCode: uint16, Parameter: uint32)
     -> int32;
}
/********************************/
/**
** \brief Generic "no arguments" command
**
** This command structure is used for commands that do not have any parameters.
** This includes:
** -# The Housekeeping Request Message
** -# The No-Op Command (For details, see #CFE_ES_NOOP_CC)
** -# The Reset Counters Command (For details, see #CFE_ES_RESET_CC)
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_NoArgsCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_NoArgsCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_NoArgsCmd_t>() , 8usize , concat !
               ( "Size of: " , stringify ! ( CFE_ES_NoArgsCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_NoArgsCmd_t>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_ES_NoArgsCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_NoArgsCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_NoArgsCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
}
impl Clone for CFE_ES_NoArgsCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Reset cFE Command
**
** For command details, see #CFE_ES_RESTART_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_RestartCmd_Payload_t {
    /**< \brief #CFE_ES_PROCESSOR_RESET=Processor Reset
                                                                or #CFE_ES_POWERON_RESET=Power-On Reset        */
    pub RestartType: uint16,
}
#[test]
fn bindgen_test_layout_CFE_ES_RestartCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_RestartCmd_Payload_t>() , 2usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_ES_RestartCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_RestartCmd_Payload_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_RestartCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_RestartCmd_Payload_t ) ) .
                RestartType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_RestartCmd_Payload_t ) , "::" , stringify ! (
                RestartType ) ));
}
impl Clone for CFE_ES_RestartCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_RestartCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_RestartCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_RestartCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_RestartCmd_t>() , 10usize , concat
               ! ( "Size of: " , stringify ! ( CFE_ES_RestartCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_RestartCmd_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_RestartCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_RestartCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_RestartCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_RestartCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_RestartCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_ES_RestartCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Shell Command
**
** For command details, see #CFE_ES_SHELL_CMD_CC
**
**/
#[repr(C)]
pub struct CFE_ES_ShellCmd_Payload_t {
    /**< \brief ASCII text string containing shell command
                                                                to be executed */
    pub CmdString: [::std::os::raw::c_char; 64usize],
    /**< \brief Filename where shell command output is to
                                                                be written */
    pub OutputFilename: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_ShellCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_ShellCmd_Payload_t>() , 128usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_ES_ShellCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_ShellCmd_Payload_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_ShellCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_ShellCmd_Payload_t ) ) . CmdString
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_ShellCmd_Payload_t ) , "::" , stringify ! ( CmdString )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_ShellCmd_Payload_t ) ) .
                OutputFilename as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_ShellCmd_Payload_t ) , "::" , stringify ! (
                OutputFilename ) ));
}
#[repr(C)]
pub struct CFE_ES_ShellCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_ShellCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_ShellCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_ShellCmd_t>() , 136usize , concat
               ! ( "Size of: " , stringify ! ( CFE_ES_ShellCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_ShellCmd_t>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_ES_ShellCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_ShellCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_ShellCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_ShellCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_ShellCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
/**
** \brief Write All ES Application Info for All Applications to File Command
**
** For command details, see #CFE_ES_QUERY_ALL_CC
**
**/
#[repr(C)]
pub struct CFE_ES_QueryAllCmd_Payload_t {
    /**< \brief ASCII text string containing full path and
                                                                filename of file in which Application data is to be dumped */
    pub QueryAllFileName: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_QueryAllCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_QueryAllCmd_Payload_t>() , 64usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_ES_QueryAllCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_QueryAllCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_QueryAllCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_QueryAllCmd_Payload_t ) ) .
                QueryAllFileName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_QueryAllCmd_Payload_t ) , "::" , stringify ! (
                QueryAllFileName ) ));
}
#[repr(C)]
pub struct CFE_ES_QueryAllCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_QueryAllCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_QueryAllCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_QueryAllCmd_t>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_QueryAllCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_QueryAllCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_QueryAllCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_QueryAllCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_QueryAllCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_QueryAllCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_QueryAllCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Write All ES Application Info for All Tasks to File Command
**
** For command details, see #CFE_ES_QUERY_ALL_TASKS_CC
**
**/
#[repr(C)]
pub struct CFE_ES_QueryAllTasksCmd_Payload_t {
    /**< \brief ASCII text string containing full path and
                                                                filename of file in which Application data is to be dumped */
    pub QueryAllFileName: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_QueryAllTasksCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_QueryAllTasksCmd_Payload_t>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_QueryAllTasksCmd_Payload_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_QueryAllTasksCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_ES_QueryAllTasksCmd_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_QueryAllTasksCmd_Payload_t ) ) .
                QueryAllFileName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_QueryAllTasksCmd_Payload_t ) , "::" , stringify ! (
                QueryAllFileName ) ));
}
#[repr(C)]
pub struct CFE_ES_QueryAllTasksCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_QueryAllTasksCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_QueryAllTasksCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_QueryAllTasksCmd_t>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_ES_QueryAllTasksCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_QueryAllTasksCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_QueryAllTasksCmd_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_QueryAllTasksCmd_t ) ) . CmdHeader
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_QueryAllTasksCmd_t ) , "::" , stringify ! ( CmdHeader )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_QueryAllTasksCmd_t ) ) . Payload
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_QueryAllTasksCmd_t ) , "::" , stringify ! ( Payload )
                ));
}
/**
** \brief Dump System Log to File Command
**
** For command details, see #CFE_ES_WRITE_SYSLOG_CC
**
**/
#[repr(C)]
pub struct CFE_ES_WriteSyslogCmd_Payload_t {
    /**< \brief ASCII text string containing full path and
                                                                filename of file in which System Log is to be dumped */
    pub SysLogFileName: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_WriteSyslogCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_WriteSyslogCmd_Payload_t>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_WriteSyslogCmd_Payload_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_WriteSyslogCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_ES_WriteSyslogCmd_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_WriteSyslogCmd_Payload_t ) ) .
                SysLogFileName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_WriteSyslogCmd_Payload_t ) , "::" , stringify ! (
                SysLogFileName ) ));
}
#[repr(C)]
pub struct CFE_ES_WriteSyslogCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_WriteSyslogCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_WriteSyslogCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_WriteSyslogCmd_t>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_ES_WriteSyslogCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_WriteSyslogCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_WriteSyslogCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_WriteSyslogCmd_t ) ) . CmdHeader
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_WriteSyslogCmd_t
                ) , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_WriteSyslogCmd_t ) ) . Payload as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_WriteSyslogCmd_t
                ) , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Dump Exception and Reset Log to File Command
**
** For command details, see #CFE_ES_WRITE_ERLOG_CC
**
**/
#[repr(C)]
pub struct CFE_ES_WriteERlogCmd_Payload_t {
    /**< \brief ASCII text string containing full path and
                                                                filename of file in which ER Log is to be dumped */
    pub ERLogFileName: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_WriteERlogCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_WriteERlogCmd_Payload_t>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_WriteERlogCmd_Payload_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_WriteERlogCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_WriteERlogCmd_Payload_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_WriteERlogCmd_Payload_t ) ) .
                ERLogFileName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_WriteERlogCmd_Payload_t ) , "::" , stringify ! (
                ERLogFileName ) ));
}
#[repr(C)]
pub struct CFE_ES_WriteERlogCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_WriteERlogCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_WriteERlogCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_WriteERlogCmd_t>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_WriteERlogCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_WriteERlogCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_WriteERlogCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_WriteERlogCmd_t ) ) . CmdHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_WriteERlogCmd_t
                ) , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_WriteERlogCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_WriteERlogCmd_t
                ) , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Overwrite/Discard System Log Configuration Command
**
** For command details, see #CFE_ES_OVERWRITE_SYSLOG_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_OverWriteSysLogCmd_Payload_t {
    /**< \brief #CFE_ES_LOG_DISCARD=Throw away most recent messages,
                                                                     #CFE_ES_LOG_OVERWRITE=Overwrite oldest with most recent */
    pub Mode: uint32,
}
#[test]
fn bindgen_test_layout_CFE_ES_OverWriteSysLogCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_OverWriteSysLogCmd_Payload_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_OverWriteSysLogCmd_Payload_t
               ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_OverWriteSysLogCmd_Payload_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_ES_OverWriteSysLogCmd_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_OverWriteSysLogCmd_Payload_t ) ) .
                Mode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_OverWriteSysLogCmd_Payload_t ) , "::" , stringify ! (
                Mode ) ));
}
impl Clone for CFE_ES_OverWriteSysLogCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_OverWriteSysLogCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_OverWriteSysLogCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_OverWriteSysLogCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_OverWriteSysLogCmd_t>() , 12usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_ES_OverWriteSysLogCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_OverWriteSysLogCmd_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_OverWriteSysLogCmd_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_OverWriteSysLogCmd_t ) ) .
                CmdHeader as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_OverWriteSysLogCmd_t ) , "::" , stringify ! ( CmdHeader
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_OverWriteSysLogCmd_t ) ) . Payload
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_OverWriteSysLogCmd_t ) , "::" , stringify ! ( Payload )
                ));
}
impl Clone for CFE_ES_OverWriteSysLogCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Start Application Command
**
** For command details, see #CFE_ES_START_APP_CC
**
**/
#[repr(C)]
pub struct CFE_ES_StartAppCmd_Payload_t {
    /**< \brief Name of Application to be started */
    pub Application: [::std::os::raw::c_char; 20usize],
    /**< \brief Symbolic name of Application's entry point */
    pub AppEntryPoint: [::std::os::raw::c_char; 20usize],
    /**< \brief Full path and filename of Application's 
                                                                     executable image */
    pub AppFileName: [::std::os::raw::c_char; 64usize],
    /**< \brief Desired stack size for the new application */
    pub StackSize: uint32,
    /**< \brief #CFE_ES_APP_EXCEPTION_RESTART_APP=On exception, 
                                                                     restart Application,
                                                                     #CFE_ES_APP_EXCEPTION_PROC_RESTART=On exception,
                                                                     perform a Processor Reset */
    pub ExceptionAction: uint16,
    /**< \brief The new Applications runtime priority. */
    pub Priority: uint16,
}
#[test]
fn bindgen_test_layout_CFE_ES_StartAppCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_StartAppCmd_Payload_t>() ,
               112usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_StartAppCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_StartAppCmd_Payload_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_StartAppCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_StartAppCmd_Payload_t ) ) .
                Application as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_StartAppCmd_Payload_t ) , "::" , stringify ! (
                Application ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_StartAppCmd_Payload_t ) ) .
                AppEntryPoint as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_StartAppCmd_Payload_t ) , "::" , stringify ! (
                AppEntryPoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_StartAppCmd_Payload_t ) ) .
                AppFileName as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_StartAppCmd_Payload_t ) , "::" , stringify ! (
                AppFileName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_StartAppCmd_Payload_t ) ) .
                StackSize as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_StartAppCmd_Payload_t ) , "::" , stringify ! (
                StackSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_StartAppCmd_Payload_t ) ) .
                ExceptionAction as * const _ as usize } , 108usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_ES_StartAppCmd_Payload_t ) , "::" , stringify ! (
                ExceptionAction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_StartAppCmd_Payload_t ) ) .
                Priority as * const _ as usize } , 110usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_StartAppCmd_Payload_t ) , "::" , stringify ! ( Priority
                ) ));
}
#[repr(C)]
pub struct CFE_ES_StartAppCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_StartAppCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_StartAppCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_StartAppCmd_t>() , 120usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_StartAppCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_StartAppCmd_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_StartAppCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_StartAppCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_StartAppCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_StartAppCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_StartAppCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Command Structure for Commands requiring just an Application Name
**
** For command details, see #CFE_ES_STOP_APP_CC, #CFE_ES_RESTART_APP_CC, #CFE_ES_QUERY_ONE_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_AppNameCmd_Payload_t {
    /**< \brief ASCII text string containing Application Name */
    pub Application: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_AppNameCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_AppNameCmd_Payload_t>() , 20usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_ES_AppNameCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_AppNameCmd_Payload_t>() , 1usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_AppNameCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppNameCmd_Payload_t ) ) .
                Application as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_AppNameCmd_Payload_t ) , "::" , stringify ! (
                Application ) ));
}
impl Clone for CFE_ES_AppNameCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_AppNameCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_AppNameCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_AppNameCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_AppNameCmd_t>() , 28usize , concat
               ! ( "Size of: " , stringify ! ( CFE_ES_AppNameCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_AppNameCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_AppNameCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppNameCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppNameCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppNameCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppNameCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_ES_AppNameCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Reload Application Command
**
** For command details, see #CFE_ES_RELOAD_APP_CC
**
**/
#[repr(C)]
pub struct CFE_ES_AppReloadCmd_Payload_t {
    /**< \brief ASCII text string containing Application Name */
    pub Application: [::std::os::raw::c_char; 20usize],
    /**< \brief Full path and filename of Application's 
                                                                    executable image */
    pub AppFileName: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_AppReloadCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_AppReloadCmd_Payload_t>() ,
               84usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_AppReloadCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_AppReloadCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_AppReloadCmd_Payload_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppReloadCmd_Payload_t ) ) .
                Application as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_AppReloadCmd_Payload_t ) , "::" , stringify ! (
                Application ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppReloadCmd_Payload_t ) ) .
                AppFileName as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_AppReloadCmd_Payload_t ) , "::" , stringify ! (
                AppFileName ) ));
}
#[repr(C)]
pub struct CFE_ES_AppReloadCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_AppReloadCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_AppReloadCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_AppReloadCmd_t>() , 92usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_AppReloadCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_AppReloadCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_AppReloadCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppReloadCmd_t ) ) . CmdHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppReloadCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_AppReloadCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_AppReloadCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Set Maximum Processor Reset Count Command
**
** For command details, see #CFE_ES_SET_MAX_PR_COUNT_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_SetMaxPRCountCmd_Payload_t {
    /**< \brief New maximum number of Processor Resets before
                                                                    an automatic Power-On Reset is performed */
    pub MaxPRCount: uint16,
}
#[test]
fn bindgen_test_layout_CFE_ES_SetMaxPRCountCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_SetMaxPRCountCmd_Payload_t>() ,
               2usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_SetMaxPRCountCmd_Payload_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_SetMaxPRCountCmd_Payload_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_ES_SetMaxPRCountCmd_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_SetMaxPRCountCmd_Payload_t ) ) .
                MaxPRCount as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_SetMaxPRCountCmd_Payload_t ) , "::" , stringify ! (
                MaxPRCount ) ));
}
impl Clone for CFE_ES_SetMaxPRCountCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_SetMaxPRCountCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_SetMaxPRCountCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_SetMaxPRCountCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_SetMaxPRCountCmd_t>() , 10usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_ES_SetMaxPRCountCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_SetMaxPRCountCmd_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_SetMaxPRCountCmd_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_SetMaxPRCountCmd_t ) ) . CmdHeader
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_SetMaxPRCountCmd_t ) , "::" , stringify ! ( CmdHeader )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_SetMaxPRCountCmd_t ) ) . Payload
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_SetMaxPRCountCmd_t ) , "::" , stringify ! ( Payload )
                ));
}
impl Clone for CFE_ES_SetMaxPRCountCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Delete Critical Data Store Command
**
** For command details, see #CFE_ES_DELETE_CDS_CC
**
**/
#[repr(C)]
pub struct CFE_ES_DeleteCDSCmd_Payload_t {
    /**< \brief ASCII text string containing name of CDS to delete */
    pub CdsName: [::std::os::raw::c_char; 38usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_DeleteCDSCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_DeleteCDSCmd_Payload_t>() ,
               38usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_DeleteCDSCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_DeleteCDSCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_DeleteCDSCmd_Payload_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_DeleteCDSCmd_Payload_t ) ) .
                CdsName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_DeleteCDSCmd_Payload_t ) , "::" , stringify ! ( CdsName
                ) ));
}
#[repr(C)]
pub struct CFE_ES_DeleteCDSCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_DeleteCDSCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_DeleteCDSCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_DeleteCDSCmd_t>() , 46usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_DeleteCDSCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_DeleteCDSCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_DeleteCDSCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_DeleteCDSCmd_t ) ) . CmdHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_DeleteCDSCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_DeleteCDSCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_DeleteCDSCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Start Performance Analyzer Command
**
** For command details, see #CFE_ES_PERF_STARTDATA_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_PerfStartCmd_Payload_t {
    /**< \brief Desired trigger position (Start, Center, End) */
    pub TriggerMode: uint32,
}
#[test]
fn bindgen_test_layout_CFE_ES_PerfStartCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_PerfStartCmd_Payload_t>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_ES_PerfStartCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_PerfStartCmd_Payload_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_PerfStartCmd_Payload_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfStartCmd_Payload_t ) ) .
                TriggerMode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PerfStartCmd_Payload_t ) , "::" , stringify ! (
                TriggerMode ) ));
}
impl Clone for CFE_ES_PerfStartCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_PerfStartCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_PerfStartCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_PerfStartCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_PerfStartCmd_t>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_PerfStartCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_PerfStartCmd_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_PerfStartCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfStartCmd_t ) ) . CmdHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_PerfStartCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfStartCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_PerfStartCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_ES_PerfStartCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Stop Performance Analyzer Command
**
** For command details, see #CFE_ES_PERF_STOPDATA_CC
**
**/
#[repr(C)]
pub struct CFE_ES_PerfStopCmd_Payload_t {
    /**< \brief ASCII text string of full path and filename 
                                                                    of file Performance Analyzer data is to be written */
    pub DataFileName: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_PerfStopCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_PerfStopCmd_Payload_t>() , 64usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_ES_PerfStopCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_PerfStopCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_PerfStopCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfStopCmd_Payload_t ) ) .
                DataFileName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PerfStopCmd_Payload_t ) , "::" , stringify ! (
                DataFileName ) ));
}
#[repr(C)]
pub struct CFE_ES_PerfStopCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_PerfStopCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_PerfStopCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_PerfStopCmd_t>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_PerfStopCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_PerfStopCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_PerfStopCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfStopCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_PerfStopCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfStopCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_PerfStopCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Set Performance Analyzer Filter Mask Command
**
** For command details, see #CFE_ES_PERF_SETFILTERMASK_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_PerfSetFilterMaskCmd_Payload_t {
    /**< \brief Index into array of Filter Masks */
    pub FilterMaskNum: uint32,
    /**< \brief New Mask for specified entry in array of Filter Masks */
    pub FilterMask: uint32,
}
#[test]
fn bindgen_test_layout_CFE_ES_PerfSetFilterMaskCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_PerfSetFilterMaskCmd_Payload_t>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               CFE_ES_PerfSetFilterMaskCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_PerfSetFilterMaskCmd_Payload_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_ES_PerfSetFilterMaskCmd_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfSetFilterMaskCmd_Payload_t ) )
                . FilterMaskNum as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PerfSetFilterMaskCmd_Payload_t ) , "::" , stringify ! (
                FilterMaskNum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfSetFilterMaskCmd_Payload_t ) )
                . FilterMask as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PerfSetFilterMaskCmd_Payload_t ) , "::" , stringify ! (
                FilterMask ) ));
}
impl Clone for CFE_ES_PerfSetFilterMaskCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_PerfSetFilterMaskCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_PerfSetFilterMaskCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_PerfSetFilterMaskCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_PerfSetFilterMaskCmd_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_PerfSetFilterMaskCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_PerfSetFilterMaskCmd_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_PerfSetFilterMaskCmd_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfSetFilterMaskCmd_t ) ) .
                CmdHeader as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PerfSetFilterMaskCmd_t ) , "::" , stringify ! (
                CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfSetFilterMaskCmd_t ) ) .
                Payload as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PerfSetFilterMaskCmd_t ) , "::" , stringify ! ( Payload
                ) ));
}
impl Clone for CFE_ES_PerfSetFilterMaskCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Set Performance Analyzer Trigger Mask Command
**
** For command details, see #CFE_ES_PERF_SETTRIGMASK_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_PerfSetTrigMaskCmd_Payload_t {
    /**< \brief Index into array of Trigger Masks */
    pub TriggerMaskNum: uint32,
    /**< \brief New Mask for specified entry in array of Trigger Masks */
    pub TriggerMask: uint32,
}
#[test]
fn bindgen_test_layout_CFE_ES_PerfSetTrigMaskCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_PerfSetTrigMaskCmd_Payload_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_PerfSetTrigMaskCmd_Payload_t
               ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_PerfSetTrigMaskCmd_Payload_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_ES_PerfSetTrigMaskCmd_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfSetTrigMaskCmd_Payload_t ) ) .
                TriggerMaskNum as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PerfSetTrigMaskCmd_Payload_t ) , "::" , stringify ! (
                TriggerMaskNum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfSetTrigMaskCmd_Payload_t ) ) .
                TriggerMask as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PerfSetTrigMaskCmd_Payload_t ) , "::" , stringify ! (
                TriggerMask ) ));
}
impl Clone for CFE_ES_PerfSetTrigMaskCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_PerfSetTrigMaskCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_PerfSetTrigMaskCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_PerfSetTrigMaskCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_PerfSetTrigMaskCmd_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_ES_PerfSetTrigMaskCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_PerfSetTrigMaskCmd_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_PerfSetTrigMaskCmd_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfSetTrigMaskCmd_t ) ) .
                CmdHeader as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PerfSetTrigMaskCmd_t ) , "::" , stringify ! ( CmdHeader
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PerfSetTrigMaskCmd_t ) ) . Payload
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PerfSetTrigMaskCmd_t ) , "::" , stringify ! ( Payload )
                ));
}
impl Clone for CFE_ES_PerfSetTrigMaskCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Telemeter Memory Pool Statistics Command
**
** For command details, see #CFE_ES_TLM_POOL_STATS_CC
**
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_TlmPoolStatsCmd_Payload_t {
    /**< \brief - RESERVED - should be all zeroes */
    pub Application: [::std::os::raw::c_char; 20usize],
    /**< \brief Handle of Pool whose statistics are to be telemetered */
    pub PoolHandle: CFE_ES_MemHandle_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_TlmPoolStatsCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_TlmPoolStatsCmd_Payload_t>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_TlmPoolStatsCmd_Payload_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_TlmPoolStatsCmd_Payload_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_ES_TlmPoolStatsCmd_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_TlmPoolStatsCmd_Payload_t ) ) .
                Application as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_TlmPoolStatsCmd_Payload_t ) , "::" , stringify ! (
                Application ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_TlmPoolStatsCmd_Payload_t ) ) .
                PoolHandle as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_TlmPoolStatsCmd_Payload_t ) , "::" , stringify ! (
                PoolHandle ) ));
}
impl Clone for CFE_ES_TlmPoolStatsCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_TlmPoolStatsCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_TlmPoolStatsCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_TlmPoolStatsCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_TlmPoolStatsCmd_t>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_ES_TlmPoolStatsCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_TlmPoolStatsCmd_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_TlmPoolStatsCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_TlmPoolStatsCmd_t ) ) . CmdHeader
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_TlmPoolStatsCmd_t ) , "::" , stringify ! ( CmdHeader )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_TlmPoolStatsCmd_t ) ) . Payload as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_TlmPoolStatsCmd_t ) , "::" , stringify ! ( Payload )
                ));
}
impl Clone for CFE_ES_TlmPoolStatsCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Dump CDS Registry Command
**
** For command details, see #CFE_ES_DUMP_CDS_REG_CC
**
**/
#[repr(C)]
pub struct CFE_ES_DumpCDSRegCmd_Payload_t {
    /**< \brief ASCII text string of full path and filename 
                                                                    of file CDS Registry is to be written */
    pub DumpFilename: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_DumpCDSRegCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_DumpCDSRegCmd_Payload_t>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_DumpCDSRegCmd_Payload_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_DumpCDSRegCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_DumpCDSRegCmd_Payload_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_DumpCDSRegCmd_Payload_t ) ) .
                DumpFilename as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_DumpCDSRegCmd_Payload_t ) , "::" , stringify ! (
                DumpFilename ) ));
}
#[repr(C)]
pub struct CFE_ES_DumpCDSRegCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_ES_DumpCDSRegCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_DumpCDSRegCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_DumpCDSRegCmd_t>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_DumpCDSRegCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_DumpCDSRegCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_DumpCDSRegCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_DumpCDSRegCmd_t ) ) . CmdHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_DumpCDSRegCmd_t
                ) , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_DumpCDSRegCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_DumpCDSRegCmd_t
                ) , "::" , stringify ! ( Payload ) ));
}
/**********************************/
/** 
**  \cfeestlm Single Application Information Packet
**/
#[repr(C)]
pub struct CFE_ES_OneAppTlm_Payload_t {
    /**< \brief For more information, see #CFE_ES_AppInfo_t */
    pub AppInfo: CFE_ES_AppInfo_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_OneAppTlm_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_OneAppTlm_Payload_t>() , 188usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_ES_OneAppTlm_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_OneAppTlm_Payload_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_OneAppTlm_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_OneAppTlm_Payload_t ) ) . AppInfo
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_OneAppTlm_Payload_t ) , "::" , stringify ! ( AppInfo )
                ));
}
#[repr(C)]
pub struct CFE_ES_OneAppTlm_t {
    /**< \brief cFE Software Bus Telemetry Message Header */
    pub TlmHeader: [uint8; 12usize],
    pub Payload: CFE_ES_OneAppTlm_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_OneAppTlm_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_OneAppTlm_t>() , 200usize , concat
               ! ( "Size of: " , stringify ! ( CFE_ES_OneAppTlm_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_OneAppTlm_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_ES_OneAppTlm_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_OneAppTlm_t ) ) . TlmHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_OneAppTlm_t ) ,
                "::" , stringify ! ( TlmHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_OneAppTlm_t ) ) . Payload as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_OneAppTlm_t ) ,
                "::" , stringify ! ( Payload ) ));
}
/** 
**  \cfeestlm Memory Pool Statistics Packet
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_PoolStatsTlm_Payload_t {
    /**< \cfetlmmnemonic \ES_POOLHANDLE
                                                             \brief Handle of memory pool whose stats are being telemetered */
    pub PoolHandle: CFE_ES_MemHandle_t,
    /**< \brief For more info, see #CFE_ES_MemPoolStats_t */
    pub PoolStats: CFE_ES_MemPoolStats_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_PoolStatsTlm_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_PoolStatsTlm_Payload_t>() ,
               232usize , concat ! (
               "Size of: " , stringify ! ( CFE_ES_PoolStatsTlm_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_PoolStatsTlm_Payload_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_PoolStatsTlm_Payload_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PoolStatsTlm_Payload_t ) ) .
                PoolHandle as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PoolStatsTlm_Payload_t ) , "::" , stringify ! (
                PoolHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PoolStatsTlm_Payload_t ) ) .
                PoolStats as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_PoolStatsTlm_Payload_t ) , "::" , stringify ! (
                PoolStats ) ));
}
impl Clone for CFE_ES_PoolStatsTlm_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_PoolStatsTlm_t {
    /**< \brief cFE Software Bus Telemetry Message Header */
    pub TlmHeader: [uint8; 12usize],
    pub Payload: CFE_ES_PoolStatsTlm_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_PoolStatsTlm_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_PoolStatsTlm_t>() , 248usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_PoolStatsTlm_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_PoolStatsTlm_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_PoolStatsTlm_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PoolStatsTlm_t ) ) . TlmHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_PoolStatsTlm_t )
                , "::" , stringify ! ( TlmHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_PoolStatsTlm_t ) ) . Payload as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_PoolStatsTlm_t )
                , "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_ES_PoolStatsTlm_t {
    fn clone(&self) -> Self { *self }
}
/** 
**  \cfeestlm Executive Services Housekeeping Packet
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_HkPacket_Payload_t {
    /**< \cfetlmmnemonic \ES_CMDPC 
                                          \brief The ES Application Command Counter */
    pub CmdCounter: uint8,
    /**< \cfetlmmnemonic \ES_CMDEC 
                                          \brief The ES Application Command Error Counter */
    pub ErrCounter: uint8,
    /**< \cfetlmmnemonic \ES_CKSUM 
                                                 \brief Checksum of cFE Core Code */
    pub CFECoreChecksum: uint16,
    /**< \cfetlmmnemonic \ES_CFEMAJORVER 
                                                 \brief Major Version Number of cFE */
    pub CFEMajorVersion: uint8,
    /**< \cfetlmmnemonic \ES_CFEMINORVER 
                                                 \brief Minor Version Number of cFE */
    pub CFEMinorVersion: uint8,
    /**< \cfetlmmnemonic \ES_CFEREVISION 
                                                 \brief Sub-Minor Version Number of cFE */
    pub CFERevision: uint8,
    /**< \cfetlmmnemonic \ES_CFEMISSIONREV 
                                                 \brief Mission Version Number of cFE */
    pub CFEMissionRevision: uint8,
    /**< \cfetlmmnemonic \ES_OSMAJORVER 
                                                 \brief OS Abstraction Layer Major Version Number */
    pub OSALMajorVersion: uint8,
    /**< \cfetlmmnemonic \ES_OSMINORVER 
                                                 \brief OS Abstraction Layer Minor Version Number */
    pub OSALMinorVersion: uint8,
    /**< \cfetlmmnemonic \ES_OSREVISION 
                                                 \brief OS Abstraction Layer Revision Number */
    pub OSALRevision: uint8,
    /**< \cfetlmmnemonic \ES_OSMISSIONREV 
                                                 \brief OS Abstraction Layer MissionRevision Number */
    pub OSALMissionRevision: uint8,
    /**< \cfetlmmnemonic \ES_SYSLOGBYTEUSED 
                                              \brief Total number of bytes used in system log */
    pub SysLogBytesUsed: uint32,
    /**< \cfetlmmnemonic \ES_SYSLOGSIZE 
                                              \brief Total size of the system log */
    pub SysLogSize: uint32,
    /**< \cfetlmmnemonic \ES_SYSLOGENTRIES 
                                              \brief Number of entries in the system log */
    pub SysLogEntries: uint32,
    /**< \cfetlmmnemonic \ES_SYSLOGMODE 
                                              \brief Write/Overwrite Mode */
    pub SysLogMode: uint32,
    /**< \cfetlmmnemonic \ES_ERLOGINDEX 
                                               \brief Current index of the ER Log (wraps around) */
    pub ERLogIndex: uint32,
    /**< \cfetlmmnemonic \ES_ERLOGENTRIES 
                                               \brief Number of entries made in the ER Log since the power on */
    pub ERLogEntries: uint32,
    /**< \cfetlmmnemonic \ES_REGCOREAPPS 
                                                      \brief Number of Applications registered with ES */
    pub RegisteredCoreApps: uint32,
    /**< \cfetlmmnemonic \ES_REGEXTAPPS 
                                                      \brief Number of Applications registered with ES */
    pub RegisteredExternalApps: uint32,
    /**< \cfetlmmnemonic \ES_REGTASKS 
                                                      \brief Number of Tasks ( main AND child tasks ) registered with ES */
    pub RegisteredTasks: uint32,
    /**< \cfetlmmnemonic \ES_REGLIBS 
                                              \brief Number of Libraries registered with ES */
    pub RegisteredLibs: uint32,
    /**< \cfetlmmnemonic \ES_RESETTYPE 
                                              \brief Reset type ( PROCESSOR or POWERON ) */
    pub ResetType: uint32,
    /**< \cfetlmmnemonic \ES_RESETSUBTYPE 
                                              \brief Reset Sub Type */
    pub ResetSubtype: uint32,
    /**< \cfetlmmnemonic \ES_PROCRESETCNT 
                                              \brief Number of processor resets since last power on */
    pub ProcessorResets: uint32,
    /**< \cfetlmmnemonic \ES_MAXPROCRESETS 
                                                 \brief Max processor resets before a power on is done */
    pub MaxProcessorResets: uint32,
    /**< \cfetlmmnemonic \ES_BOOTSOURCE 
                                              \brief Boot source ( as provided from BSP ) */
    pub BootSource: uint32,
    /**< \cfetlmmnemonic \ES_PERFSTATE 
                                              \brief Current state of Performance Analyzer */
    pub PerfState: uint32,
    /**< \cfetlmmnemonic \ES_PERFMODE 
                                              \brief Current mode of Performance Analyzer */
    pub PerfMode: uint32,
    /**< \cfetlmmnemonic \ES_PERFTRIGCNT 
                                                                         \brief Number of Times Perfomance Analyzer has Triggered */
    pub PerfTriggerCount: uint32,
    /**< \cfetlmmnemonic \ES_PERFFLTRMASK 
                                                                         \brief Current Setting of Performance Analyzer Filter Masks */
    pub PerfFilterMask: [uint32; 4usize],
    /**< \cfetlmmnemonic \ES_PERFTRIGMASK 
                                                                         \brief Current Setting of Performance Analyzer Trigger Masks */
    pub PerfTriggerMask: [uint32; 4usize],
    /**< \cfetlmmnemonic \ES_PERFDATASTART 
                                              \brief Identifies First Stored Entry in Performance Analyzer Log */
    pub PerfDataStart: uint32,
    /**< \cfetlmmnemonic \ES_PERFDATAEND 
                                              \brief Identifies Last Stored Entry in Performance Analyzer Log */
    pub PerfDataEnd: uint32,
    /**< \cfetlmmnemonic \ES_PERFDATACNT 
                                              \brief Number of Entries Put Into the Performance Analyzer Log */
    pub PerfDataCount: uint32,
    /**< \cfetlmmnemonic \ES_PERFDATA2WRITE 
                                              \brief Number of Performance Analyzer Log Entries Left to be Written to Log Dump File */
    pub PerfDataToWrite: uint32,
    /**< \cfetlmmnemonic \ES_HEAPBYTESFREE
                                              \brief Number of free bytes remaining in the OS heap */
    pub HeapBytesFree: uint32,
    /**< \cfetlmmnemonic \ES_HEAPBLKSFREE
                                              \brief Number of free blocks remaining in the OS heap */
    pub HeapBlocksFree: uint32,
    /**< \cfetlmmnemonic \ES_HEAPMAXBLK
                                              \brief Number of bytes in the largest free block */
    pub HeapMaxBlockSize: uint32,
}
#[test]
fn bindgen_test_layout_CFE_ES_HkPacket_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_HkPacket_Payload_t>() , 144usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_ES_HkPacket_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_HkPacket_Payload_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_HkPacket_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                CmdCounter as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! ( CmdCounter
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                ErrCounter as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! ( ErrCounter
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                CFECoreChecksum as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                CFECoreChecksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                CFEMajorVersion as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                CFEMajorVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                CFEMinorVersion as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                CFEMinorVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                CFERevision as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! ( CFERevision
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                CFEMissionRevision as * const _ as usize } , 7usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                CFEMissionRevision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                OSALMajorVersion as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                OSALMajorVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                OSALMinorVersion as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                OSALMinorVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                OSALRevision as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                OSALRevision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                OSALMissionRevision as * const _ as usize } , 11usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                OSALMissionRevision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                SysLogBytesUsed as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                SysLogBytesUsed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                SysLogSize as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! ( SysLogSize
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                SysLogEntries as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                SysLogEntries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                SysLogMode as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! ( SysLogMode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                ERLogIndex as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! ( ERLogIndex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                ERLogEntries as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                ERLogEntries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                RegisteredCoreApps as * const _ as usize } , 36usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                RegisteredCoreApps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                RegisteredExternalApps as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                RegisteredExternalApps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                RegisteredTasks as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                RegisteredTasks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                RegisteredLibs as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                RegisteredLibs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) . ResetType
                as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! ( ResetType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                ResetSubtype as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                ResetSubtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                ProcessorResets as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                ProcessorResets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                MaxProcessorResets as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                MaxProcessorResets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                BootSource as * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! ( BootSource
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) . PerfState
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! ( PerfState )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) . PerfMode
                as * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! ( PerfMode )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                PerfTriggerCount as * const _ as usize } , 80usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                PerfTriggerCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                PerfFilterMask as * const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                PerfFilterMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                PerfTriggerMask as * const _ as usize } , 100usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                PerfTriggerMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                PerfDataStart as * const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                PerfDataStart ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                PerfDataEnd as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! ( PerfDataEnd
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                PerfDataCount as * const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                PerfDataCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                PerfDataToWrite as * const _ as usize } , 128usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                PerfDataToWrite ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                HeapBytesFree as * const _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                HeapBytesFree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                HeapBlocksFree as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                HeapBlocksFree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_Payload_t ) ) .
                HeapMaxBlockSize as * const _ as usize } , 140usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_ES_HkPacket_Payload_t ) , "::" , stringify ! (
                HeapMaxBlockSize ) ));
}
impl Clone for CFE_ES_HkPacket_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_ES_HkPacket_t {
    /**< \brief cFE Software Bus Telemetry Message Header */
    pub TlmHeader: [uint8; 12usize],
    pub Payload: CFE_ES_HkPacket_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_HkPacket_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_HkPacket_t>() , 156usize , concat
               ! ( "Size of: " , stringify ! ( CFE_ES_HkPacket_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_HkPacket_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_ES_HkPacket_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_t ) ) . TlmHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_HkPacket_t ) ,
                "::" , stringify ! ( TlmHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_HkPacket_t ) ) . Payload as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_HkPacket_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_ES_HkPacket_t {
    fn clone(&self) -> Self { *self }
}
/** 
**  \cfeestlm OS Shell Output Packet
**/
#[repr(C)]
pub struct CFE_ES_ShellPacket_Payload_t {
    /**< \brief ASCII text string containing output from OS Shell
                                                                 that was received in response to an OS Shell Command */
    pub ShellOutput: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_ES_ShellPacket_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_ShellPacket_Payload_t>() , 64usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_ES_ShellPacket_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_ES_ShellPacket_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_ES_ShellPacket_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_ShellPacket_Payload_t ) ) .
                ShellOutput as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_ES_ShellPacket_Payload_t ) , "::" , stringify ! (
                ShellOutput ) ));
}
#[repr(C)]
pub struct CFE_ES_ShellPacket_t {
    /**< \brief cFE Software Bus Telemetry Message Header */
    pub TlmHeader: [uint8; 12usize],
    pub Payload: CFE_ES_ShellPacket_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_ES_ShellPacket_t() {
    assert_eq!(::std::mem::size_of::<CFE_ES_ShellPacket_t>() , 76usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_ES_ShellPacket_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_ES_ShellPacket_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_ES_ShellPacket_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_ShellPacket_t ) ) . TlmHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_ShellPacket_t )
                , "::" , stringify ! ( TlmHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_ES_ShellPacket_t ) ) . Payload as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_ES_ShellPacket_t )
                , "::" , stringify ! ( Payload ) ));
}
/**
**  \brief Write File Info Commands
**
**  This structure contains a generic definition used by three SB commands,
**  'Write Routing Info to File' #CFE_SB_SEND_ROUTING_INFO_CC,
**  'Write Pipe Info to File' #CFE_SB_SEND_PIPE_INFO_CC and
**  'Write Map Info to File' #CFE_SB_SEND_MAP_INFO_CC.
*/
#[repr(C)]
pub struct CFE_SB_WriteFileInfoCmd_Payload_t {
    /**< \brief Path and Filename of data to be loaded */
    pub Filename: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_SB_WriteFileInfoCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_WriteFileInfoCmd_Payload_t>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( CFE_SB_WriteFileInfoCmd_Payload_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_SB_WriteFileInfoCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! (
                CFE_SB_WriteFileInfoCmd_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_WriteFileInfoCmd_Payload_t ) ) .
                Filename as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_WriteFileInfoCmd_Payload_t ) , "::" , stringify ! (
                Filename ) ));
}
#[repr(C)]
pub struct CFE_SB_WriteFileInfoCmd_t {
    /**< \brief cFE Software Bus Command Message Header #CFE_SB_CmdHdr_t */
    pub Hdr: CFE_SB_CmdHdr_t,
    pub Payload: CFE_SB_WriteFileInfoCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_SB_WriteFileInfoCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_WriteFileInfoCmd_t>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_SB_WriteFileInfoCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_WriteFileInfoCmd_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_SB_WriteFileInfoCmd_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_WriteFileInfoCmd_t ) ) . Hdr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_WriteFileInfoCmd_t ) , "::" , stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_WriteFileInfoCmd_t ) ) . Payload
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_WriteFileInfoCmd_t ) , "::" , stringify ! ( Payload )
                ));
}
/**
**  \brief Enable/Disable Route Commands
**
**  This structure contains a definition used by two SB commands,
**  'Enable Route' #CFE_SB_ENABLE_ROUTE_CC and 'Disable Route' #CFE_SB_DISABLE_ROUTE_CC.
**  A route is the destination pipe for a  particular message and is therefore defined
**  as a MsgId and PipeId combination.
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_EnRoutCmd_Payload_t {
    /**< \brief Message ID of route to be enabled or disabled #CFE_SB_MsgId_t */
    pub MsgId: CFE_SB_MsgId_t,
    /**< \brief Pipe ID of route to be enabled or disabled #CFE_SB_PipeId_t */
    pub Pipe: CFE_SB_PipeId_t,
    /**<\brief Spare byte to make command even number of bytes */
    pub Spare: uint8,
}
#[test]
fn bindgen_test_layout_CFE_SB_EnRoutCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_EnRoutCmd_Payload_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_SB_EnRoutCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_EnRoutCmd_Payload_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_SB_EnRoutCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_EnRoutCmd_Payload_t ) ) . MsgId as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_EnRoutCmd_Payload_t ) , "::" , stringify ! ( MsgId )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_EnRoutCmd_Payload_t ) ) . Pipe as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_EnRoutCmd_Payload_t ) , "::" , stringify ! ( Pipe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_EnRoutCmd_Payload_t ) ) . Spare as
                * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_EnRoutCmd_Payload_t ) , "::" , stringify ! ( Spare )
                ));
}
impl Clone for CFE_SB_EnRoutCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_EnRoutCmd_t {
    /**< \brief cFE Software Bus Command Message Header #CFE_SB_CmdHdr_t */
    pub Hdr: CFE_SB_CmdHdr_t,
    pub Payload: CFE_SB_EnRoutCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_SB_EnRoutCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_EnRoutCmd_t>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( CFE_SB_EnRoutCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_EnRoutCmd_t>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_SB_EnRoutCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_EnRoutCmd_t ) ) . Hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_EnRoutCmd_t ) ,
                "::" , stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_EnRoutCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_EnRoutCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_SB_EnRoutCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
**  \cfesbtlm Software Bus task housekeeping Packet
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_HKMsg_Payload_t {
    /**< \cfetlmmnemonic \SB_CMDPC
                                    \brief Count of valid commands received */
    pub CommandCnt: uint8,
    /**< \cfetlmmnemonic \SB_CMDEC
                                   \brief Count of invalid commands received */
    pub CmdErrCnt: uint8,
    /**< \cfetlmmnemonic \SB_NOSUBEC
                                          \brief Count pkts sent with no subscribers */
    pub NoSubscribersCnt: uint8,
    /**< \cfetlmmnemonic \SB_MSGSNDEC
                                       \brief Count of message send errors */
    pub MsgSendErrCnt: uint8,
    /**< \cfetlmmnemonic \SB_MSGRECEC
                                          \brief Count of message receive errors */
    pub MsgReceiveErrCnt: uint8,
    /**< \cfetlmmnemonic \SB_INTERNALEC
                                        \brief Count of queue read or write errors */
    pub InternalErrCnt: uint8,
    /**< \cfetlmmnemonic \SB_NEWPIPEEC
                                          \brief Count of errors in create pipe API */
    pub CreatePipeErrCnt: uint8,
    /**< \cfetlmmnemonic \SB_SUBSCREC
                                         \brief Count of errors in subscribe API */
    pub SubscribeErrCnt: uint8,
    /**< \cfetlmmnemonic \SB_SPARE
                                     \brief Spare Byte */
    pub Spare: uint8,
    /**< \cfetlmmnemonic \SB_DUPSUBCNT
                                             \brief Count of duplicate subscriptions */
    pub DupSubscriptionsCnt: uint8,
    /**< \cfetlmmnemonic \SB_SPARE2ALIGN
                                        \brief Spare bytes to ensure alignment */
    pub Spare2Align: [uint8; 2usize],
    /**< \cfetlmmnemonic \SB_PIPEOVREC
                                            \brief Count of pipe overflow errors */
    pub PipeOverflowErrCnt: uint16,
    /**< \cfetlmmnemonic \SB_MSGLIMEC
                                           \brief Count of msg id to pipe errors */
    pub MsgLimErrCnt: uint16,
    /**< \cfetlmmnemonic \SB_MEMPOOLHANDLE
                                          \brief Handle to SB's Memory Pool */
    pub MemPoolHandle: CFE_ES_MemHandle_t,
    /**< \cfetlmmnemonic \SB_MEMINUSE
                                            \brief Memory in use */
    pub MemInUse: uint32,
    /**< \cfetlmmnemonic \SB_UNMARKEDMEM
                                     \brief cfg param CFE_SB_BUF_MEMORY_BYTES minus Peak Memory in use */
    pub UnmarkedMem: uint32,
}
#[test]
fn bindgen_test_layout_CFE_SB_HKMsg_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_HKMsg_Payload_t>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_SB_HKMsg_Payload_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_SB_HKMsg_Payload_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_SB_HKMsg_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) . CommandCnt
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( CommandCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) . CmdErrCnt as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( CmdErrCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) .
                NoSubscribersCnt as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( NoSubscribersCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) .
                MsgSendErrCnt as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( MsgSendErrCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) .
                MsgReceiveErrCnt as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( MsgReceiveErrCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) .
                InternalErrCnt as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( InternalErrCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) .
                CreatePipeErrCnt as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( CreatePipeErrCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) .
                SubscribeErrCnt as * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( SubscribeErrCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) . Spare as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( Spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) .
                DupSubscriptionsCnt as * const _ as usize } , 9usize , concat
                ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( DupSubscriptionsCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) . Spare2Align
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( Spare2Align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) .
                PipeOverflowErrCnt as * const _ as usize } , 12usize , concat
                ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( PipeOverflowErrCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) . MsgLimErrCnt
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( MsgLimErrCnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) .
                MemPoolHandle as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( MemPoolHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) . MemInUse as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( MemInUse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_Payload_t ) ) . UnmarkedMem
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_Payload_t
                ) , "::" , stringify ! ( UnmarkedMem ) ));
}
impl Clone for CFE_SB_HKMsg_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_HKMsg_t {
    /**< \brief cFE Software Bus Telemetry Message Header */
    pub Hdr: CFE_SB_TlmHdr_t,
    pub Payload: CFE_SB_HKMsg_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_SB_HKMsg_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_HKMsg_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( CFE_SB_HKMsg_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_HKMsg_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CFE_SB_HKMsg_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_t ) ) . Hdr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_t ) , "::"
                , stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_HKMsg_t ) ) . Payload as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_HKMsg_t ) , "::"
                , stringify ! ( Payload ) ));
}
impl Clone for CFE_SB_HKMsg_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief SB Pipe Depth Statistics
**
** Used in SB Statistics Telemetry Packet #CFE_SB_StatMsg_t
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_PipeDepthStats_t {
    /**< \cfetlmmnemonic \SB_PDPIPEID
                                    \brief Pipe Id associated with the stats below */
    pub PipeId: CFE_SB_PipeId_t,
    /**< \cfetlmmnemonic \SB_PDSPARE
                                   \brief Spare byte to ensure alignment */
    pub Spare: uint8,
    /**< \cfetlmmnemonic \SB_PDDEPTH
                                   \brief Number of messages the pipe can hold */
    pub Depth: uint16,
    /**< \cfetlmmnemonic \SB_PDINUSE
                                   \brief Number of messages currently on the pipe */
    pub InUse: uint16,
    /**< \cfetlmmnemonic \SB_PDPKINUSE
                                       \brief Peak number of messages that have been on the pipe */
    pub PeakInUse: uint16,
}
#[test]
fn bindgen_test_layout_CFE_SB_PipeDepthStats_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_PipeDepthStats_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_SB_PipeDepthStats_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_PipeDepthStats_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_SB_PipeDepthStats_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_PipeDepthStats_t ) ) . PipeId as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_PipeDepthStats_t
                ) , "::" , stringify ! ( PipeId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_PipeDepthStats_t ) ) . Spare as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_PipeDepthStats_t
                ) , "::" , stringify ! ( Spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_PipeDepthStats_t ) ) . Depth as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_PipeDepthStats_t
                ) , "::" , stringify ! ( Depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_PipeDepthStats_t ) ) . InUse as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_PipeDepthStats_t
                ) , "::" , stringify ! ( InUse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_PipeDepthStats_t ) ) . PeakInUse
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_PipeDepthStats_t
                ) , "::" , stringify ! ( PeakInUse ) ));
}
impl Clone for CFE_SB_PipeDepthStats_t {
    fn clone(&self) -> Self { *self }
}
/**
** \cfesbtlm SB Statistics Telemetry Packet
**
** SB Statistics packet sent (via CFE_SB_SendMsg) in response to #CFE_SB_SEND_SB_STATS_CC
*/
#[repr(C)]
pub struct CFE_SB_StatMsg_Payload_t {
    /**< \cfetlmmnemonic \SB_SMMIDIU
                                         \brief Current number of MsgIds with a destination */
    pub MsgIdsInUse: uint32,
    /**< \cfetlmmnemonic \SB_SMPMIDIU
                                             \brief Peak number of MsgIds with a destination */
    pub PeakMsgIdsInUse: uint32,
    /**< \cfetlmmnemonic \SB_SMMMIDALW
                                              \brief cFE Cfg Param \link #CFE_SB_MAX_MSG_IDS \endlink */
    pub MaxMsgIdsAllowed: uint32,
    /**< \cfetlmmnemonic \SB_SMPIU
                                        \brief Number of pipes currently in use */
    pub PipesInUse: uint32,
    /**< \cfetlmmnemonic \SB_SMPPIU
                                            \brief Peak number of pipes since last reboot */
    pub PeakPipesInUse: uint32,
    /**< \cfetlmmnemonic \SB_SMMPALW
                                             \brief cFE Cfg Param \link #CFE_SB_MAX_PIPES \endlink */
    pub MaxPipesAllowed: uint32,
    /**< \cfetlmmnemonic \SB_SMBMIU
                                         \brief Memory bytes currently in use for SB msg transfers */
    pub MemInUse: uint32,
    /**< \cfetlmmnemonic \SB_SMPBMIU
                                             \brief Peak memory bytes in use for SB msg transfers */
    pub PeakMemInUse: uint32,
    /**< \cfetlmmnemonic \SB_SMMBMALW
                                              \brief cFE Cfg Param \link #CFE_SB_BUF_MEMORY_BYTES \endlink */
    pub MaxMemAllowed: uint32,
    /**< \cfetlmmnemonic \SB_SMSIU
                                                \brief Number of current subscriptions */
    pub SubscriptionsInUse: uint32,
    /**< \cfetlmmnemonic \SB_SMPSIU
                                                    \brief Peak number of subscriptions */
    pub PeakSubscriptionsInUse: uint32,
    /**< \cfetlmmnemonic \SB_SMMSALW
                                                     \brief product of \link #CFE_SB_MAX_MSG_IDS \endlink
                                                     and \link #CFE_SB_MAX_DEST_PER_PKT \endlink */
    pub MaxSubscriptionsAllowed: uint32,
    /**< \cfetlmmnemonic \SB_SMSBBIU
                                            \brief Number of SB message buffers currently in use */
    pub SBBuffersInUse: uint32,
    /**< \cfetlmmnemonic \SB_SMPSBBIU
                                                \brief Max number of SB message buffers in use */
    pub PeakSBBuffersInUse: uint32,
    /**< \cfetlmmnemonic \SB_SMMPDALW
                                                 \brief cFE Cfg Param \link #CFE_SB_MAX_PIPE_DEPTH \endlink */
    pub MaxPipeDepthAllowed: uint32,
    /**< \cfetlmmnemonic \SB_SMPDS
                                                                  \brief Pipe Depth Statistics #CFE_SB_PipeDepthStats_t*/
    pub PipeDepthStats: [CFE_SB_PipeDepthStats_t; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_SB_StatMsg_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_StatMsg_Payload_t>() , 572usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_SB_StatMsg_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_StatMsg_Payload_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_SB_StatMsg_Payload_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                MsgIdsInUse as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! ( MsgIdsInUse
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                PeakMsgIdsInUse as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                PeakMsgIdsInUse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                MaxMsgIdsAllowed as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                MaxMsgIdsAllowed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) . PipesInUse
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! ( PipesInUse )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                PeakPipesInUse as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                PeakPipesInUse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                MaxPipesAllowed as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                MaxPipesAllowed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) . MemInUse
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! ( MemInUse )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                PeakMemInUse as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! ( PeakMemInUse
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                MaxMemAllowed as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                MaxMemAllowed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                SubscriptionsInUse as * const _ as usize } , 36usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                SubscriptionsInUse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                PeakSubscriptionsInUse as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                PeakSubscriptionsInUse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                MaxSubscriptionsAllowed as * const _ as usize } , 44usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                MaxSubscriptionsAllowed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                SBBuffersInUse as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                SBBuffersInUse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                PeakSBBuffersInUse as * const _ as usize } , 52usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                PeakSBBuffersInUse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                MaxPipeDepthAllowed as * const _ as usize } , 56usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                MaxPipeDepthAllowed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_Payload_t ) ) .
                PipeDepthStats as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_StatMsg_Payload_t ) , "::" , stringify ! (
                PipeDepthStats ) ));
}
#[repr(C)]
pub struct CFE_SB_StatMsg_t {
    /**< \brief cFE Software Bus Telemetry Message Header */
    pub Hdr: CFE_SB_TlmHdr_t,
    pub Payload: CFE_SB_StatMsg_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_SB_StatMsg_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_StatMsg_t>() , 584usize , concat !
               ( "Size of: " , stringify ! ( CFE_SB_StatMsg_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_StatMsg_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( CFE_SB_StatMsg_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_t ) ) . Hdr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_StatMsg_t ) ,
                "::" , stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_StatMsg_t ) ) . Payload as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_StatMsg_t ) ,
                "::" , stringify ! ( Payload ) ));
}
/**
** \brief SB Routing File Entry
**
** Structure of one element of the routing information in response to #CFE_SB_SEND_ROUTING_INFO_CC
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_RoutingFileEntry_t {
    /**< \brief Message Id portion of the route */
    pub MsgId: CFE_SB_MsgId_t,
    /**< \brief Pipe Id portion of the route */
    pub PipeId: CFE_SB_PipeId_t,
    /**< \brief Route Enabled or Disabled */
    pub State: uint8,
    /**< \brief Number of msgs with this MsgId sent to this PipeId */
    pub MsgCnt: uint16,
    /**< \brief Pipe Depth Statistics */
    pub AppName: [::std::os::raw::c_char; 20usize],
    /**< \brief Pipe Depth Statistics */
    pub PipeName: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout_CFE_SB_RoutingFileEntry_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_RoutingFileEntry_t>() , 46usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_SB_RoutingFileEntry_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_RoutingFileEntry_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_SB_RoutingFileEntry_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_RoutingFileEntry_t ) ) . MsgId as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_RoutingFileEntry_t ) , "::" , stringify ! ( MsgId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_RoutingFileEntry_t ) ) . PipeId as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_RoutingFileEntry_t ) , "::" , stringify ! ( PipeId )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_RoutingFileEntry_t ) ) . State as
                * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_RoutingFileEntry_t ) , "::" , stringify ! ( State ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_RoutingFileEntry_t ) ) . MsgCnt as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_RoutingFileEntry_t ) , "::" , stringify ! ( MsgCnt )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_RoutingFileEntry_t ) ) . AppName
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_RoutingFileEntry_t ) , "::" , stringify ! ( AppName )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_RoutingFileEntry_t ) ) . PipeName
                as * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_RoutingFileEntry_t ) , "::" , stringify ! ( PipeName )
                ));
}
impl Clone for CFE_SB_RoutingFileEntry_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief SB Map File Entry
**
** Structure of one element of the map information in response to #CFE_SB_SEND_MAP_INFO_CC
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_MsgMapFileEntry_t {
    /**< \brief Message Id which has been subscribed to */
    pub MsgId: uint16,
    /**< \brief Routing table index where pipe destinations are found */
    pub Index: uint16,
}
#[test]
fn bindgen_test_layout_CFE_SB_MsgMapFileEntry_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_MsgMapFileEntry_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_SB_MsgMapFileEntry_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_MsgMapFileEntry_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_SB_MsgMapFileEntry_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_MsgMapFileEntry_t ) ) . MsgId as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_MsgMapFileEntry_t ) , "::" , stringify ! ( MsgId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_MsgMapFileEntry_t ) ) . Index as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_MsgMapFileEntry_t ) , "::" , stringify ! ( Index ) ));
}
impl Clone for CFE_SB_MsgMapFileEntry_t {
    fn clone(&self) -> Self { *self }
}
/**
** \cfesbtlm SB Subscription Report Packet
**
** This structure defines the pkt sent by SB when a subscription or
** a request to unsubscribe is received while subscription reporting is enabled.
** By default subscription reporting is disabled. This feature is intended to be
** used primarily by Software Bus Networking Application (SBN)
**
** \sa #CFE_SB_ENABLE_SUB_REPORTING_CC, #CFE_SB_DISABLE_SUB_REPORTING_CC
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_SubRprtMsg_Payload_t {
    /**< \brief Subscription or Unsubscription */
    pub SubType: uint8,
    /**< \brief MsgId subscribed or unsubscribe to */
    pub MsgId: CFE_SB_MsgId_t,
    /**< \brief Quality of Service, used only for interprocessor communication */
    pub Qos: CFE_SB_Qos_t,
    /**< \brief Destination pipe id to send above msg id  */
    pub Pipe: CFE_SB_PipeId_t,
}
#[test]
fn bindgen_test_layout_CFE_SB_SubRprtMsg_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_SubRprtMsg_Payload_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_SB_SubRprtMsg_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_SubRprtMsg_Payload_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_SB_SubRprtMsg_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_SubRprtMsg_Payload_t ) ) . SubType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_SubRprtMsg_Payload_t ) , "::" , stringify ! ( SubType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_SubRprtMsg_Payload_t ) ) . MsgId
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_SubRprtMsg_Payload_t ) , "::" , stringify ! ( MsgId )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_SubRprtMsg_Payload_t ) ) . Qos as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_SubRprtMsg_Payload_t ) , "::" , stringify ! ( Qos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_SubRprtMsg_Payload_t ) ) . Pipe as
                * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_SubRprtMsg_Payload_t ) , "::" , stringify ! ( Pipe )
                ));
}
impl Clone for CFE_SB_SubRprtMsg_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_SubRprtMsg_t {
    /**< \brief cFE Software Bus Telemetry Message Header */
    pub Hdr: CFE_SB_TlmHdr_t,
    pub Payload: CFE_SB_SubRprtMsg_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_SB_SubRprtMsg_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_SubRprtMsg_t>() , 20usize , concat
               ! ( "Size of: " , stringify ! ( CFE_SB_SubRprtMsg_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_SubRprtMsg_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_SB_SubRprtMsg_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_SubRprtMsg_t ) ) . Hdr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_SubRprtMsg_t ) ,
                "::" , stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_SubRprtMsg_t ) ) . Payload as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_SubRprtMsg_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_SB_SubRprtMsg_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief SB Previous Subscriptions Entry
**
** This structure defines an entry used in the CFE_SB_PrevSubsPkt_t
** Intended to be used primarily by Software Bus Networking Application (SBN)
**
** Used in structure definition #CFE_SB_PrevSubMsg_t
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_SubEntries_t {
    /**< \brief MsgId portion of the subscription */
    pub MsgId: CFE_SB_MsgId_t,
    /**< \brief Qos portion of the subscription */
    pub Qos: CFE_SB_Qos_t,
    /**< \brief PipeId portion of the subscription */
    pub Pipe: CFE_SB_PipeId_t,
}
#[test]
fn bindgen_test_layout_CFE_SB_SubEntries_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_SubEntries_t>() , 6usize , concat
               ! ( "Size of: " , stringify ! ( CFE_SB_SubEntries_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_SubEntries_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_SB_SubEntries_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_SubEntries_t ) ) . MsgId as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_SubEntries_t ) ,
                "::" , stringify ! ( MsgId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_SubEntries_t ) ) . Qos as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_SubEntries_t ) ,
                "::" , stringify ! ( Qos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_SubEntries_t ) ) . Pipe as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_SubEntries_t ) ,
                "::" , stringify ! ( Pipe ) ));
}
impl Clone for CFE_SB_SubEntries_t {
    fn clone(&self) -> Self { *self }
}
/**
** \cfesbtlm SB Previous Subscriptions Packet
**
** This structure defines the pkt(s) sent by SB that contains a list of all current
** subscriptions. This pkt is generated on cmd and intended to be used primarily by
** the Software Bus Networking Application (SBN). Typically, when the cmd is received
** there are more subscriptions than can fit in one pkt. The complete list of
** subscriptions is sent via a series of segmented pkts.
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_PrevSubMsg_Payload_t {
    /**< \brief Pkt number(starts at 1) in the series */
    pub PktSegment: uint32,
    /**< \brief Total number of pkts needed to complete the request */
    pub TotalSegments: uint32,
    /**< \brief Number of entries in the pkt */
    pub Entries: uint32,
    /**< \brief Array of #CFE_SB_SubEntries_t entries */
    pub Entry: [CFE_SB_SubEntries_t; 20usize],
}
#[test]
fn bindgen_test_layout_CFE_SB_PrevSubMsg_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_PrevSubMsg_Payload_t>() , 132usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_SB_PrevSubMsg_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_SB_PrevSubMsg_Payload_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_SB_PrevSubMsg_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_PrevSubMsg_Payload_t ) ) .
                PktSegment as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_PrevSubMsg_Payload_t ) , "::" , stringify ! (
                PktSegment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_PrevSubMsg_Payload_t ) ) .
                TotalSegments as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_PrevSubMsg_Payload_t ) , "::" , stringify ! (
                TotalSegments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_PrevSubMsg_Payload_t ) ) . Entries
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_PrevSubMsg_Payload_t ) , "::" , stringify ! ( Entries )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_PrevSubMsg_Payload_t ) ) . Entry
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_SB_PrevSubMsg_Payload_t ) , "::" , stringify ! ( Entry )
                ));
}
impl Clone for CFE_SB_PrevSubMsg_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_SB_PrevSubMsg_t {
    /**< \brief cFE Software Bus Telemetry Message Header */
    pub Hdr: CFE_SB_TlmHdr_t,
    pub Payload: CFE_SB_PrevSubMsg_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_SB_PrevSubMsg_t() {
    assert_eq!(::std::mem::size_of::<CFE_SB_PrevSubMsg_t>() , 144usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_SB_PrevSubMsg_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_SB_PrevSubMsg_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_SB_PrevSubMsg_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_PrevSubMsg_t ) ) . Hdr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_PrevSubMsg_t ) ,
                "::" , stringify ! ( Hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_SB_PrevSubMsg_t ) ) . Payload as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_SB_PrevSubMsg_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_SB_PrevSubMsg_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct CFE_TBL_File_Hdr_t {
    /**< Future Use: NumTblSegments in File?   */
    pub Reserved: uint32,
    /**< Byte Offset at which load should commence */
    pub Offset: uint32,
    /**< Number of bytes to load into table */
    pub NumBytes: uint32,
    /**< Fully qualified name of table to load */
    pub TableName: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_File_Hdr_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_File_Hdr_t>() , 52usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TBL_File_Hdr_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_File_Hdr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_TBL_File_Hdr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_File_Hdr_t ) ) . Reserved as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_File_Hdr_t ) ,
                "::" , stringify ! ( Reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_File_Hdr_t ) ) . Offset as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_File_Hdr_t ) ,
                "::" , stringify ! ( Offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_File_Hdr_t ) ) . NumBytes as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_File_Hdr_t ) ,
                "::" , stringify ! ( NumBytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_File_Hdr_t ) ) . TableName as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_File_Hdr_t ) ,
                "::" , stringify ! ( TableName ) ));
}
#[repr(C)]
pub struct CFE_TBL_FileDef_t {
    /**< \brief Name of instantiated variable that contains desired table image */
    pub ObjectName: [::std::os::raw::c_char; 64usize],
    /**< \brief Name of Table as defined onboard */
    pub TableName: [::std::os::raw::c_char; 40usize],
    /**< \brief Description of table image that is included in cFE File Header */
    pub Description: [::std::os::raw::c_char; 32usize],
    /**< \brief Default filename to be used for output of elf2cfetbl utility  */
    pub TgtFilename: [::std::os::raw::c_char; 20usize],
    /**< \brief Size, in bytes, of instantiated object */
    pub ObjectSize: uint32,
}
#[test]
fn bindgen_test_layout_CFE_TBL_FileDef_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_FileDef_t>() , 160usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TBL_FileDef_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_FileDef_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_TBL_FileDef_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_FileDef_t ) ) . ObjectName as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_FileDef_t ) ,
                "::" , stringify ! ( ObjectName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_FileDef_t ) ) . TableName as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_FileDef_t ) ,
                "::" , stringify ! ( TableName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_FileDef_t ) ) . Description as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_FileDef_t ) ,
                "::" , stringify ! ( Description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_FileDef_t ) ) . TgtFilename as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_FileDef_t ) ,
                "::" , stringify ! ( TgtFilename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_FileDef_t ) ) . ObjectSize as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_FileDef_t ) ,
                "::" , stringify ! ( ObjectSize ) ));
}
/********************************/
/**
** \brief Generic "no arguments" command
**
** This command structure is used for commands that do not have any parameters.
** This includes:
** -# The Housekeeping Request Message
** -# The No-Op Command (For details, see #CFE_TBL_NOOP_CC)
** -# The Reset Counters Command (For details, see #CFE_TBL_RESET_CC)
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TBL_NoArgsCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_NoArgsCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_NoArgsCmd_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TBL_NoArgsCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_NoArgsCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_NoArgsCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_NoArgsCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_NoArgsCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
}
impl Clone for CFE_TBL_NoArgsCmd_t {
    fn clone(&self) -> Self { *self }
}
/**
** \brief Load Table Command
**
** For command details, see #CFE_TBL_LOAD_CC
**
**/
#[repr(C)]
pub struct CFE_TBL_LoadCmd_Payload_t {
    /**< \brief Filename (and path) of data to be loaded */
                                                          /**< ASCII Character string containing full path 
                                                               filename for file to be loaded */
    pub LoadFilename: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_LoadCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_LoadCmd_Payload_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_TBL_LoadCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_LoadCmd_Payload_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_LoadCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_LoadCmd_Payload_t ) ) .
                LoadFilename as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_LoadCmd_Payload_t ) , "::" , stringify ! (
                LoadFilename ) ));
}
#[repr(C)]
pub struct CFE_TBL_LoadCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TBL_LoadCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TBL_LoadCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_LoadCmd_t>() , 72usize , concat !
               ( "Size of: " , stringify ! ( CFE_TBL_LoadCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_LoadCmd_t>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_TBL_LoadCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_LoadCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_LoadCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_LoadCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_LoadCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
/**
** \brief Dump Table Command
**
** For command details, see #CFE_TBL_DUMP_CC
*/
#[repr(C)]
pub struct CFE_TBL_DumpCmd_Payload_t {
    /**< \brief #CFE_TBL_INACTIVE_BUFFER=Inactive Table, 
                                                                            #CFE_TBL_ACTIVE_BUFFER=Active Table */
                                                                /**< Selects either the "Inactive" 
                                                                     (#CFE_TBL_INACTIVE_BUFFER) buffer or the 
                                                                     "Active" (#CFE_TBL_ACTIVE_BUFFER) buffer 
                                                                     to be dumped */
    pub ActiveTblFlag: uint16,
    /**< \brief Full name of table to be dumped */
                                                                /**< ASCII string containing full table name 
                                                                     identifier of table to be dumped */
    pub TableName: [::std::os::raw::c_char; 40usize],
    /**< \brief Full Filename where data is to be written */
                                                                /**< ASCII string containing full path of filename 
                                                                     where data is to be dumped */
    pub DumpFilename: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_DumpCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_DumpCmd_Payload_t>() , 106usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_TBL_DumpCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_DumpCmd_Payload_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_DumpCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_DumpCmd_Payload_t ) ) .
                ActiveTblFlag as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_DumpCmd_Payload_t ) , "::" , stringify ! (
                ActiveTblFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_DumpCmd_Payload_t ) ) . TableName
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_DumpCmd_Payload_t ) , "::" , stringify ! ( TableName )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_DumpCmd_Payload_t ) ) .
                DumpFilename as * const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_DumpCmd_Payload_t ) , "::" , stringify ! (
                DumpFilename ) ));
}
#[repr(C)]
pub struct CFE_TBL_DumpCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TBL_DumpCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TBL_DumpCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_DumpCmd_t>() , 114usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TBL_DumpCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_DumpCmd_t>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_TBL_DumpCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_DumpCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_DumpCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_DumpCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_DumpCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
/**
** \brief Validate Table Command
**
** For command details, see #CFE_TBL_VALIDATE_CC
*/
#[repr(C)]
pub struct CFE_TBL_ValidateCmd_Payload_t {
    /**< \brief #CFE_TBL_INACTIVE_BUFFER=Inactive Table, 
                                                                             #CFE_TBL_ACTIVE_BUFFER=Active Table */
                                                                 /**< Selects either the "Inactive" 
                                                                      (#CFE_TBL_INACTIVE_BUFFER) buffer or the 
                                                                      "Active" (#CFE_TBL_ACTIVE_BUFFER) buffer 
                                                                      to be validated */
    pub ActiveTblFlag: uint16,
    /**< \brief Full Name of Table to be validated */
                                                                 /**< ASCII string containing full table name 
                                                                      identifier of table to be validated */
    pub TableName: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_ValidateCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_ValidateCmd_Payload_t>() ,
               42usize , concat ! (
               "Size of: " , stringify ! ( CFE_TBL_ValidateCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_ValidateCmd_Payload_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_ValidateCmd_Payload_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_ValidateCmd_Payload_t ) ) .
                ActiveTblFlag as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_ValidateCmd_Payload_t ) , "::" , stringify ! (
                ActiveTblFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_ValidateCmd_Payload_t ) ) .
                TableName as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_ValidateCmd_Payload_t ) , "::" , stringify ! (
                TableName ) ));
}
#[repr(C)]
pub struct CFE_TBL_ValidateCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TBL_ValidateCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TBL_ValidateCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_ValidateCmd_t>() , 50usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TBL_ValidateCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_ValidateCmd_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_ValidateCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_ValidateCmd_t ) ) . CmdHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_ValidateCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_ValidateCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_ValidateCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Activate Table Command
**
** For command details, see #CFE_TBL_ACTIVATE_CC
*/
#[repr(C)]
pub struct CFE_TBL_ActivateCmd_Payload_t {
    /**< \brief Full Name of Table to be activated */
                                                                 /**< ASCII string containing full table name 
                                                                      identifier of table to be activated */
    pub TableName: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_ActivateCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_ActivateCmd_Payload_t>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( CFE_TBL_ActivateCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_ActivateCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_ActivateCmd_Payload_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_ActivateCmd_Payload_t ) ) .
                TableName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_ActivateCmd_Payload_t ) , "::" , stringify ! (
                TableName ) ));
}
#[repr(C)]
pub struct CFE_TBL_ActivateCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TBL_ActivateCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TBL_ActivateCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_ActivateCmd_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TBL_ActivateCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_ActivateCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_ActivateCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_ActivateCmd_t ) ) . CmdHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_ActivateCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_ActivateCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_ActivateCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Dump Registry Command
**
** For command details, see #CFE_TBL_DUMP_REG_CC
*/
#[repr(C)]
pub struct CFE_TBL_DumpRegCmd_Payload_t {
    /**< \brief Full Filename where dumped data is to be 
                                                                     written */
                                                                /**< ASCII string containing full path of filename 
                                                                     where registry is to be dumped */
    pub DumpFilename: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_DumpRegCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_DumpRegCmd_Payload_t>() , 64usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_TBL_DumpRegCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_DumpRegCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_DumpRegCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_DumpRegCmd_Payload_t ) ) .
                DumpFilename as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_DumpRegCmd_Payload_t ) , "::" , stringify ! (
                DumpFilename ) ));
}
#[repr(C)]
pub struct CFE_TBL_DumpRegCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TBL_DumpRegCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TBL_DumpRegCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_DumpRegCmd_t>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TBL_DumpRegCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_DumpRegCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_DumpRegCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_DumpRegCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_DumpRegCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_DumpRegCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_DumpRegCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
/**
** \brief Telemeter Table Registry Entry Command
**
** For command details, see #CFE_TBL_TLM_REG_CC
*/
#[repr(C)]
pub struct CFE_TBL_TlmRegCmd_Payload_t {
    /**< \brief Full Name of Table whose registry entry 
                                                                      is to be telemetered */
                                                                 /**< ASCII string containing full table name 
                                                                      identifier of table whose registry entry is
                                                                      to be telemetered via #CFE_TBL_TblRegPacket_t */
    pub TableName: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_TlmRegCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_TlmRegCmd_Payload_t>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_TBL_TlmRegCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_TlmRegCmd_Payload_t>() , 1usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_TlmRegCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TlmRegCmd_Payload_t ) ) .
                TableName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TlmRegCmd_Payload_t ) , "::" , stringify ! ( TableName
                ) ));
}
#[repr(C)]
pub struct CFE_TBL_TlmRegCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TBL_TlmRegCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TBL_TlmRegCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_TlmRegCmd_t>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TBL_TlmRegCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_TlmRegCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_TlmRegCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TlmRegCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_TlmRegCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TlmRegCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_TlmRegCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
/**
** \brief Delete Critical Table CDS Command
**
** For command details, see #CFE_TBL_DELETE_CDS_CC
*/
#[repr(C)]
pub struct CFE_TBL_DelCDSCmd_Payload_t {
    /**< \brief Full Name of Table whose CDS is 
                                                                      to be deleted */
                                                                 /**< ASCII string containing full table name 
                                                                      identifier of a critical table whose 
                                                                      CDS is to be deleted */
    pub TableName: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_DelCDSCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_DelCDSCmd_Payload_t>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_TBL_DelCDSCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_DelCDSCmd_Payload_t>() , 1usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_DelCDSCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_DelCDSCmd_Payload_t ) ) .
                TableName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_DelCDSCmd_Payload_t ) , "::" , stringify ! ( TableName
                ) ));
}
#[repr(C)]
pub struct CFE_TBL_DelCDSCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TBL_DelCDSCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TBL_DelCDSCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_DelCDSCmd_t>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TBL_DelCDSCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_DelCDSCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_DelCDSCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_DelCDSCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_DelCDSCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_DelCDSCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_DelCDSCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
/**
** \brief Abort Load Command
**
** For command details, see #CFE_TBL_ABORT_LOAD_CC
*/
#[repr(C)]
pub struct CFE_TBL_AbortLdCmd_Payload_t {
    /**< \brief Full Name of Table whose load is to be aborted */
                                                                 /**< ASCII string containing full table name 
                                                                      identifier of a table whose load is to be aborted */
    pub TableName: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_AbortLdCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_AbortLdCmd_Payload_t>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_TBL_AbortLdCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_AbortLdCmd_Payload_t>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_AbortLdCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_AbortLdCmd_Payload_t ) ) .
                TableName as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_AbortLdCmd_Payload_t ) , "::" , stringify ! (
                TableName ) ));
}
#[repr(C)]
pub struct CFE_TBL_AbortLdCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TBL_AbortLdCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TBL_AbortLdCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_AbortLdCmd_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TBL_AbortLdCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_AbortLdCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_AbortLdCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_AbortLdCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_AbortLdCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_AbortLdCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_AbortLdCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
/******************************************/
/**
** \brief Table Management Notification Message
**
** \par Description
**      Whenever an application that owns a table calls the #CFE_TBL_NotifyByMessage API
**      following the table registration, Table services will generate the following
**      command message with the application specified message ID, command code and
**      parameter whenever the table requires management (e.g. - loads and validations).
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TBL_NotifyCmd_Payload_t {
    /**< \brief Application specified command parameter */
    pub Parameter: uint32,
}
#[test]
fn bindgen_test_layout_CFE_TBL_NotifyCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_NotifyCmd_Payload_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_TBL_NotifyCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_NotifyCmd_Payload_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_NotifyCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_NotifyCmd_Payload_t ) ) .
                Parameter as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_NotifyCmd_Payload_t ) , "::" , stringify ! ( Parameter
                ) ));
}
impl Clone for CFE_TBL_NotifyCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TBL_NotifyCmd_t {
    /**< \brief cFE Software Bus Command Message Header */
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TBL_NotifyCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TBL_NotifyCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_NotifyCmd_t>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TBL_NotifyCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_NotifyCmd_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_NotifyCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_NotifyCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_NotifyCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_NotifyCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_NotifyCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_TBL_NotifyCmd_t {
    fn clone(&self) -> Self { *self }
}
/**********************************/
/** 
**  \cfetbltlm Table Services Housekeeping Packet
**/
#[repr(C)]
pub struct CFE_TBL_HkPacket_Payload_t {
    /**< \cfetlmmnemonic \TBL_CMDPC 
                                                                     \brief Count of valid commands received */
    pub CmdCounter: uint8,
    /**< \cfetlmmnemonic \TBL_CMDEC 
                                                                     \brief Count of invalid commands received */
    pub ErrCounter: uint8,
    /**< \cfetlmmnemonic \TBL_NUMTABLES 
                                                                     \brief Number of Tables Registered */
    pub NumTables: uint16,
    /**< \cfetlmmnemonic \TBL_NUMUPDATESPEND 
                                                                     \brief Number of Tables pending on Applications for their update */
    pub NumLoadPending: uint16,
    /**< \cfetlmmnemonic \TBL_VALCOMPLTDCTR 
                                                                     \brief Number of completed table validations */
    pub ValidationCtr: uint16,
    /**< \cfetlmmnemonic \TBL_LASTVALCRC 
                                                                     \brief Data Integrity Value computed for last table validated */
    pub LastValCrc: uint32,
    /**< \cfetlmmnemonic \TBL_LASTVALS 
                                                                     \brief Returned status from validation function for last table validated */
    pub LastValStatus: int32,
    /**< \cfetlmmnemonic \TBL_LASTVALBUF 
                                                                     \brief Indicator of whether table buffer validated was 0=Inactive, 1=Active */
    pub ActiveBuffer: boolean,
    /**< \cfetlmmnemonic \TBL_LASTVALTBLNAME 
                                                                            \brief Name of last table validated */
    pub LastValTableName: [::std::os::raw::c_char; 40usize],
    /**< \cfetlmmnemonic \TBL_VALSUCCESSCTR 
                                                                     \brief Total number of successful table validations */
    pub SuccessValCtr: uint8,
    /**< \cfetlmmnemonic \TBL_VALFAILEDCTR 
                                                                     \brief Total number of unsuccessful table validations */
    pub FailedValCtr: uint8,
    /**< \cfetlmmnemonic \TBL_VALREQCTR 
                                                                     \brief Number of times Table Services has requested validations from Apps */
    pub NumValRequests: uint8,
    /**< \cfetlmmnemonic \TBL_NUMFREESHRBUF 
                                                                     \brief Number of free Shared Working Buffers */
    pub NumFreeSharedBufs: uint8,
    /**< \cfetlmmnemonic \TBL_BYTEALIGNPAD1 
                                                                     \brief Spare byte to ensure longword alignment */
    pub ByteAlignPad1: uint8,
    /**< \cfetlmmnemonic \TBL_MEMPOOLHANDLE 
                                                                     \brief Handle to TBL's memory pool */
    pub MemPoolHandle: CFE_ES_MemHandle_t,
    /**< \cfetlmmnemonic \TBL_LASTUPDTIME 
                                                                     \brief Time of last table update */
    pub LastUpdateTime: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TBL_LASTUPDTBLNAME 
                                                                          \brief Name of the last table updated */
    pub LastUpdatedTbl: [::std::os::raw::c_char; 40usize],
    /**< \cfetlmmnemonic \TBL_LASTFILELOADED 
                                                                     \brief Path and Name of last table image file loaded */
    pub LastFileLoaded: [::std::os::raw::c_char; 64usize],
    /**< \cfetlmmnemonic \TBL_LASTFILEDUMPED 
                                                                     \brief Path and Name of last file dumped to */
    pub LastFileDumped: [::std::os::raw::c_char; 64usize],
    /**< \cfetlmmnemonic \TBL_LASTTABLELOADED 
                                                                          \brief Name of the last table loaded */
    pub LastTableLoaded: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_CFE_TBL_HkPacket_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_HkPacket_Payload_t>() , 288usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_TBL_HkPacket_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_HkPacket_Payload_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_HkPacket_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                CmdCounter as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! ( CmdCounter
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                ErrCounter as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! ( ErrCounter
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                NumTables as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! ( NumTables
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                NumLoadPending as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                NumLoadPending ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                ValidationCtr as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                ValidationCtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                LastValCrc as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! ( LastValCrc
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                LastValStatus as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                LastValStatus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                ActiveBuffer as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                ActiveBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                LastValTableName as * const _ as usize } , 17usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                LastValTableName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                SuccessValCtr as * const _ as usize } , 57usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                SuccessValCtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                FailedValCtr as * const _ as usize } , 58usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                FailedValCtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                NumValRequests as * const _ as usize } , 59usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                NumValRequests ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                NumFreeSharedBufs as * const _ as usize } , 60usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                NumFreeSharedBufs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                ByteAlignPad1 as * const _ as usize } , 61usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                ByteAlignPad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                MemPoolHandle as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                MemPoolHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                LastUpdateTime as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                LastUpdateTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                LastUpdatedTbl as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                LastUpdatedTbl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                LastFileLoaded as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                LastFileLoaded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                LastFileDumped as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                LastFileDumped ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_Payload_t ) ) .
                LastTableLoaded as * const _ as usize } , 248usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_TBL_HkPacket_Payload_t ) , "::" , stringify ! (
                LastTableLoaded ) ));
}
#[repr(C)]
pub struct CFE_TBL_HkPacket_t {
    /**< \brief cFE Software Bus Telemetry Message Header */
    pub TlmHeader: [uint8; 12usize],
    pub Payload: CFE_TBL_HkPacket_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TBL_HkPacket_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_HkPacket_t>() , 304usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TBL_HkPacket_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_HkPacket_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_TBL_HkPacket_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_t ) ) . TlmHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_HkPacket_t ) ,
                "::" , stringify ! ( TlmHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_HkPacket_t ) ) . Payload as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_HkPacket_t ) ,
                "::" , stringify ! ( Payload ) ));
}
/** 
**  \cfetbltlm Table Registry Info Packet
**/
#[repr(C)]
pub struct CFE_TBL_TblRegPacket_Payload_t {
    /**< \cfetlmmnemonic \TBL_SIZE 
                                                                     \brief Size, in bytes, of Table */
    pub Size: uint32,
    /**< \cfetlmmnemonic \TBL_CRC 
                                                                     \brief Most recently calculated CRC of Table */
    pub Crc: uint32,
    /**< \cfetlmmnemonic \TBL_ACTBUFADD
                                                                     \brief Address of Active Buffer */
    pub ActiveBufferAddr: cpuaddr,
    /**< \cfetlmmnemonic \TBL_IACTBUFADD
                                                                     \brief Address of Inactive Buffer */
    pub InactiveBufferAddr: cpuaddr,
    /**< \cfetlmmnemonic \TBL_VALFUNCPTR
                                                                     \brief Ptr to Owner App's function that validates tbl contents */
    pub ValidationFuncPtr: cpuaddr,
    /**< \cfetlmmnemonic \TBL_TIMELASTUPD 
                                                                     \brief Time when Table was last updated */
    pub TimeOfLastUpdate: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TBL_FILECSECONDS 
                                                                     \brief File creation time from last file loaded into table */
    pub FileCreateTimeSecs: uint32,
    /**< \cfetlmmnemonic \TBL_FILECSUBSECONDS 
                                                                     \brief File creation time from last file loaded into table */
    pub FileCreateTimeSubSecs: uint32,
    /**< \cfetlmmnemonic \TBL_LOADEDONCE 
                                                                     \brief Flag indicating whether table has been loaded once or not */
    pub TableLoadedOnce: boolean,
    /**< \cfetlmmnemonic \TBL_UPDATEPNDNG 
                                                                     \brief Flag indicating an inactive buffer is ready to be copied */
    pub LoadPending: boolean,
    /**< \cfetlmmnemonic \TBL_DUMPONLY 
                                                                     \brief Flag indicating Table is NOT to be loaded */
    pub DumpOnly: boolean,
    /**< \cfetlmmnemonic \TBL_DBLBUFFERED 
                                                                     \brief Flag indicating Table has a dedicated inactive buffer */
    pub DblBuffered: boolean,
    /**< \cfetlmmnemonic \TBL_NAME 
                                                                     \brief Processor specific table name */
    pub Name: [::std::os::raw::c_char; 40usize],
    /**< \cfetlmmnemonic \TBL_LASTFILEUPD 
                                                                     \brief Filename of last file loaded into table */
    pub LastFileLoaded: [::std::os::raw::c_char; 64usize],
    /**< \cfetlmmnemonic \TBL_OWNERAPP 
                                                                     \brief Name of owning application */
    pub OwnerAppName: [::std::os::raw::c_char; 20usize],
    /**< \cfetlmmnemonic \TBL_CRITICAL
                                                                     \brief Indicates whether table is Critical or not */
    pub Critical: boolean,
    /**< \cfetlmmnemonic \TBL_SPARE4
                                                                     \brief Spare byte to maintain byte alignment */
    pub ByteAlign4: uint8,
}
#[test]
fn bindgen_test_layout_CFE_TBL_TblRegPacket_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_TblRegPacket_Payload_t>() ,
               184usize , concat ! (
               "Size of: " , stringify ! ( CFE_TBL_TblRegPacket_Payload_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_TblRegPacket_Payload_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_TblRegPacket_Payload_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) . Size
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! ( Size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) . Crc
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! ( Crc )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                ActiveBufferAddr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                ActiveBufferAddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                InactiveBufferAddr as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                InactiveBufferAddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                ValidationFuncPtr as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                ValidationFuncPtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                TimeOfLastUpdate as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                TimeOfLastUpdate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                FileCreateTimeSecs as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                FileCreateTimeSecs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                FileCreateTimeSubSecs as * const _ as usize } , 44usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                FileCreateTimeSubSecs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                TableLoadedOnce as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                TableLoadedOnce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                LoadPending as * const _ as usize } , 49usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                LoadPending ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                DumpOnly as * const _ as usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                DumpOnly ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                DblBuffered as * const _ as usize } , 51usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                DblBuffered ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) . Name
                as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! ( Name )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                LastFileLoaded as * const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                LastFileLoaded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                OwnerAppName as * const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                OwnerAppName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                Critical as * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                Critical ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_Payload_t ) ) .
                ByteAlign4 as * const _ as usize } , 177usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TBL_TblRegPacket_Payload_t ) , "::" , stringify ! (
                ByteAlign4 ) ));
}
#[repr(C)]
pub struct CFE_TBL_TblRegPacket_t {
    /**< \brief cFE Software Bus Telemetry Message Header */
    pub TlmHeader: [uint8; 12usize],
    pub Payload: CFE_TBL_TblRegPacket_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TBL_TblRegPacket_t() {
    assert_eq!(::std::mem::size_of::<CFE_TBL_TblRegPacket_t>() , 200usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TBL_TblRegPacket_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TBL_TblRegPacket_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TBL_TblRegPacket_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_t ) ) . TlmHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_TblRegPacket_t
                ) , "::" , stringify ! ( TlmHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TBL_TblRegPacket_t ) ) . Payload as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TBL_TblRegPacket_t
                ) , "::" , stringify ! ( Payload ) ));
}
/*************************************************************************/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_NoArgsCmd_t {
    pub CmdHeader: [uint8; 8usize],
}
#[test]
fn bindgen_test_layout_CFE_TIME_NoArgsCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_NoArgsCmd_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TIME_NoArgsCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_NoArgsCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_NoArgsCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_NoArgsCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_NoArgsCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
}
impl Clone for CFE_TIME_NoArgsCmd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_LeapsCmd_Payload_t {
    pub LeapSeconds: int16,
}
#[test]
fn bindgen_test_layout_CFE_TIME_LeapsCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_LeapsCmd_Payload_t>() , 2usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_TIME_LeapsCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_LeapsCmd_Payload_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_LeapsCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_LeapsCmd_Payload_t ) ) .
                LeapSeconds as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_LeapsCmd_Payload_t ) , "::" , stringify ! (
                LeapSeconds ) ));
}
impl Clone for CFE_TIME_LeapsCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_LeapsCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TIME_LeapsCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TIME_LeapsCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_LeapsCmd_t>() , 10usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TIME_LeapsCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_LeapsCmd_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_LeapsCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_LeapsCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_LeapsCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_LeapsCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_LeapsCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_TIME_LeapsCmd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_StateCmd_Payload_t {
    /**< \brief #CFE_TIME_INVALID=Spacecraft time has not been accurately set,
                                                                     #CFE_TIME_VALID=Spacecraft clock has been accurately set,
                                                                     #CFE_TIME_FLYWHEEL=Force into FLYWHEEL mode   */
                                                         /**< Selects the current clock state */
    pub ClockState: int16,
}
#[test]
fn bindgen_test_layout_CFE_TIME_StateCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_StateCmd_Payload_t>() , 2usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_TIME_StateCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_StateCmd_Payload_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_StateCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_StateCmd_Payload_t ) ) .
                ClockState as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_StateCmd_Payload_t ) , "::" , stringify ! (
                ClockState ) ));
}
impl Clone for CFE_TIME_StateCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_StateCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TIME_StateCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TIME_StateCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_StateCmd_t>() , 10usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TIME_StateCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_StateCmd_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_StateCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_StateCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_StateCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_StateCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_StateCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_TIME_StateCmd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_SourceCmd_Payload_t {
    /**< \brief #CFE_TIME_USE_INTERN=Internal Source,
                                                                     #CFE_TIME_USE_EXTERN=External Source   */
                                                         /**< Selects either the "Internal" and "External" clock source */
    pub TimeSource: int16,
}
#[test]
fn bindgen_test_layout_CFE_TIME_SourceCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_SourceCmd_Payload_t>() , 2usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_TIME_SourceCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_SourceCmd_Payload_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_SourceCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_SourceCmd_Payload_t ) ) .
                TimeSource as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_SourceCmd_Payload_t ) , "::" , stringify ! (
                TimeSource ) ));
}
impl Clone for CFE_TIME_SourceCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_SourceCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TIME_SourceCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TIME_SourceCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_SourceCmd_t>() , 10usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TIME_SourceCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_SourceCmd_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_SourceCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_SourceCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_SourceCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_SourceCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_SourceCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_TIME_SourceCmd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_SignalCmd_Payload_t {
    /**< \brief #CFE_TIME_TONE_PRI=Primary Source,
                                                                     #CFE_TIME_TONE_RED=Redundant Source   */
                                                         /**< Selects either the "Primary" or "Redundant" tone signal source */
    pub ToneSource: int16,
}
#[test]
fn bindgen_test_layout_CFE_TIME_SignalCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_SignalCmd_Payload_t>() , 2usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_TIME_SignalCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_SignalCmd_Payload_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_SignalCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_SignalCmd_Payload_t ) ) .
                ToneSource as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_SignalCmd_Payload_t ) , "::" , stringify ! (
                ToneSource ) ));
}
impl Clone for CFE_TIME_SignalCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_SignalCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TIME_SignalCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TIME_SignalCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_SignalCmd_t>() , 10usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TIME_SignalCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_SignalCmd_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_SignalCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_SignalCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_SignalCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_SignalCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_SignalCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_TIME_SignalCmd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_TimeCmd_Payload_t {
    pub Seconds: uint32,
    pub MicroSeconds: uint32,
}
#[test]
fn bindgen_test_layout_CFE_TIME_TimeCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_TimeCmd_Payload_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_TIME_TimeCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_TimeCmd_Payload_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_TimeCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_TimeCmd_Payload_t ) ) . Seconds
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_TimeCmd_Payload_t ) , "::" , stringify ! ( Seconds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_TimeCmd_Payload_t ) ) .
                MicroSeconds as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_TimeCmd_Payload_t ) , "::" , stringify ! (
                MicroSeconds ) ));
}
impl Clone for CFE_TIME_TimeCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_TimeCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TIME_TimeCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TIME_TimeCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_TimeCmd_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TIME_TimeCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_TimeCmd_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_TIME_TimeCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_TimeCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_TimeCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_TimeCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_TimeCmd_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_TIME_TimeCmd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_1HzAdjCmd_Payload_t {
    pub Seconds: uint32,
    pub Subseconds: uint32,
}
#[test]
fn bindgen_test_layout_CFE_TIME_1HzAdjCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_1HzAdjCmd_Payload_t>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_TIME_1HzAdjCmd_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_1HzAdjCmd_Payload_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_1HzAdjCmd_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_1HzAdjCmd_Payload_t ) ) .
                Seconds as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_1HzAdjCmd_Payload_t ) , "::" , stringify ! ( Seconds
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_1HzAdjCmd_Payload_t ) ) .
                Subseconds as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_1HzAdjCmd_Payload_t ) , "::" , stringify ! (
                Subseconds ) ));
}
impl Clone for CFE_TIME_1HzAdjCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_1HzAdjCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TIME_1HzAdjCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TIME_1HzAdjCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_1HzAdjCmd_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TIME_1HzAdjCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_1HzAdjCmd_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_1HzAdjCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_1HzAdjCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_1HzAdjCmd_t )
                , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_1HzAdjCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_1HzAdjCmd_t )
                , "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_TIME_1HzAdjCmd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_1HzCmd_t {
    pub CmdHeader: [uint8; 8usize],
}
#[test]
fn bindgen_test_layout_CFE_TIME_1HzCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_1HzCmd_t>() , 8usize , concat !
               ( "Size of: " , stringify ! ( CFE_TIME_1HzCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_1HzCmd_t>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( CFE_TIME_1HzCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_1HzCmd_t ) ) . CmdHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_1HzCmd_t ) ,
                "::" , stringify ! ( CmdHeader ) ));
}
impl Clone for CFE_TIME_1HzCmd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_ToneSignalCmd_t {
    pub CmdHeader: [uint8; 8usize],
}
#[test]
fn bindgen_test_layout_CFE_TIME_ToneSignalCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_ToneSignalCmd_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( CFE_TIME_ToneSignalCmd_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_ToneSignalCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_ToneSignalCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ToneSignalCmd_t ) ) . CmdHeader
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_ToneSignalCmd_t ) , "::" , stringify ! ( CmdHeader )
                ));
}
impl Clone for CFE_TIME_ToneSignalCmd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_FakeToneCmd_t {
    pub CmdHeader: [uint8; 8usize],
}
#[test]
fn bindgen_test_layout_CFE_TIME_FakeToneCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_FakeToneCmd_t>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TIME_FakeToneCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_FakeToneCmd_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_FakeToneCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_FakeToneCmd_t ) ) . CmdHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_FakeToneCmd_t
                ) , "::" , stringify ! ( CmdHeader ) ));
}
impl Clone for CFE_TIME_FakeToneCmd_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_ToneDataCmd_Payload_t {
    /**< \brief MET at time of tone */
    pub AtToneMET: CFE_TIME_SysTime_t,
    /**< \brief STCF at time of tone */
    pub AtToneSTCF: CFE_TIME_SysTime_t,
    /**< \brief Leap Seconds at time of tone */
    pub AtToneLeaps: int16,
    /**< \brief Clock state at time of tone */
    pub AtToneState: int16,
}
#[test]
fn bindgen_test_layout_CFE_TIME_ToneDataCmd_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_ToneDataCmd_Payload_t>() ,
               20usize , concat ! (
               "Size of: " , stringify ! ( CFE_TIME_ToneDataCmd_Payload_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_ToneDataCmd_Payload_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_ToneDataCmd_Payload_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ToneDataCmd_Payload_t ) ) .
                AtToneMET as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_ToneDataCmd_Payload_t ) , "::" , stringify ! (
                AtToneMET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ToneDataCmd_Payload_t ) ) .
                AtToneSTCF as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_ToneDataCmd_Payload_t ) , "::" , stringify ! (
                AtToneSTCF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ToneDataCmd_Payload_t ) ) .
                AtToneLeaps as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_ToneDataCmd_Payload_t ) , "::" , stringify ! (
                AtToneLeaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ToneDataCmd_Payload_t ) ) .
                AtToneState as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_ToneDataCmd_Payload_t ) , "::" , stringify ! (
                AtToneState ) ));
}
impl Clone for CFE_TIME_ToneDataCmd_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_ToneDataCmd_t {
    pub CmdHeader: [uint8; 8usize],
    pub Payload: CFE_TIME_ToneDataCmd_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TIME_ToneDataCmd_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_ToneDataCmd_t>() , 28usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TIME_ToneDataCmd_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_ToneDataCmd_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_ToneDataCmd_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ToneDataCmd_t ) ) . CmdHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_ToneDataCmd_t
                ) , "::" , stringify ! ( CmdHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_ToneDataCmd_t ) ) . Payload as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_ToneDataCmd_t
                ) , "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_TIME_ToneDataCmd_t {
    fn clone(&self) -> Self { *self }
}
/** 
**  \cfetimetlm Time Services Housekeeping Packet
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_HkPacket_Payload_t {
    /**< \cfetlmmnemonic \TIME_CMDPC
                                                 \brief Time Command Execution Counter */
    pub CmdCounter: uint8,
    /**< \cfetlmmnemonic \TIME_CMDEC
                                                 \brief Time Command Error Counter */
    pub ErrCounter: uint8,
    /**< \cfetlmmnemonic \TIME_STATEFLG
                                                 \brief State Flags */
    pub ClockStateFlags: uint16,
    /**< \cfetlmmnemonic \TIME_APISTATE
                                                 \brief API State */
    pub ClockStateAPI: int16,
    /**< \cfetlmmnemonic \TIME_LEAPSECS
                                                 \brief Current Leaps Seconds */
    pub LeapSeconds: int16,
    /**< \cfetlmmnemonic \TIME_METSECS
                                                 \brief Current MET (seconds) */
    pub SecondsMET: uint32,
    /**< \cfetlmmnemonic \TIME_METSUBSECS
                                                 \brief Current MET (sub-seconds) */
    pub SubsecsMET: uint32,
    /**< \cfetlmmnemonic \TIME_STCFSECS
                                                 \brief Current STCF (seconds) */
    pub SecondsSTCF: uint32,
    /**< \cfetlmmnemonic \TIME_STCFSUBSECS
                                                 \brief Current STCF (sub-seconds) */
    pub SubsecsSTCF: uint32,
    /**< \cfetlmmnemonic \TIME_1HZADJSECS
                                                 \brief Current 1 Hz SCTF adjustment (seconds) */
    pub Seconds1HzAdj: uint32,
    /**< \cfetlmmnemonic \TIME_1HZADJSSECS
                                                 \brief Current 1 Hz SCTF adjustment (sub-seconds) */
    pub Subsecs1HzAdj: uint32,
}
#[test]
fn bindgen_test_layout_CFE_TIME_HkPacket_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_HkPacket_Payload_t>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( CFE_TIME_HkPacket_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_HkPacket_Payload_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_HkPacket_Payload_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_Payload_t ) ) .
                CmdCounter as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_HkPacket_Payload_t ) , "::" , stringify ! (
                CmdCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_Payload_t ) ) .
                ErrCounter as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_HkPacket_Payload_t ) , "::" , stringify ! (
                ErrCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_Payload_t ) ) .
                ClockStateFlags as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_HkPacket_Payload_t ) , "::" , stringify ! (
                ClockStateFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_Payload_t ) ) .
                ClockStateAPI as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_HkPacket_Payload_t ) , "::" , stringify ! (
                ClockStateAPI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_Payload_t ) ) .
                LeapSeconds as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_HkPacket_Payload_t ) , "::" , stringify ! (
                LeapSeconds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_Payload_t ) ) .
                SecondsMET as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_HkPacket_Payload_t ) , "::" , stringify ! (
                SecondsMET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_Payload_t ) ) .
                SubsecsMET as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_HkPacket_Payload_t ) , "::" , stringify ! (
                SubsecsMET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_Payload_t ) ) .
                SecondsSTCF as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_HkPacket_Payload_t ) , "::" , stringify ! (
                SecondsSTCF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_Payload_t ) ) .
                SubsecsSTCF as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_HkPacket_Payload_t ) , "::" , stringify ! (
                SubsecsSTCF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_Payload_t ) ) .
                Seconds1HzAdj as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_HkPacket_Payload_t ) , "::" , stringify ! (
                Seconds1HzAdj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_Payload_t ) ) .
                Subsecs1HzAdj as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_HkPacket_Payload_t ) , "::" , stringify ! (
                Subsecs1HzAdj ) ));
}
impl Clone for CFE_TIME_HkPacket_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_HkPacket_t {
    pub TlmHeader: [uint8; 12usize],
    pub Payload: CFE_TIME_HkPacket_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TIME_HkPacket_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_HkPacket_t>() , 44usize , concat
               ! ( "Size of: " , stringify ! ( CFE_TIME_HkPacket_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_HkPacket_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_HkPacket_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_t ) ) . TlmHeader as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_HkPacket_t ) ,
                "::" , stringify ! ( TlmHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_HkPacket_t ) ) . Payload as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_HkPacket_t ) ,
                "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_TIME_HkPacket_t {
    fn clone(&self) -> Self { *self }
}
/** 
**  \cfetimetlm Time Services Diagnostics Packet
**/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_DiagPacket_Payload_t {
    /**< \cfetlmmnemonic \TIME_TMETS
	                                             \brief MET at time of tone */
    pub AtToneMET: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_STCFS
	                                             \brief STCF at time of tone */
    pub AtToneSTCF: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_LATENTS
	                                             \brief Adjustment for slow tone detection */
    pub AtToneDelay: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_TVALIDS
	                                             \brief Local clock latched at time of tone */
    pub AtToneLatch: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_LEAPS
	                                             \brief Leap Seconds at time of tone */
    pub AtToneLeaps: int16,
    /**< \cfetlmmnemonic \TIME_APISTATE
	                                             \brief Clock state as per API */
    pub ClockStateAPI: int16,
    /**< \cfetlmmnemonic \TIME_ELAPSEDS
	                                             \brief Time elapsed since the tone */
    pub TimeSinceTone: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_LOCALS
	                                             \brief Local clock latched just "now" */
    pub CurrentLatch: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_METS
	                                             \brief MET at this instant */
    pub CurrentMET: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_TAIS
	                                             \brief TAI at this instant */
    pub CurrentTAI: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_UTCS
	                                             \brief UTC at this instant */
    pub CurrentUTC: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_VALID
	                                             \brief Time has been "set" */
    pub ClockSetState: int16,
    /**< \cfetlmmnemonic \TIME_FLYWHEEL
	                                             \brief Current fly-wheel state */
    pub ClockFlyState: int16,
    /**< \cfetlmmnemonic \TIME_SOURCE
	                                             \brief Internal vs external, etc. */
    pub ClockSource: int16,
    /**< \cfetlmmnemonic \TIME_SIGNAL
	                                             \brief Primary vs redundant, etc. */
    pub ClockSignal: int16,
    /**< \cfetlmmnemonic \TIME_SRVFLY
	                                             \brief Used by clients only */
    pub ServerFlyState: int16,
    /**< \cfetlmmnemonic \TIME_CMD2FLY
	                                             \brief Commanded into fly-wheel */
    pub Forced2Fly: int16,
    /**< \cfetlmmnemonic \TIME_STATEFLAGS
	                                             \brief Clock State Flags */
    pub ClockStateFlags: uint16,
    /**< \cfetlmmnemonic \TIME_ADJUSTDIR
	                                               \brief One time STCF adjustment direction (Add = 1,  Sub = 2) */
    pub OneTimeDirection: int16,
    /**< \cfetlmmnemonic \TIME_1HZADJDIR
	                                               \brief 1Hz STCF adjustment direction */
    pub OneHzDirection: int16,
    /**< \cfetlmmnemonic \TIME_LATENTDIR
	                                               \brief Client latency adjustment direction */
    pub DelayDirection: int16,
    /**< \cfetlmmnemonic \TIME_ADJUSTS
	                                               \brief Previous one-time STCF adjustment */
    pub OneTimeAdjust: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_1HZADJS
	                                               \brief Current 1Hz STCF adjustment */
    pub OneHzAdjust: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_TTS
	                                               \brief  Local Clock latched at most recent tone signal */
    pub ToneSignalLatch: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_TDS
	                                               \brief  Local Clock latched at arrival of tone data */
    pub ToneDataLatch: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_VERIFYCNT
	                                               \brief  Tone signal / data verification count */
    pub ToneMatchCount: uint32,
    /**< \cfetlmmnemonic \TIME_VERIFYER
	                                               \brief  Tone signal / data verification error count */
    pub ToneMatchErrors: uint32,
    /**< \cfetlmmnemonic \TIME_TSDETCNT
	                                               \brief  Tone signal detected SB message count */
    pub ToneSignalCount: uint32,
    /**< \cfetlmmnemonic \TIME_TATTCNT
	                                               \brief  Time at the tone data SB message count */
    pub ToneDataCount: uint32,
    /**< \cfetlmmnemonic \TIME_TSISRCNT
	                                               \brief  Tone signal ISR execution count */
    pub ToneIntCount: uint32,
    /**< \cfetlmmnemonic \TIME_TSISRERR
	                                               \brief  Tone signal ISR error count */
    pub ToneIntErrors: uint32,
    /**< \cfetlmmnemonic \TIME_TSTASKCNT
	                                               \brief  Tone task execution count */
    pub ToneTaskCount: uint32,
    /**< \cfetlmmnemonic \TIME_VERSIONCNT
	                                               \brief  Count of mods to time at tone reference data (version) */
    pub VersionCount: uint32,
    /**< \cfetlmmnemonic \TIME_1HZISRCNT
	                                               \brief  Local 1Hz ISR execution count */
    pub LocalIntCount: uint32,
    /**< \cfetlmmnemonic \TIME_1HZTASKCNT
	                                               \brief  Local 1Hz task execution count */
    pub LocalTaskCount: uint32,
    /**< \cfetlmmnemonic \TIME_LOGICALMET
	                                               \brief  Software MET */
    pub VirtualMET: uint32,
    /**< \cfetlmmnemonic \TIME_MINWINDOW
	                                               \brief Min tone signal / data pkt arrival window (Sub-seconds) */
    pub MinElapsed: uint32,
    /**< \cfetlmmnemonic \TIME_MAXWINDOW
	                                               \brief Max tone signal / data pkt arrival window (Sub-seconds) */
    pub MaxElapsed: uint32,
    /**< \cfetlmmnemonic \TIME_WRAPS
	                                               \brief Max local clock value before rollover */
    pub MaxLocalClock: CFE_TIME_SysTime_t,
    /**< \cfetlmmnemonic \TIME_MAXSS
	                                               \brief Max between tone signal interrupts */
    pub ToneOverLimit: uint32,
    /**< \cfetlmmnemonic \TIME_MINSS
	                                               \brief Min between tone signal interrupts */
    pub ToneUnderLimit: uint32,
    /**< \cfetlmmnemonic \TIME_ATASTSTAT
	                                               \brief Data Store status (preserved across processor reset) */
    pub DataStoreStatus: uint32,
}
#[test]
fn bindgen_test_layout_CFE_TIME_DiagPacket_Payload_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_DiagPacket_Payload_t>() ,
               200usize , concat ! (
               "Size of: " , stringify ! ( CFE_TIME_DiagPacket_Payload_t ) ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_DiagPacket_Payload_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_DiagPacket_Payload_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                AtToneMET as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                AtToneMET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                AtToneSTCF as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                AtToneSTCF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                AtToneDelay as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                AtToneDelay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                AtToneLatch as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                AtToneLatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                AtToneLeaps as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                AtToneLeaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ClockStateAPI as * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ClockStateAPI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                TimeSinceTone as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                TimeSinceTone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                CurrentLatch as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                CurrentLatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                CurrentMET as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                CurrentMET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                CurrentTAI as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                CurrentTAI ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                CurrentUTC as * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                CurrentUTC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ClockSetState as * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ClockSetState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ClockFlyState as * const _ as usize } , 78usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ClockFlyState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ClockSource as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ClockSource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ClockSignal as * const _ as usize } , 82usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ClockSignal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ServerFlyState as * const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ServerFlyState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                Forced2Fly as * const _ as usize } , 86usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                Forced2Fly ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ClockStateFlags as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ClockStateFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                OneTimeDirection as * const _ as usize } , 90usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                OneTimeDirection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                OneHzDirection as * const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                OneHzDirection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                DelayDirection as * const _ as usize } , 94usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                DelayDirection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                OneTimeAdjust as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                OneTimeAdjust ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                OneHzAdjust as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                OneHzAdjust ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ToneSignalLatch as * const _ as usize } , 112usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ToneSignalLatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ToneDataLatch as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ToneDataLatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ToneMatchCount as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ToneMatchCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ToneMatchErrors as * const _ as usize } , 132usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ToneMatchErrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ToneSignalCount as * const _ as usize } , 136usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ToneSignalCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ToneDataCount as * const _ as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ToneDataCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ToneIntCount as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ToneIntCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ToneIntErrors as * const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ToneIntErrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ToneTaskCount as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ToneTaskCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                VersionCount as * const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                VersionCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                LocalIntCount as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                LocalIntCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                LocalTaskCount as * const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                LocalTaskCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                VirtualMET as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                VirtualMET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                MinElapsed as * const _ as usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                MinElapsed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                MaxElapsed as * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                MaxElapsed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                MaxLocalClock as * const _ as usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                MaxLocalClock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ToneOverLimit as * const _ as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ToneOverLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                ToneUnderLimit as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                ToneUnderLimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_Payload_t ) ) .
                DataStoreStatus as * const _ as usize } , 196usize , concat !
                (
                "Alignment of field: " , stringify ! (
                CFE_TIME_DiagPacket_Payload_t ) , "::" , stringify ! (
                DataStoreStatus ) ));
}
impl Clone for CFE_TIME_DiagPacket_Payload_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CFE_TIME_DiagPacket_t {
    pub TlmHeader: [uint8; 12usize],
    pub Payload: CFE_TIME_DiagPacket_Payload_t,
}
#[test]
fn bindgen_test_layout_CFE_TIME_DiagPacket_t() {
    assert_eq!(::std::mem::size_of::<CFE_TIME_DiagPacket_t>() , 212usize ,
               concat ! ( "Size of: " , stringify ! ( CFE_TIME_DiagPacket_t )
               ));
    assert_eq! (::std::mem::align_of::<CFE_TIME_DiagPacket_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( CFE_TIME_DiagPacket_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_t ) ) . TlmHeader as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_DiagPacket_t )
                , "::" , stringify ! ( TlmHeader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CFE_TIME_DiagPacket_t ) ) . Payload as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CFE_TIME_DiagPacket_t )
                , "::" , stringify ! ( Payload ) ));
}
impl Clone for CFE_TIME_DiagPacket_t {
    fn clone(&self) -> Self { *self }
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(__name: *const ::std::os::raw::c_char,
                  __type: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(__fd: ::std::os::raw::c_int,
                     __file: *const ::std::os::raw::c_char,
                     __type: ::std::os::raw::c_int,
                     __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(__fd: ::std::os::raw::c_int, __offset: __off_t,
                 __whence: ::std::os::raw::c_int) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __nbytes: usize) -> isize;
}
extern "C" {
    pub fn write(__fd: ::std::os::raw::c_int,
                 __buf: *const ::std::os::raw::c_void, __n: usize) -> isize;
}
extern "C" {
    pub fn pread(__fd: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_void, __nbytes: usize,
                 __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pwrite(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: usize,
                  __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t)
     -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(__file: *const ::std::os::raw::c_char, __owner: __uid_t,
                 __group: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(__fd: ::std::os::raw::c_int, __owner: __uid_t,
                  __group: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(__file: *const ::std::os::raw::c_char, __owner: __uid_t,
                  __group: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(__fd: ::std::os::raw::c_int,
                    __file: *const ::std::os::raw::c_char, __owner: __uid_t,
                    __group: __gid_t, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__environ"]
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(__path: *const ::std::os::raw::c_char,
                  __argv: *const *const ::std::os::raw::c_char,
                  __envp: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(__fd: ::std::os::raw::c_int,
                   __argv: *const *const ::std::os::raw::c_char,
                   __envp: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(__path: *const ::std::os::raw::c_char,
                 __argv: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(__path: *const ::std::os::raw::c_char,
                  __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(__path: *const ::std::os::raw::c_char,
                 __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(__file: *const ::std::os::raw::c_char,
                  __argv: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(__file: *const ::std::os::raw::c_char,
                  __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int);
}
pub const _PC_LINK_MAX: _bindgen_ty_3 = _bindgen_ty_3::_PC_LINK_MAX;
pub const _PC_MAX_CANON: _bindgen_ty_3 = _bindgen_ty_3::_PC_MAX_CANON;
pub const _PC_MAX_INPUT: _bindgen_ty_3 = _bindgen_ty_3::_PC_MAX_INPUT;
pub const _PC_NAME_MAX: _bindgen_ty_3 = _bindgen_ty_3::_PC_NAME_MAX;
pub const _PC_PATH_MAX: _bindgen_ty_3 = _bindgen_ty_3::_PC_PATH_MAX;
pub const _PC_PIPE_BUF: _bindgen_ty_3 = _bindgen_ty_3::_PC_PIPE_BUF;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_3 =
    _bindgen_ty_3::_PC_CHOWN_RESTRICTED;
pub const _PC_NO_TRUNC: _bindgen_ty_3 = _bindgen_ty_3::_PC_NO_TRUNC;
pub const _PC_VDISABLE: _bindgen_ty_3 = _bindgen_ty_3::_PC_VDISABLE;
pub const _PC_SYNC_IO: _bindgen_ty_3 = _bindgen_ty_3::_PC_SYNC_IO;
pub const _PC_ASYNC_IO: _bindgen_ty_3 = _bindgen_ty_3::_PC_ASYNC_IO;
pub const _PC_PRIO_IO: _bindgen_ty_3 = _bindgen_ty_3::_PC_PRIO_IO;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_3 = _bindgen_ty_3::_PC_SOCK_MAXBUF;
pub const _PC_FILESIZEBITS: _bindgen_ty_3 = _bindgen_ty_3::_PC_FILESIZEBITS;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_3 =
    _bindgen_ty_3::_PC_REC_INCR_XFER_SIZE;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_3 =
    _bindgen_ty_3::_PC_REC_MAX_XFER_SIZE;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_3 =
    _bindgen_ty_3::_PC_REC_MIN_XFER_SIZE;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_3 =
    _bindgen_ty_3::_PC_REC_XFER_ALIGN;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_3 =
    _bindgen_ty_3::_PC_ALLOC_SIZE_MIN;
pub const _PC_SYMLINK_MAX: _bindgen_ty_3 = _bindgen_ty_3::_PC_SYMLINK_MAX;
pub const _PC_2_SYMLINKS: _bindgen_ty_3 = _bindgen_ty_3::_PC_2_SYMLINKS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20,
}
pub const _SC_ARG_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_ARG_MAX;
pub const _SC_CHILD_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_CHILD_MAX;
pub const _SC_CLK_TCK: _bindgen_ty_4 = _bindgen_ty_4::_SC_CLK_TCK;
pub const _SC_NGROUPS_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_NGROUPS_MAX;
pub const _SC_OPEN_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_OPEN_MAX;
pub const _SC_STREAM_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_STREAM_MAX;
pub const _SC_TZNAME_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_TZNAME_MAX;
pub const _SC_JOB_CONTROL: _bindgen_ty_4 = _bindgen_ty_4::_SC_JOB_CONTROL;
pub const _SC_SAVED_IDS: _bindgen_ty_4 = _bindgen_ty_4::_SC_SAVED_IDS;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_REALTIME_SIGNALS;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_PRIORITY_SCHEDULING;
pub const _SC_TIMERS: _bindgen_ty_4 = _bindgen_ty_4::_SC_TIMERS;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_ASYNCHRONOUS_IO;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_PRIORITIZED_IO;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_SYNCHRONIZED_IO;
pub const _SC_FSYNC: _bindgen_ty_4 = _bindgen_ty_4::_SC_FSYNC;
pub const _SC_MAPPED_FILES: _bindgen_ty_4 = _bindgen_ty_4::_SC_MAPPED_FILES;
pub const _SC_MEMLOCK: _bindgen_ty_4 = _bindgen_ty_4::_SC_MEMLOCK;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_4 = _bindgen_ty_4::_SC_MEMLOCK_RANGE;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_MEMORY_PROTECTION;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_MESSAGE_PASSING;
pub const _SC_SEMAPHORES: _bindgen_ty_4 = _bindgen_ty_4::_SC_SEMAPHORES;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_SHARED_MEMORY_OBJECTS;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_AIO_LISTIO_MAX;
pub const _SC_AIO_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_AIO_MAX;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_AIO_PRIO_DELTA_MAX;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_DELAYTIMER_MAX;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_MQ_OPEN_MAX;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_MQ_PRIO_MAX;
pub const _SC_VERSION: _bindgen_ty_4 = _bindgen_ty_4::_SC_VERSION;
pub const _SC_PAGESIZE: _bindgen_ty_4 = _bindgen_ty_4::_SC_PAGESIZE;
pub const _SC_RTSIG_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_RTSIG_MAX;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_SEM_NSEMS_MAX;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_SEM_VALUE_MAX;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_SIGQUEUE_MAX;
pub const _SC_TIMER_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_TIMER_MAX;
pub const _SC_BC_BASE_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_BC_BASE_MAX;
pub const _SC_BC_DIM_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_BC_DIM_MAX;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_BC_SCALE_MAX;
pub const _SC_BC_STRING_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_BC_STRING_MAX;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_COLL_WEIGHTS_MAX;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_EQUIV_CLASS_MAX;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_EXPR_NEST_MAX;
pub const _SC_LINE_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_LINE_MAX;
pub const _SC_RE_DUP_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_RE_DUP_MAX;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_CHARCLASS_NAME_MAX;
pub const _SC_2_VERSION: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_VERSION;
pub const _SC_2_C_BIND: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_C_BIND;
pub const _SC_2_C_DEV: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_C_DEV;
pub const _SC_2_FORT_DEV: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_FORT_DEV;
pub const _SC_2_FORT_RUN: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_FORT_RUN;
pub const _SC_2_SW_DEV: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_SW_DEV;
pub const _SC_2_LOCALEDEF: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_LOCALEDEF;
pub const _SC_PII: _bindgen_ty_4 = _bindgen_ty_4::_SC_PII;
pub const _SC_PII_XTI: _bindgen_ty_4 = _bindgen_ty_4::_SC_PII_XTI;
pub const _SC_PII_SOCKET: _bindgen_ty_4 = _bindgen_ty_4::_SC_PII_SOCKET;
pub const _SC_PII_INTERNET: _bindgen_ty_4 = _bindgen_ty_4::_SC_PII_INTERNET;
pub const _SC_PII_OSI: _bindgen_ty_4 = _bindgen_ty_4::_SC_PII_OSI;
pub const _SC_POLL: _bindgen_ty_4 = _bindgen_ty_4::_SC_POLL;
pub const _SC_SELECT: _bindgen_ty_4 = _bindgen_ty_4::_SC_SELECT;
pub const _SC_UIO_MAXIOV: _bindgen_ty_4 = _bindgen_ty_4::_SC_UIO_MAXIOV;
pub const _SC_IOV_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_UIO_MAXIOV;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_PII_INTERNET_STREAM;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_PII_INTERNET_DGRAM;
pub const _SC_PII_OSI_COTS: _bindgen_ty_4 = _bindgen_ty_4::_SC_PII_OSI_COTS;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_4 = _bindgen_ty_4::_SC_PII_OSI_CLTS;
pub const _SC_PII_OSI_M: _bindgen_ty_4 = _bindgen_ty_4::_SC_PII_OSI_M;
pub const _SC_T_IOV_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_T_IOV_MAX;
pub const _SC_THREADS: _bindgen_ty_4 = _bindgen_ty_4::_SC_THREADS;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_SAFE_FUNCTIONS;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_GETGR_R_SIZE_MAX;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_GETPW_R_SIZE_MAX;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LOGIN_NAME_MAX;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_TTY_NAME_MAX;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_DESTRUCTOR_ITERATIONS;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_KEYS_MAX;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_STACK_MIN;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_THREADS_MAX;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_ATTR_STACKADDR;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_ATTR_STACKSIZE;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_PRIORITY_SCHEDULING;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_PRIO_INHERIT;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_PRIO_PROTECT;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_PROCESS_SHARED;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_NPROCESSORS_CONF;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_NPROCESSORS_ONLN;
pub const _SC_PHYS_PAGES: _bindgen_ty_4 = _bindgen_ty_4::_SC_PHYS_PAGES;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_4 = _bindgen_ty_4::_SC_AVPHYS_PAGES;
pub const _SC_ATEXIT_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_ATEXIT_MAX;
pub const _SC_PASS_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_PASS_MAX;
pub const _SC_XOPEN_VERSION: _bindgen_ty_4 = _bindgen_ty_4::_SC_XOPEN_VERSION;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_XOPEN_XCU_VERSION;
pub const _SC_XOPEN_UNIX: _bindgen_ty_4 = _bindgen_ty_4::_SC_XOPEN_UNIX;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_4 = _bindgen_ty_4::_SC_XOPEN_CRYPT;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_XOPEN_ENH_I18N;
pub const _SC_XOPEN_SHM: _bindgen_ty_4 = _bindgen_ty_4::_SC_XOPEN_SHM;
pub const _SC_2_CHAR_TERM: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_CHAR_TERM;
pub const _SC_2_C_VERSION: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_C_VERSION;
pub const _SC_2_UPE: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_UPE;
pub const _SC_XOPEN_XPG2: _bindgen_ty_4 = _bindgen_ty_4::_SC_XOPEN_XPG2;
pub const _SC_XOPEN_XPG3: _bindgen_ty_4 = _bindgen_ty_4::_SC_XOPEN_XPG3;
pub const _SC_XOPEN_XPG4: _bindgen_ty_4 = _bindgen_ty_4::_SC_XOPEN_XPG4;
pub const _SC_CHAR_BIT: _bindgen_ty_4 = _bindgen_ty_4::_SC_CHAR_BIT;
pub const _SC_CHAR_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_CHAR_MAX;
pub const _SC_CHAR_MIN: _bindgen_ty_4 = _bindgen_ty_4::_SC_CHAR_MIN;
pub const _SC_INT_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_INT_MAX;
pub const _SC_INT_MIN: _bindgen_ty_4 = _bindgen_ty_4::_SC_INT_MIN;
pub const _SC_LONG_BIT: _bindgen_ty_4 = _bindgen_ty_4::_SC_LONG_BIT;
pub const _SC_WORD_BIT: _bindgen_ty_4 = _bindgen_ty_4::_SC_WORD_BIT;
pub const _SC_MB_LEN_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_MB_LEN_MAX;
pub const _SC_NZERO: _bindgen_ty_4 = _bindgen_ty_4::_SC_NZERO;
pub const _SC_SSIZE_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_SSIZE_MAX;
pub const _SC_SCHAR_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_SCHAR_MAX;
pub const _SC_SCHAR_MIN: _bindgen_ty_4 = _bindgen_ty_4::_SC_SCHAR_MIN;
pub const _SC_SHRT_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_SHRT_MAX;
pub const _SC_SHRT_MIN: _bindgen_ty_4 = _bindgen_ty_4::_SC_SHRT_MIN;
pub const _SC_UCHAR_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_UCHAR_MAX;
pub const _SC_UINT_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_UINT_MAX;
pub const _SC_ULONG_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_ULONG_MAX;
pub const _SC_USHRT_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_USHRT_MAX;
pub const _SC_NL_ARGMAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_NL_ARGMAX;
pub const _SC_NL_LANGMAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_NL_LANGMAX;
pub const _SC_NL_MSGMAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_NL_MSGMAX;
pub const _SC_NL_NMAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_NL_NMAX;
pub const _SC_NL_SETMAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_NL_SETMAX;
pub const _SC_NL_TEXTMAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_NL_TEXTMAX;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_XBS5_ILP32_OFF32;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_XBS5_ILP32_OFFBIG;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_XBS5_LP64_OFF64;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_XBS5_LPBIG_OFFBIG;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_4 = _bindgen_ty_4::_SC_XOPEN_LEGACY;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_XOPEN_REALTIME;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_XOPEN_REALTIME_THREADS;
pub const _SC_ADVISORY_INFO: _bindgen_ty_4 = _bindgen_ty_4::_SC_ADVISORY_INFO;
pub const _SC_BARRIERS: _bindgen_ty_4 = _bindgen_ty_4::_SC_BARRIERS;
pub const _SC_BASE: _bindgen_ty_4 = _bindgen_ty_4::_SC_BASE;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_C_LANG_SUPPORT;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_C_LANG_SUPPORT_R;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_CLOCK_SELECTION;
pub const _SC_CPUTIME: _bindgen_ty_4 = _bindgen_ty_4::_SC_CPUTIME;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_CPUTIME;
pub const _SC_DEVICE_IO: _bindgen_ty_4 = _bindgen_ty_4::_SC_DEVICE_IO;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_DEVICE_SPECIFIC;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_DEVICE_SPECIFIC_R;
pub const _SC_FD_MGMT: _bindgen_ty_4 = _bindgen_ty_4::_SC_FD_MGMT;
pub const _SC_FIFO: _bindgen_ty_4 = _bindgen_ty_4::_SC_FIFO;
pub const _SC_PIPE: _bindgen_ty_4 = _bindgen_ty_4::_SC_PIPE;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_FILE_ATTRIBUTES;
pub const _SC_FILE_LOCKING: _bindgen_ty_4 = _bindgen_ty_4::_SC_FILE_LOCKING;
pub const _SC_FILE_SYSTEM: _bindgen_ty_4 = _bindgen_ty_4::_SC_FILE_SYSTEM;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_MONOTONIC_CLOCK;
pub const _SC_MULTI_PROCESS: _bindgen_ty_4 = _bindgen_ty_4::_SC_MULTI_PROCESS;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_SINGLE_PROCESS;
pub const _SC_NETWORKING: _bindgen_ty_4 = _bindgen_ty_4::_SC_NETWORKING;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_READER_WRITER_LOCKS;
pub const _SC_SPIN_LOCKS: _bindgen_ty_4 = _bindgen_ty_4::_SC_SPIN_LOCKS;
pub const _SC_REGEXP: _bindgen_ty_4 = _bindgen_ty_4::_SC_REGEXP;
pub const _SC_REGEX_VERSION: _bindgen_ty_4 = _bindgen_ty_4::_SC_REGEX_VERSION;
pub const _SC_SHELL: _bindgen_ty_4 = _bindgen_ty_4::_SC_SHELL;
pub const _SC_SIGNALS: _bindgen_ty_4 = _bindgen_ty_4::_SC_SIGNALS;
pub const _SC_SPAWN: _bindgen_ty_4 = _bindgen_ty_4::_SC_SPAWN;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_SPORADIC_SERVER;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_SPORADIC_SERVER;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_SYSTEM_DATABASE;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_SYSTEM_DATABASE_R;
pub const _SC_TIMEOUTS: _bindgen_ty_4 = _bindgen_ty_4::_SC_TIMEOUTS;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_TYPED_MEMORY_OBJECTS;
pub const _SC_USER_GROUPS: _bindgen_ty_4 = _bindgen_ty_4::_SC_USER_GROUPS;
pub const _SC_USER_GROUPS_R: _bindgen_ty_4 = _bindgen_ty_4::_SC_USER_GROUPS_R;
pub const _SC_2_PBS: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_PBS;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_2_PBS_ACCOUNTING;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_PBS_LOCATE;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_PBS_MESSAGE;
pub const _SC_2_PBS_TRACK: _bindgen_ty_4 = _bindgen_ty_4::_SC_2_PBS_TRACK;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_SYMLOOP_MAX;
pub const _SC_STREAMS: _bindgen_ty_4 = _bindgen_ty_4::_SC_STREAMS;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_2_PBS_CHECKPOINT;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_V6_ILP32_OFF32;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_V6_ILP32_OFFBIG;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_4 = _bindgen_ty_4::_SC_V6_LP64_OFF64;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_V6_LPBIG_OFFBIG;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_HOST_NAME_MAX;
pub const _SC_TRACE: _bindgen_ty_4 = _bindgen_ty_4::_SC_TRACE;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_TRACE_EVENT_FILTER;
pub const _SC_TRACE_INHERIT: _bindgen_ty_4 = _bindgen_ty_4::_SC_TRACE_INHERIT;
pub const _SC_TRACE_LOG: _bindgen_ty_4 = _bindgen_ty_4::_SC_TRACE_LOG;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL1_ICACHE_SIZE;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL1_ICACHE_ASSOC;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL1_ICACHE_LINESIZE;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL1_DCACHE_SIZE;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL1_DCACHE_ASSOC;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL1_DCACHE_LINESIZE;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL2_CACHE_SIZE;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL2_CACHE_ASSOC;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL2_CACHE_LINESIZE;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL3_CACHE_SIZE;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL3_CACHE_ASSOC;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL3_CACHE_LINESIZE;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL4_CACHE_SIZE;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL4_CACHE_ASSOC;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_LEVEL4_CACHE_LINESIZE;
pub const _SC_IPV6: _bindgen_ty_4 = _bindgen_ty_4::_SC_IPV6;
pub const _SC_RAW_SOCKETS: _bindgen_ty_4 = _bindgen_ty_4::_SC_RAW_SOCKETS;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_V7_ILP32_OFF32;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_V7_ILP32_OFFBIG;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_4 = _bindgen_ty_4::_SC_V7_LP64_OFF64;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_V7_LPBIG_OFFBIG;
pub const _SC_SS_REPL_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_SS_REPL_MAX;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_TRACE_EVENT_NAME_MAX;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_TRACE_NAME_MAX;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_4 = _bindgen_ty_4::_SC_TRACE_SYS_MAX;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_TRACE_USER_EVENT_MAX;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_4 = _bindgen_ty_4::_SC_XOPEN_STREAMS;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_ROBUST_PRIO_INHERIT;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_4 =
    _bindgen_ty_4::_SC_THREAD_ROBUST_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
}
pub const _CS_PATH: _bindgen_ty_5 = _bindgen_ty_5::_CS_PATH;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_V6_WIDTH_RESTRICTED_ENVS;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_GNU_LIBC_VERSION;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_GNU_LIBPTHREAD_VERSION;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_V5_WIDTH_RESTRICTED_ENVS;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_V7_WIDTH_RESTRICTED_ENVS;
pub const _CS_LFS_CFLAGS: _bindgen_ty_5 = _bindgen_ty_5::_CS_LFS_CFLAGS;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_5 = _bindgen_ty_5::_CS_LFS_LDFLAGS;
pub const _CS_LFS_LIBS: _bindgen_ty_5 = _bindgen_ty_5::_CS_LFS_LIBS;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_5 = _bindgen_ty_5::_CS_LFS_LINTFLAGS;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_5 = _bindgen_ty_5::_CS_LFS64_CFLAGS;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_5 = _bindgen_ty_5::_CS_LFS64_LDFLAGS;
pub const _CS_LFS64_LIBS: _bindgen_ty_5 = _bindgen_ty_5::_CS_LFS64_LIBS;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_LFS64_LINTFLAGS;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_ILP32_OFF32_CFLAGS;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_ILP32_OFF32_LDFLAGS;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_ILP32_OFF32_LIBS;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_ILP32_OFF32_LINTFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_ILP32_OFFBIG_CFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_ILP32_OFFBIG_LDFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_ILP32_OFFBIG_LIBS;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_LP64_OFF64_CFLAGS;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_LP64_OFF64_LDFLAGS;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_LP64_OFF64_LIBS;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_LP64_OFF64_LINTFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_LPBIG_OFFBIG_CFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_LPBIG_OFFBIG_LIBS;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_ILP32_OFF32_CFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_ILP32_OFF32_LIBS;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_ILP32_OFFBIG_LIBS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_LP64_OFF64_CFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_LP64_OFF64_LDFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_LP64_OFF64_LIBS;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_LP64_OFF64_LINTFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_ILP32_OFF32_CFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_ILP32_OFF32_LDFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_ILP32_OFF32_LIBS;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_ILP32_OFFBIG_LIBS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_LP64_OFF64_CFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_LP64_OFF64_LDFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_LP64_OFF64_LIBS;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_LP64_OFF64_LINTFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_LPBIG_OFFBIG_LIBS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_5 =
    _bindgen_ty_5::_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_V6_ENV: _bindgen_ty_5 = _bindgen_ty_5::_CS_V6_ENV;
pub const _CS_V7_ENV: _bindgen_ty_5 = _bindgen_ty_5::_CS_V7_ENV;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149,
}
extern "C" {
    pub fn pathconf(__path: *const ::std::os::raw::c_char,
                    __name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(__fd: ::std::os::raw::c_int,
                     __name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(__name: ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(__fd: ::std::os::raw::c_int,
                     __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(__from: *const ::std::os::raw::c_char,
                __to: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(__fromfd: ::std::os::raw::c_int,
                  __from: *const ::std::os::raw::c_char,
                  __tofd: ::std::os::raw::c_int,
                  __to: *const ::std::os::raw::c_char,
                  __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(__from: *const ::std::os::raw::c_char,
                   __to: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(__path: *const ::std::os::raw::c_char,
                    __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> isize;
}
extern "C" {
    pub fn symlinkat(__from: *const ::std::os::raw::c_char,
                     __tofd: ::std::os::raw::c_int,
                     __to: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(__fd: ::std::os::raw::c_int,
                      __path: *const ::std::os::raw::c_char,
                      __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(__fd: ::std::os::raw::c_int,
                    __name: *const ::std::os::raw::c_char,
                    __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(__name: *mut ::std::os::raw::c_char, __name_len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "optarg"]
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "optind"]
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "opterr"]
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "optopt"]
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(___argc: ::std::os::raw::c_int,
                  ___argv: *const *const ::std::os::raw::c_char,
                  __shortopts: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(__name: *const ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(__name: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(__name: *const ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(__sample_buffer: *mut ::std::os::raw::c_ushort,
                  __size: usize, __offset: usize,
                  __scale: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(__nochdir: ::std::os::raw::c_int,
                  __noclose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(__file: *const ::std::os::raw::c_char, __length: __off_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(__fd: ::std::os::raw::c_int, __cmd: ::std::os::raw::c_int,
                 __len: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::std::mem::size_of::<iovec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( iovec ) ));
    assert_eq! (::std::mem::align_of::<iovec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( iovec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_len as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_len ) ));
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn readv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                 __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn writev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn preadv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int, __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pwritev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                   __count: ::std::os::raw::c_int, __offset: __off_t)
     -> isize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048,
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(::std::mem::size_of::<sockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr ) ));
    assert_eq! (::std::mem::align_of::<sockaddr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for sockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(::std::mem::size_of::<sockaddr_storage>() , 128usize , concat !
               ( "Size of: " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_storage>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . ss_family as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( ss_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_padding as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_align as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_align ) ));
}
pub const MSG_OOB: _bindgen_ty_6 = _bindgen_ty_6::MSG_OOB;
pub const MSG_PEEK: _bindgen_ty_6 = _bindgen_ty_6::MSG_PEEK;
pub const MSG_DONTROUTE: _bindgen_ty_6 = _bindgen_ty_6::MSG_DONTROUTE;
pub const MSG_CTRUNC: _bindgen_ty_6 = _bindgen_ty_6::MSG_CTRUNC;
pub const MSG_PROXY: _bindgen_ty_6 = _bindgen_ty_6::MSG_PROXY;
pub const MSG_TRUNC: _bindgen_ty_6 = _bindgen_ty_6::MSG_TRUNC;
pub const MSG_DONTWAIT: _bindgen_ty_6 = _bindgen_ty_6::MSG_DONTWAIT;
pub const MSG_EOR: _bindgen_ty_6 = _bindgen_ty_6::MSG_EOR;
pub const MSG_WAITALL: _bindgen_ty_6 = _bindgen_ty_6::MSG_WAITALL;
pub const MSG_FIN: _bindgen_ty_6 = _bindgen_ty_6::MSG_FIN;
pub const MSG_SYN: _bindgen_ty_6 = _bindgen_ty_6::MSG_SYN;
pub const MSG_CONFIRM: _bindgen_ty_6 = _bindgen_ty_6::MSG_CONFIRM;
pub const MSG_RST: _bindgen_ty_6 = _bindgen_ty_6::MSG_RST;
pub const MSG_ERRQUEUE: _bindgen_ty_6 = _bindgen_ty_6::MSG_ERRQUEUE;
pub const MSG_NOSIGNAL: _bindgen_ty_6 = _bindgen_ty_6::MSG_NOSIGNAL;
pub const MSG_MORE: _bindgen_ty_6 = _bindgen_ty_6::MSG_MORE;
pub const MSG_WAITFORONE: _bindgen_ty_6 = _bindgen_ty_6::MSG_WAITFORONE;
pub const MSG_FASTOPEN: _bindgen_ty_6 = _bindgen_ty_6::MSG_FASTOPEN;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_6 = _bindgen_ty_6::MSG_CMSG_CLOEXEC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(::std::mem::size_of::<msghdr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( msghdr ) ));
    assert_eq! (::std::mem::align_of::<msghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_namelen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iov as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iovlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iovlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_control as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_controllen as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_controllen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_flags as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_flags ) ));
}
impl Clone for msghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(::std::mem::size_of::<cmsghdr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cmsghdr ) ));
    assert_eq! (::std::mem::align_of::<cmsghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cmsghdr ) ));
}
impl Clone for cmsghdr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr)
     -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_7 = _bindgen_ty_7::SCM_RIGHTS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 { SCM_RIGHTS = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(::std::mem::size_of::<linger>() , 8usize , concat ! (
               "Size of: " , stringify ! ( linger ) ));
    assert_eq! (::std::mem::align_of::<linger>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( linger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_onoff as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_onoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_linger as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_linger ) ));
}
impl Clone for linger {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(::std::mem::size_of::<osockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( osockaddr ) ));
    assert_eq! (::std::mem::align_of::<osockaddr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( osockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for osockaddr {
    fn clone(&self) -> Self { *self }
}
pub const SHUT_RD: _bindgen_ty_8 = _bindgen_ty_8::SHUT_RD;
pub const SHUT_WR: _bindgen_ty_8 = _bindgen_ty_8::SHUT_WR;
pub const SHUT_RDWR: _bindgen_ty_8 = _bindgen_ty_8::SHUT_RDWR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 { SHUT_RD = 0, SHUT_WR = 1, SHUT_RDWR = 2, }
extern "C" {
    pub fn socket(__domain: ::std::os::raw::c_int,
                  __type: ::std::os::raw::c_int,
                  __protocol: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(__domain: ::std::os::raw::c_int,
                      __type: ::std::os::raw::c_int,
                      __protocol: ::std::os::raw::c_int,
                      __fds: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                __len: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                   __len: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(__fd: ::std::os::raw::c_int,
                __buf: *const ::std::os::raw::c_void, __n: usize,
                __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn recv(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __n: usize,
                __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn sendto(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: usize,
                  __flags: ::std::os::raw::c_int, __addr: *const sockaddr,
                  __addr_len: socklen_t) -> isize;
}
extern "C" {
    pub fn recvfrom(__fd: ::std::os::raw::c_int,
                    __buf: *mut ::std::os::raw::c_void, __n: usize,
                    __flags: ::std::os::raw::c_int, __addr: *mut sockaddr,
                    __addr_len: *mut socklen_t) -> isize;
}
extern "C" {
    pub fn sendmsg(__fd: ::std::os::raw::c_int, __message: *const msghdr,
                   __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn recvmsg(__fd: ::std::os::raw::c_int, __message: *mut msghdr,
                   __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn getsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *mut ::std::os::raw::c_void,
                      __optlen: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *const ::std::os::raw::c_void,
                      __optlen: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                  __addr_len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(__fd: ::std::os::raw::c_int, __how: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(__fd: ::std::os::raw::c_int,
                    __fdtype: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(::std::mem::size_of::<in_addr>() , 4usize , concat ! (
               "Size of: " , stringify ! ( in_addr ) ));
    assert_eq! (::std::mem::align_of::<in_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_addr ) ) . s_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in_addr ) , "::" ,
                stringify ! ( s_addr ) ));
}
impl Clone for in_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(::std::mem::size_of::<ip_opts>() , 44usize , concat ! (
               "Size of: " , stringify ! ( ip_opts ) ));
    assert_eq! (::std::mem::align_of::<ip_opts>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_opts ) ) . ip_dst as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_opts ) , "::" ,
                stringify ! ( ip_dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_opts ) ) . ip_opts as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_opts ) , "::" ,
                stringify ! ( ip_opts ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(::std::mem::size_of::<ip_mreqn>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ip_mreqn ) ));
    assert_eq! (::std::mem::align_of::<ip_mreqn>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreqn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_multiaddr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_address as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_ifindex as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_ifindex ) ));
}
impl Clone for ip_mreqn {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(::std::mem::size_of::<in_pktinfo>() , 12usize , concat ! (
               "Size of: " , stringify ! ( in_pktinfo ) ));
    assert_eq! (::std::mem::align_of::<in_pktinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in_pktinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_ifindex as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_ifindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_spec_dst as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_spec_dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_addr ) ));
}
impl Clone for in_pktinfo {
    fn clone(&self) -> Self { *self }
}
pub const IPPROTO_IP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_IP;
pub const IPPROTO_ICMP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_ICMP;
pub const IPPROTO_IGMP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_IGMP;
pub const IPPROTO_IPIP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_IPIP;
pub const IPPROTO_TCP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_TCP;
pub const IPPROTO_EGP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_EGP;
pub const IPPROTO_PUP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_PUP;
pub const IPPROTO_UDP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_UDP;
pub const IPPROTO_IDP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_IDP;
pub const IPPROTO_TP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_TP;
pub const IPPROTO_DCCP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_DCCP;
pub const IPPROTO_IPV6: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_IPV6;
pub const IPPROTO_RSVP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_RSVP;
pub const IPPROTO_GRE: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_GRE;
pub const IPPROTO_ESP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_ESP;
pub const IPPROTO_AH: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_AH;
pub const IPPROTO_MTP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_MTP;
pub const IPPROTO_BEETPH: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_BEETPH;
pub const IPPROTO_ENCAP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_ENCAP;
pub const IPPROTO_PIM: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_PIM;
pub const IPPROTO_COMP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_COMP;
pub const IPPROTO_SCTP: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_SCTP;
pub const IPPROTO_UDPLITE: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_UDPLITE;
pub const IPPROTO_MPLS: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_MPLS;
pub const IPPROTO_RAW: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_RAW;
pub const IPPROTO_MAX: _bindgen_ty_9 = _bindgen_ty_9::IPPROTO_MAX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256,
}
pub const IPPROTO_HOPOPTS: _bindgen_ty_10 = _bindgen_ty_10::IPPROTO_HOPOPTS;
pub const IPPROTO_ROUTING: _bindgen_ty_10 = _bindgen_ty_10::IPPROTO_ROUTING;
pub const IPPROTO_FRAGMENT: _bindgen_ty_10 = _bindgen_ty_10::IPPROTO_FRAGMENT;
pub const IPPROTO_ICMPV6: _bindgen_ty_10 = _bindgen_ty_10::IPPROTO_ICMPV6;
pub const IPPROTO_NONE: _bindgen_ty_10 = _bindgen_ty_10::IPPROTO_NONE;
pub const IPPROTO_DSTOPTS: _bindgen_ty_10 = _bindgen_ty_10::IPPROTO_DSTOPTS;
pub const IPPROTO_MH: _bindgen_ty_10 = _bindgen_ty_10::IPPROTO_MH;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135,
}
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_ECHO;
pub const IPPORT_DISCARD: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_DISCARD;
pub const IPPORT_SYSTAT: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_SYSTAT;
pub const IPPORT_DAYTIME: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_DAYTIME;
pub const IPPORT_NETSTAT: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_NETSTAT;
pub const IPPORT_FTP: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_FTP;
pub const IPPORT_TELNET: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_TELNET;
pub const IPPORT_SMTP: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_SMTP;
pub const IPPORT_TIMESERVER: _bindgen_ty_11 =
    _bindgen_ty_11::IPPORT_TIMESERVER;
pub const IPPORT_NAMESERVER: _bindgen_ty_11 =
    _bindgen_ty_11::IPPORT_NAMESERVER;
pub const IPPORT_WHOIS: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_WHOIS;
pub const IPPORT_MTP: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_MTP;
pub const IPPORT_TFTP: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_TFTP;
pub const IPPORT_RJE: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_RJE;
pub const IPPORT_FINGER: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_FINGER;
pub const IPPORT_TTYLINK: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_TTYLINK;
pub const IPPORT_SUPDUP: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_SUPDUP;
pub const IPPORT_EXECSERVER: _bindgen_ty_11 =
    _bindgen_ty_11::IPPORT_EXECSERVER;
pub const IPPORT_LOGINSERVER: _bindgen_ty_11 =
    _bindgen_ty_11::IPPORT_LOGINSERVER;
pub const IPPORT_CMDSERVER: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_CMDSERVER;
pub const IPPORT_EFSSERVER: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_EFSSERVER;
pub const IPPORT_BIFFUDP: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_EXECSERVER;
pub const IPPORT_WHOSERVER: _bindgen_ty_11 =
    _bindgen_ty_11::IPPORT_LOGINSERVER;
pub const IPPORT_ROUTESERVER: _bindgen_ty_11 =
    _bindgen_ty_11::IPPORT_EFSSERVER;
pub const IPPORT_RESERVED: _bindgen_ty_11 = _bindgen_ty_11::IPPORT_RESERVED;
pub const IPPORT_USERRESERVED: _bindgen_ty_11 =
    _bindgen_ty_11::IPPORT_USERRESERVED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in6_addr__bindgen_ty_1 {
    pub __u6_addr8: __BindgenUnionField<[u8; 16usize]>,
    pub __u6_addr16: __BindgenUnionField<[u16; 8usize]>,
    pub __u6_addr32: __BindgenUnionField<[u32; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<in6_addr__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( in6_addr__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<in6_addr__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( in6_addr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr8
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr16
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr32
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr32 ) ));
}
impl Clone for in6_addr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(::std::mem::size_of::<in6_addr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( in6_addr ) ));
    assert_eq! (::std::mem::align_of::<in6_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in6_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr ) ) . __in6_u as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr ) , "::" ,
                stringify ! ( __in6_u ) ));
}
impl Clone for in6_addr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "in6addr_any"]
    pub static in6addr_any: in6_addr;
}
extern "C" {
    #[link_name = "in6addr_loopback"]
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(::std::mem::size_of::<sockaddr_in>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_in ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_in>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_family as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_port as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_addr as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_zero as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_zero ) ));
}
impl Clone for sockaddr_in {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(::std::mem::size_of::<sockaddr_in6>() , 28usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_in6 ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_in6>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr_in6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_family as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_port as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_flowinfo as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_flowinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_addr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_scope_id as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_scope_id ) ));
}
impl Clone for sockaddr_in6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(::std::mem::size_of::<ip_mreq>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ip_mreq ) ));
    assert_eq! (::std::mem::align_of::<ip_mreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq ) ) . imr_multiaddr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq ) , "::" ,
                stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq ) ) . imr_interface as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq ) , "::" ,
                stringify ! ( imr_interface ) ));
}
impl Clone for ip_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(::std::mem::size_of::<ip_mreq_source>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ip_mreq_source ) ));
    assert_eq! (::std::mem::align_of::<ip_mreq_source>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreq_source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_interface as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_sourceaddr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_sourceaddr ) ));
}
impl Clone for ip_mreq_source {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(::std::mem::size_of::<ipv6_mreq>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ipv6_mreq ) ));
    assert_eq! (::std::mem::align_of::<ipv6_mreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ipv6_mreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_mreq ) ) . ipv6mr_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_mreq ) , "::" ,
                stringify ! ( ipv6mr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_mreq ) ) . ipv6mr_interface as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_mreq ) , "::" ,
                stringify ! ( ipv6mr_interface ) ));
}
impl Clone for ipv6_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(::std::mem::size_of::<group_req>() , 136usize , concat ! (
               "Size of: " , stringify ! ( group_req ) ));
    assert_eq! (::std::mem::align_of::<group_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( group_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_req ) ) . gr_interface as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_req ) , "::" ,
                stringify ! ( gr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_req ) ) . gr_group as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_req ) , "::" ,
                stringify ! ( gr_group ) ));
}
#[repr(C)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(::std::mem::size_of::<group_source_req>() , 264usize , concat !
               ( "Size of: " , stringify ! ( group_source_req ) ));
    assert_eq! (::std::mem::align_of::<group_source_req>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( group_source_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_interface as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_group as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_source as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_source ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(::std::mem::size_of::<ip_msfilter>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ip_msfilter ) ));
    assert_eq! (::std::mem::align_of::<ip_msfilter>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_msfilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_interface as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_fmode as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_fmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_numsrc as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_numsrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_slist as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_slist ) ));
}
impl Clone for ip_msfilter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(::std::mem::size_of::<group_filter>() , 272usize , concat ! (
               "Size of: " , stringify ! ( group_filter ) ));
    assert_eq! (::std::mem::align_of::<group_filter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( group_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_interface as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_group as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_fmode as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_fmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_numsrc as * const _
                as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_numsrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_slist as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_slist ) ));
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(__sockfd: ::std::os::raw::c_int,
                        __sock_in: *mut sockaddr_in) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(__sockfd: ::std::os::raw::c_int,
                         __sock_in: *mut sockaddr_in6)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_addr(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_lnaof(__in: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_makeaddr(__net: in_addr_t, __host: in_addr_t) -> in_addr;
}
extern "C" {
    pub fn inet_netof(__in: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_network(__cp: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_ntoa(__in: in_addr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_pton(__af: ::std::os::raw::c_int,
                     __cp: *const ::std::os::raw::c_char,
                     __buf: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_ntop(__af: ::std::os::raw::c_int,
                     __cp: *const ::std::os::raw::c_void,
                     __buf: *mut ::std::os::raw::c_char, __len: socklen_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_aton(__cp: *const ::std::os::raw::c_char, __inp: *mut in_addr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_neta(__net: in_addr_t, __buf: *mut ::std::os::raw::c_char,
                     __len: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_ntop(__af: ::std::os::raw::c_int,
                         __cp: *const ::std::os::raw::c_void,
                         __bits: ::std::os::raw::c_int,
                         __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_pton(__af: ::std::os::raw::c_int,
                         __cp: *const ::std::os::raw::c_char,
                         __buf: *mut ::std::os::raw::c_void, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_nsap_addr(__cp: *const ::std::os::raw::c_char,
                          __buf: *mut ::std::os::raw::c_uchar,
                          __len: ::std::os::raw::c_int)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn inet_nsap_ntoa(__len: ::std::os::raw::c_int,
                          __cp: *const ::std::os::raw::c_uchar,
                          __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type tcp_seq = u_int32_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tcphdr {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tcphdr__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<tcphdr__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<tcphdr__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_1 {
    pub th_sport: u_int16_t,
    pub th_dport: u_int16_t,
    pub th_seq: tcp_seq,
    pub th_ack: tcp_seq,
    pub _bitfield_1: u8,
    pub th_flags: u_int8_t,
    pub th_win: u_int16_t,
    pub th_sum: u_int16_t,
    pub th_urp: u_int16_t,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>() ,
               20usize , concat ! (
               "Size of: " , stringify ! ( tcphdr__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_1 ) ) .
                th_sport as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                th_sport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_1 ) ) .
                th_dport as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                th_dport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_1 ) ) .
                th_seq as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                th_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_1 ) ) .
                th_ack as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                th_ack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_1 ) ) .
                th_flags as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                th_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_1 ) ) .
                th_win as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                th_win ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_1 ) ) .
                th_sum as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                th_sum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_1 ) ) .
                th_urp as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                th_urp ) ));
}
impl Clone for tcphdr__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl tcphdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn th_x2(&self) -> u_int8_t {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: u_int8_t) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn th_off(&self) -> u_int8_t {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: u_int8_t) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(th_x2: u_int8_t, th_off: u_int8_t) -> u8 {
        ({ ({ 0 } | ((th_x2 as u8 as u8) << 0usize) & (15u64 as u8)) } |
             ((th_off as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_2 {
    pub source: u_int16_t,
    pub dest: u_int16_t,
    pub seq: u_int32_t,
    pub ack_seq: u_int32_t,
    pub _bitfield_1: [u8; 2usize],
    pub window: u_int16_t,
    pub check: u_int16_t,
    pub urg_ptr: u_int16_t,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>() ,
               20usize , concat ! (
               "Size of: " , stringify ! ( tcphdr__bindgen_ty_1__bindgen_ty_2
               ) ));
    assert_eq! (::std::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_2 ) ) .
                source as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_2 ) ) .
                dest as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                dest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_2 ) ) .
                seq as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_2 ) ) .
                ack_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                ack_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_2 ) ) .
                window as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_2 ) ) .
                check as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                check ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr__bindgen_ty_1__bindgen_ty_2 ) ) .
                urg_ptr as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                tcphdr__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                urg_ptr ) ));
}
impl Clone for tcphdr__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl tcphdr__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn res1(&self) -> u_int16_t {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 15u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u_int16_t) {
        let mask = 15u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn doff(&self) -> u_int16_t {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 240u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: u_int16_t) {
        let mask = 240u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn fin(&self) -> u_int16_t {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: u_int16_t) {
        let mask = 256u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn syn(&self) -> u_int16_t {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 512u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: u_int16_t) {
        let mask = 512u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn rst(&self) -> u_int16_t {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1024u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: u_int16_t) {
        let mask = 1024u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn psh(&self) -> u_int16_t {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2048u64 as u16;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: u_int16_t) {
        let mask = 2048u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ack(&self) -> u_int16_t {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4096u64 as u16;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: u_int16_t) {
        let mask = 4096u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn urg(&self) -> u_int16_t {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8192u64 as u16;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: u_int16_t) {
        let mask = 8192u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn res2(&self) -> u_int16_t {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 49152u64 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u_int16_t) {
        let mask = 49152u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(res1: u_int16_t, doff: u_int16_t, fin: u_int16_t,
                          syn: u_int16_t, rst: u_int16_t, psh: u_int16_t,
                          ack: u_int16_t, urg: u_int16_t, res2: u_int16_t)
     -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({ 0 } |
                                                     ((res1 as u16 as u16) <<
                                                          0usize) &
                                                         (15u64 as u16))
                                            } |
                                                ((doff as u16 as u16) <<
                                                     4usize) &
                                                    (240u64 as u16))
                                       } |
                                           ((fin as u16 as u16) << 8usize) &
                                               (256u64 as u16))
                                  } |
                                      ((syn as u16 as u16) << 9usize) &
                                          (512u64 as u16))
                             } |
                                 ((rst as u16 as u16) << 10usize) &
                                     (1024u64 as u16))
                        } |
                            ((psh as u16 as u16) << 11usize) &
                                (2048u64 as u16))
                   } | ((ack as u16 as u16) << 12usize) & (4096u64 as u16))
              } | ((urg as u16 as u16) << 13usize) & (8192u64 as u16))
         } | ((res2 as u16 as u16) << 14usize) & (49152u64 as u16))
    }
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<tcphdr__bindgen_ty_1>() , 20usize ,
               concat ! ( "Size of: " , stringify ! ( tcphdr__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<tcphdr__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( tcphdr__bindgen_ty_1 ) ));
}
impl Clone for tcphdr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_tcphdr() {
    assert_eq!(::std::mem::size_of::<tcphdr>() , 20usize , concat ! (
               "Size of: " , stringify ! ( tcphdr ) ));
    assert_eq! (::std::mem::align_of::<tcphdr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( tcphdr ) ));
}
impl Clone for tcphdr {
    fn clone(&self) -> Self { *self }
}
pub const TCP_ESTABLISHED: _bindgen_ty_12 = _bindgen_ty_12::TCP_ESTABLISHED;
pub const TCP_SYN_SENT: _bindgen_ty_12 = _bindgen_ty_12::TCP_SYN_SENT;
pub const TCP_SYN_RECV: _bindgen_ty_12 = _bindgen_ty_12::TCP_SYN_RECV;
pub const TCP_FIN_WAIT1: _bindgen_ty_12 = _bindgen_ty_12::TCP_FIN_WAIT1;
pub const TCP_FIN_WAIT2: _bindgen_ty_12 = _bindgen_ty_12::TCP_FIN_WAIT2;
pub const TCP_TIME_WAIT: _bindgen_ty_12 = _bindgen_ty_12::TCP_TIME_WAIT;
pub const TCP_CLOSE: _bindgen_ty_12 = _bindgen_ty_12::TCP_CLOSE;
pub const TCP_CLOSE_WAIT: _bindgen_ty_12 = _bindgen_ty_12::TCP_CLOSE_WAIT;
pub const TCP_LAST_ACK: _bindgen_ty_12 = _bindgen_ty_12::TCP_LAST_ACK;
pub const TCP_LISTEN: _bindgen_ty_12 = _bindgen_ty_12::TCP_LISTEN;
pub const TCP_CLOSING: _bindgen_ty_12 = _bindgen_ty_12::TCP_CLOSING;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_12 {
    TCP_ESTABLISHED = 1,
    TCP_SYN_SENT = 2,
    TCP_SYN_RECV = 3,
    TCP_FIN_WAIT1 = 4,
    TCP_FIN_WAIT2 = 5,
    TCP_TIME_WAIT = 6,
    TCP_CLOSE = 7,
    TCP_CLOSE_WAIT = 8,
    TCP_LAST_ACK = 9,
    TCP_LISTEN = 10,
    TCP_CLOSING = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum tcp_ca_state {
    TCP_CA_Open = 0,
    TCP_CA_Disorder = 1,
    TCP_CA_CWR = 2,
    TCP_CA_Recovery = 3,
    TCP_CA_Loss = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tcp_info {
    pub tcpi_state: u_int8_t,
    pub tcpi_ca_state: u_int8_t,
    pub tcpi_retransmits: u_int8_t,
    pub tcpi_probes: u_int8_t,
    pub tcpi_backoff: u_int8_t,
    pub tcpi_options: u_int8_t,
    pub _bitfield_1: u8,
    pub tcpi_rto: u_int32_t,
    pub tcpi_ato: u_int32_t,
    pub tcpi_snd_mss: u_int32_t,
    pub tcpi_rcv_mss: u_int32_t,
    pub tcpi_unacked: u_int32_t,
    pub tcpi_sacked: u_int32_t,
    pub tcpi_lost: u_int32_t,
    pub tcpi_retrans: u_int32_t,
    pub tcpi_fackets: u_int32_t,
    pub tcpi_last_data_sent: u_int32_t,
    pub tcpi_last_ack_sent: u_int32_t,
    pub tcpi_last_data_recv: u_int32_t,
    pub tcpi_last_ack_recv: u_int32_t,
    pub tcpi_pmtu: u_int32_t,
    pub tcpi_rcv_ssthresh: u_int32_t,
    pub tcpi_rtt: u_int32_t,
    pub tcpi_rttvar: u_int32_t,
    pub tcpi_snd_ssthresh: u_int32_t,
    pub tcpi_snd_cwnd: u_int32_t,
    pub tcpi_advmss: u_int32_t,
    pub tcpi_reordering: u_int32_t,
    pub tcpi_rcv_rtt: u_int32_t,
    pub tcpi_rcv_space: u_int32_t,
    pub tcpi_total_retrans: u_int32_t,
}
#[test]
fn bindgen_test_layout_tcp_info() {
    assert_eq!(::std::mem::size_of::<tcp_info>() , 104usize , concat ! (
               "Size of: " , stringify ! ( tcp_info ) ));
    assert_eq! (::std::mem::align_of::<tcp_info>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( tcp_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_ca_state as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_ca_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_retransmits as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_retransmits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_probes as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_probes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_backoff as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_backoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_options as * const _
                as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rto as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_ato as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_ato ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_snd_mss as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_snd_mss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rcv_mss as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rcv_mss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_unacked as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_unacked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_sacked as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_sacked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_lost as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_lost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_retrans as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_retrans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_fackets as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_fackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_last_data_sent as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_last_data_sent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_last_ack_sent as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_last_ack_sent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_last_data_recv as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_last_data_recv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_last_ack_recv as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_last_ack_recv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_pmtu as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_pmtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rcv_ssthresh as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rcv_ssthresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rtt as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rtt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rttvar as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rttvar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_snd_ssthresh as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_snd_ssthresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_snd_cwnd as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_snd_cwnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_advmss as * const _
                as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_advmss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_reordering as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_reordering ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rcv_rtt as * const _
                as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rcv_rtt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rcv_space as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rcv_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_total_retrans as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_total_retrans ) ));
}
impl Clone for tcp_info {
    fn clone(&self) -> Self { *self }
}
impl tcp_info {
    #[inline]
    pub fn tcpi_snd_wscale(&self) -> u_int8_t {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_tcpi_snd_wscale(&mut self, val: u_int8_t) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn tcpi_rcv_wscale(&self) -> u_int8_t {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_tcpi_rcv_wscale(&mut self, val: u_int8_t) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(tcpi_snd_wscale: u_int8_t,
                          tcpi_rcv_wscale: u_int8_t) -> u8 {
        ({
             ({ 0 } |
                  ((tcpi_snd_wscale as u8 as u8) << 0usize) & (15u64 as u8))
         } | ((tcpi_rcv_wscale as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
#[repr(C)]
pub struct tcp_md5sig {
    pub tcpm_addr: sockaddr_storage,
    pub __tcpm_pad1: u_int16_t,
    pub tcpm_keylen: u_int16_t,
    pub __tcpm_pad2: u_int32_t,
    pub tcpm_key: [u_int8_t; 80usize],
}
#[test]
fn bindgen_test_layout_tcp_md5sig() {
    assert_eq!(::std::mem::size_of::<tcp_md5sig>() , 216usize , concat ! (
               "Size of: " , stringify ! ( tcp_md5sig ) ));
    assert_eq! (::std::mem::align_of::<tcp_md5sig>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tcp_md5sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_md5sig ) ) . tcpm_addr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_md5sig ) , "::" ,
                stringify ! ( tcpm_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_md5sig ) ) . __tcpm_pad1 as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_md5sig ) , "::" ,
                stringify ! ( __tcpm_pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_md5sig ) ) . tcpm_keylen as * const _
                as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_md5sig ) , "::" ,
                stringify ! ( tcpm_keylen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_md5sig ) ) . __tcpm_pad2 as * const _
                as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_md5sig ) , "::" ,
                stringify ! ( __tcpm_pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_md5sig ) ) . tcpm_key as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_md5sig ) , "::" ,
                stringify ! ( tcpm_key ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tcp_repair_opt {
    pub opt_code: u_int32_t,
    pub opt_val: u_int32_t,
}
#[test]
fn bindgen_test_layout_tcp_repair_opt() {
    assert_eq!(::std::mem::size_of::<tcp_repair_opt>() , 8usize , concat ! (
               "Size of: " , stringify ! ( tcp_repair_opt ) ));
    assert_eq! (::std::mem::align_of::<tcp_repair_opt>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( tcp_repair_opt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_repair_opt ) ) . opt_code as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_repair_opt ) , "::"
                , stringify ! ( opt_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_repair_opt ) ) . opt_val as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_repair_opt ) , "::"
                , stringify ! ( opt_val ) ));
}
impl Clone for tcp_repair_opt {
    fn clone(&self) -> Self { *self }
}
pub const TCP_NO_QUEUE: _bindgen_ty_13 = _bindgen_ty_13::TCP_NO_QUEUE;
pub const TCP_RECV_QUEUE: _bindgen_ty_13 = _bindgen_ty_13::TCP_RECV_QUEUE;
pub const TCP_SEND_QUEUE: _bindgen_ty_13 = _bindgen_ty_13::TCP_SEND_QUEUE;
pub const TCP_QUEUES_NR: _bindgen_ty_13 = _bindgen_ty_13::TCP_QUEUES_NR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_13 {
    TCP_NO_QUEUE = 0,
    TCP_RECV_QUEUE = 1,
    TCP_SEND_QUEUE = 2,
    TCP_QUEUES_NR = 3,
}
#[repr(C)]
pub struct tcp_cookie_transactions {
    pub tcpct_flags: u_int16_t,
    pub __tcpct_pad1: u_int8_t,
    pub tcpct_cookie_desired: u_int8_t,
    pub tcpct_s_data_desired: u_int16_t,
    pub tcpct_used: u_int16_t,
    pub tcpct_value: [u_int8_t; 536usize],
}
#[test]
fn bindgen_test_layout_tcp_cookie_transactions() {
    assert_eq!(::std::mem::size_of::<tcp_cookie_transactions>() , 544usize ,
               concat ! (
               "Size of: " , stringify ! ( tcp_cookie_transactions ) ));
    assert_eq! (::std::mem::align_of::<tcp_cookie_transactions>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( tcp_cookie_transactions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_cookie_transactions ) ) . tcpct_flags
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_cookie_transactions
                ) , "::" , stringify ! ( tcpct_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_cookie_transactions ) ) .
                __tcpct_pad1 as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_cookie_transactions
                ) , "::" , stringify ! ( __tcpct_pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_cookie_transactions ) ) .
                tcpct_cookie_desired as * const _ as usize } , 3usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tcp_cookie_transactions
                ) , "::" , stringify ! ( tcpct_cookie_desired ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_cookie_transactions ) ) .
                tcpct_s_data_desired as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tcp_cookie_transactions
                ) , "::" , stringify ! ( tcpct_s_data_desired ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_cookie_transactions ) ) . tcpct_used
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_cookie_transactions
                ) , "::" , stringify ! ( tcpct_used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_cookie_transactions ) ) . tcpct_value
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_cookie_transactions
                ) , "::" , stringify ! ( tcpct_value ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(::std::mem::size_of::<flock>() , 32usize , concat ! (
               "Size of: " , stringify ! ( flock ) ));
    assert_eq! (::std::mem::align_of::<flock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( flock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const flock ) ) . l_type as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( flock ) , "::" ,
                stringify ! ( l_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const flock ) ) . l_whence as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( flock ) , "::" ,
                stringify ! ( l_whence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const flock ) ) . l_start as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( flock ) , "::" ,
                stringify ! ( l_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const flock ) ) . l_len as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( flock ) , "::" ,
                stringify ! ( l_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const flock ) ) . l_pid as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( flock ) , "::" ,
                stringify ! ( l_pid ) ));
}
impl Clone for flock {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn fcntl(__fd: ::std::os::raw::c_int,
                 __cmd: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open(__file: *const ::std::os::raw::c_char,
                __oflag: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(__fd: ::std::os::raw::c_int,
                  __file: *const ::std::os::raw::c_char,
                  __oflag: ::std::os::raw::c_int, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fadvise(__fd: ::std::os::raw::c_int, __offset: off_t,
                         __len: off_t, __advise: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fallocate(__fd: ::std::os::raw::c_int, __offset: off_t,
                           __len: off_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_14 {
    pub MajorVersion: uint8,
    pub MinorVersion: uint8,
    pub Revision: uint8,
    pub MissionRev: uint8,
}
#[test]
fn bindgen_test_layout__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_14>() , 4usize , concat ! (
               "Size of: " , stringify ! ( _bindgen_ty_14 ) ));
    assert_eq! (::std::mem::align_of::<_bindgen_ty_14>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( _bindgen_ty_14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_14 ) ) . MajorVersion as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_14 ) , "::"
                , stringify ! ( MajorVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_14 ) ) . MinorVersion as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_14 ) , "::"
                , stringify ! ( MinorVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_14 ) ) . Revision as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_14 ) , "::"
                , stringify ! ( Revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_14 ) ) . MissionRev as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_14 ) , "::"
                , stringify ! ( MissionRev ) ));
}
impl Clone for _bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
pub type CFE_PSP_VersionInfo_t = _bindgen_ty_14;
/**
 * PSP/Hardware configuration parameters
 * This structure should be instantiated by the PSP according
 * such that other modules do not need to directly include
 * the PSP configuration at compile time.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_15 {
    /**< PSP Minimum watchdog in milliseconds */
    pub PSP_WatchdogMin: uint32,
    /**< PSP Maximum watchdog in milliseconds */
    pub PSP_WatchdogMax: uint32,
    /**< Size of PSP memory table */
    pub PSP_MemTableSize: uint32,
    /**< Pointer to PSP memory table (forward reference) */
    pub PSP_MemoryTable: *mut CFE_PSP_MemTable_t,
    /**< Size of OS volume table */
    pub OS_VolumeTableSize: uint32,
    /**< Pointer to OS volume table (forward reference) */
    pub OS_VolumeTable: *mut OS_VolumeInfo_t,
    /**
    * Processor Context type.
    * This is needed to determine the size of the context entry in the ER log.
    * It is a placeholder as the implementation to use it is not merged in yet.
    */
    pub OS_CpuContextSize: uint32,
    /**
    * Number of EEPROM banks on this platform
    */
    pub HW_NumEepromBanks: uint32,
    pub PSP_VersionInfo: CFE_PSP_VersionInfo_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_15>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _bindgen_ty_15 ) ));
    assert_eq! (::std::mem::align_of::<_bindgen_ty_15>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _bindgen_ty_15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_15 ) ) . PSP_WatchdogMin as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_15 ) , "::"
                , stringify ! ( PSP_WatchdogMin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_15 ) ) . PSP_WatchdogMax as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_15 ) , "::"
                , stringify ! ( PSP_WatchdogMax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_15 ) ) . PSP_MemTableSize as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_15 ) , "::"
                , stringify ! ( PSP_MemTableSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_15 ) ) . PSP_MemoryTable as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_15 ) , "::"
                , stringify ! ( PSP_MemoryTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_15 ) ) . OS_VolumeTableSize
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_15 ) , "::"
                , stringify ! ( OS_VolumeTableSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_15 ) ) . OS_VolumeTable as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_15 ) , "::"
                , stringify ! ( OS_VolumeTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_15 ) ) . OS_CpuContextSize as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_15 ) , "::"
                , stringify ! ( OS_CpuContextSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_15 ) ) . HW_NumEepromBanks as
                * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_15 ) , "::"
                , stringify ! ( HW_NumEepromBanks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _bindgen_ty_15 ) ) . PSP_VersionInfo as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _bindgen_ty_15 ) , "::"
                , stringify ! ( PSP_VersionInfo ) ));
}
impl Clone for _bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
pub type Target_PspConfigData = _bindgen_ty_15;
extern "C" {
    #[link_name = "GLOBAL_PSP_CONFIGDATA"]
    pub static mut GLOBAL_PSP_CONFIGDATA: Target_PspConfigData;
}
extern "C" {
    #[link_name = "CFE_PSP_MemoryTable"]
    pub static mut CFE_PSP_MemoryTable: [CFE_PSP_MemTable_t; 0usize];
}
extern "C" {
    #[link_name = "OS_VolumeTable"]
    pub static mut OS_VolumeTable: [OS_VolumeInfo_t; 0usize];
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
