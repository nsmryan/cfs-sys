# CFS App in Rust
This crate provides bindings to the NASA [Core Flight Executive
(CFE)](https://github.com/nasa/cFE) and [Operational System Abstraction Layer
(OSAL)](https://github.com/nasa/osal). These provide a core set of
software components for building flight software systems, as well
as a mechanism to extend the system with additional modules called 
Core Flight Software (CFS) Apps. With the cfs-sys crate, you can write your CFS Apps in
Rust!


This is the base bindings generated by bindgen. A Rusty interface could be written
to wrap up all the unsafe FFI called and raw pointers.


## Building
This crate is intended to be used as a dependancy of a CFS App written in Rust.
There is an example of such an app at: 


This project has been tested with the i686-unknown-linux-gnu target
by building the POSIX implementation of OSAL.


To get this target using rustup, type
```shell
rustup target add i686-unknown-linux-gnu
```

To build this project, you need the following environment variables defined:


* OSAL\_DIR
* PSP\_DIR
* CFE\_FSW
* CFE\_CORE\_SRC
* CFS\_MISSION
* CFS\_MISSION\_INC


The easiest way to define these is to clone the 
[cFE github repository](https://github.com/nasa/cFE) and its submodules
(at least OSAL- the submodules in the app directory are not necessary).


Then go to your cloned cFE repository, and type the following to set up
the necessary environment variables:


```shell
. ./setvars.sh
```


##The Concept
This library is build using a build.rs file which uses bindgen to generate
binding to all of the OSAL, PSP, and CFE includes you would need to write
a CFE application.


Since each CFS project may be different, the bindings should really be
generated each time as part of the build process. In principal, however,
we could build bindings to a generic CFS project. This may require
assuming an operating system, or having a separate set of bindings, one
for each operating system. Even then, any changes to the PSP or mission
specific configuration would require regenerating the bindings, so this
may not be a good idea.



The library is configured to build a shared library, which in principal can
be loaded by CFE as a CFS application. This is yet to be seen.


## Note on Shared Object Size
When using the cfs-sys crate to write a CFS App, I've noticed that
I get a .so file 3MB by default, with lto=true and panic='abort'. Stripping
this gets down to about 200KOB.


For reference, other CFS apps are 8KB to 20KB or so. This works fine for
some environments, but in space it would be nice to have small object files to
assist in uploading new code through a slow, intermittent connection.


Compression with xz gets this down to 79KB, which is better, but still not
great.

## Macros in CFS
There are macros with arguments (aka inline functions) used in certain CFE modules.
There are listed below:
* ccsds.h
* cfs\_es.h
* cfs\_evs.h
* cfs\_tbl\_filedef.h
* cfs\_sb.h
* common\_types.h
* cfe\_platform\_cfg.h
* cfe\_psp\_module.h
 
